<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sea Ranch Quest - Level 6: Naturalist Trail</title>
    <script src="sea-ranch-style.js"></script>
    <style>
        :root {
            --black: #1a1a1a;
            --white: #f5f5f0;
            --red: #C41E3A;
            --blue: #2E5DA8;
            --wood: #8b7355;
            --sand: #d4c4a8;
            --fog: #e8e4dc;
        }

        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }
        #game-container {
            width: 640px;
            height: 480px;
            position: relative;
            overflow: hidden;
            background: #1a1a1a;
        }
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            display: block;
            image-rendering: pixelated;
        }

        /* HTML/CSS Title Card */
        .title-card {
            position: absolute;
            inset: 0;
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .title-card .wood-bg {
            position: absolute;
            inset: 0;
            background:
                repeating-linear-gradient(
                    90deg,
                    transparent 0px,
                    transparent 3px,
                    rgba(139, 115, 85, 0.08) 3px,
                    rgba(139, 115, 85, 0.08) 4px
                ),
                radial-gradient(ellipse at 20% 30%, rgba(139, 115, 85, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 70% 60%, rgba(139, 115, 85, 0.1) 0%, transparent 40%),
                radial-gradient(ellipse at 40% 80%, rgba(139, 115, 85, 0.12) 0%, transparent 45%),
                linear-gradient(180deg, var(--fog) 0%, var(--sand) 100%);
        }

        .title-card .supergraphic {
            position: absolute;
            top: -80px;
            right: -120px;
            width: 550px;
            height: 550px;
            pointer-events: none;
        }

        .title-card .supergraphic::before,
        .title-card .supergraphic::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            border: 36px solid var(--blue);
        }

        .title-card .supergraphic::before {
            width: 420px;
            height: 420px;
            top: 0;
            right: 0;
            border-color: transparent transparent var(--blue) var(--blue);
            transform: rotate(-45deg);
        }

        .title-card .supergraphic::after {
            width: 320px;
            height: 320px;
            top: 50px;
            right: 50px;
            border-color: transparent transparent var(--blue) var(--blue);
            transform: rotate(-45deg);
            opacity: 0.7;
        }

        .title-card .arrow-accent {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 80px;
            height: 100px;
            pointer-events: none;
        }

        .title-card .arrow-accent::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 40px solid transparent;
            border-right: 40px solid transparent;
            border-bottom: 50px solid var(--red);
            top: 0;
        }

        .title-card .arrow-accent::after {
            content: '';
            position: absolute;
            width: 26px;
            height: 50px;
            background: var(--red);
            top: 45px;
            left: 27px;
        }

        .title-card .title-content {
            position: relative;
            z-index: 10;
            text-align: center;
        }

        .title-card .level-title {
            font-size: 56px;
            font-weight: 700;
            color: var(--black);
            letter-spacing: -2px;
            line-height: 1;
            margin-bottom: 10px;
        }

        .title-card .level-subtitle {
            font-size: 18px;
            font-weight: 400;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: var(--wood);
        }

        .title-card .continue-hint {
            position: absolute;
            bottom: 36px;
            right: 36px;
            font-size: 12px;
            color: var(--wood);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .title-card .title-grain {
            position: absolute;
            inset: 0;
            opacity: 0.4;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%' height='100%' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* Complete Screen Overlay */
        .complete-card {
            position: absolute;
            inset: 0;
            z-index: 200;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .complete-card.visible {
            display: flex;
        }

        .complete-card .wood-bg {
            position: absolute;
            inset: 0;
            background:
                repeating-linear-gradient(
                    90deg,
                    transparent 0px,
                    transparent 3px,
                    rgba(139, 115, 85, 0.08) 3px,
                    rgba(139, 115, 85, 0.08) 4px
                ),
                radial-gradient(ellipse at 20% 30%, rgba(139, 115, 85, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 70% 60%, rgba(139, 115, 85, 0.1) 0%, transparent 40%),
                radial-gradient(ellipse at 40% 80%, rgba(139, 115, 85, 0.12) 0%, transparent 45%),
                linear-gradient(180deg, var(--fog) 0%, var(--sand) 100%);
        }

        .complete-card .supergraphic {
            position: absolute;
            top: -80px;
            right: -120px;
            width: 550px;
            height: 550px;
            pointer-events: none;
        }

        .complete-card .supergraphic::before,
        .complete-card .supergraphic::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            border: 36px solid var(--blue);
        }

        .complete-card .supergraphic::before {
            width: 420px;
            height: 420px;
            top: 0;
            right: 0;
            border-color: transparent transparent var(--blue) var(--blue);
            transform: rotate(-45deg);
        }

        .complete-card .supergraphic::after {
            width: 320px;
            height: 320px;
            top: 50px;
            right: 50px;
            border-color: transparent transparent var(--blue) var(--blue);
            transform: rotate(-45deg);
            opacity: 0.7;
        }

        .complete-card .complete-header {
            position: relative;
            z-index: 10;
            text-align: center;
            margin-top: 20px;
            margin-bottom: 18px;
        }

        .complete-card .complete-title {
            font-size: 42px;
            font-weight: 800;
            color: var(--black);
            letter-spacing: -2px;
            line-height: 1;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .complete-card .complete-subtitle {
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: var(--blue);
        }

        /* ═══════════════════════════════════════════════════════════════
           SPECIES CARD - Supergraphic Style
           ═══════════════════════════════════════════════════════════════ */
        .complete-card .species-card {
            position: relative;
            z-index: 10;
            width: 560px;
            background: var(--fog);
            box-shadow: 0 12px 40px rgba(0,0,0,0.25);
            overflow: hidden;
        }

        /* Sweeping curve on species card */
        .complete-card .species-card::before {
            content: '';
            position: absolute;
            width: 600px;
            height: 600px;
            bottom: -450px;
            left: -200px;
            border: 45px solid var(--blue);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1;
            opacity: 0.3;
        }

        .complete-card .species-header {
            position: relative;
            z-index: 5;
            background: var(--blue);
            color: white;
            text-align: center;
            padding: 14px 15px;
            font-size: 12px;
            font-weight: 800;
            letter-spacing: 3px;
        }

        .complete-card .species-grid {
            position: relative;
            z-index: 5;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            padding: 16px 14px;
            background: linear-gradient(180deg, var(--fog) 0%, var(--sand) 100%);
        }

        .complete-card .species-item {
            text-align: center;
            position: relative;
            padding: 10px 4px 8px;
            background: white;
            border: 2px solid transparent;
            transition: all 0.15s ease;
        }

        .complete-card .species-item.observed {
            border-color: var(--blue);
        }

        .complete-card .species-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(46, 93, 168, 0.2);
        }

        .complete-card .species-icon {
            width: 56px;
            height: 56px;
            margin: 0 auto 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--fog);
            border-radius: 50%;
            border: 2px solid var(--sand);
        }

        .complete-card .species-check {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 20px;
            height: 20px;
            background: var(--blue);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .complete-card .species-check::after {
            content: '✓';
            color: white;
            font-size: 11px;
            font-weight: bold;
        }

        .complete-card .species-name {
            font-size: 8px;
            color: var(--black);
            font-weight: 700;
            letter-spacing: 0.5px;
            line-height: 1.2;
            text-transform: uppercase;
        }

        .complete-card .species-footer {
            position: relative;
            z-index: 5;
            height: 8px;
            background: var(--red);
        }

        .complete-card .controls {
            position: relative;
            z-index: 10;
            display: flex;
            justify-content: center;
            gap: 50px;
            margin-top: 20px;
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 2px;
        }

        .complete-card .control-replay {
            color: var(--blue);
        }

        .complete-card .control-menu {
            color: var(--red);
        }

        .complete-card .success-msg {
            position: relative;
            z-index: 10;
            margin-top: 14px;
            font-size: 16px;
            font-weight: 800;
            color: var(--blue);
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .complete-card .grain {
            position: absolute;
            inset: 0;
            opacity: 0.25;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%' height='100%' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* Results Screen Overlay */
        .results-card {
            position: absolute;
            inset: 0;
            z-index: 200;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .results-card.visible {
            display: flex;
        }

        .results-card .wood-bg {
            position: absolute;
            inset: 0;
            background:
                repeating-linear-gradient(
                    90deg,
                    transparent 0px,
                    transparent 3px,
                    rgba(139, 115, 85, 0.08) 3px,
                    rgba(139, 115, 85, 0.08) 4px
                ),
                radial-gradient(ellipse at 20% 30%, rgba(139, 115, 85, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 70% 60%, rgba(139, 115, 85, 0.1) 0%, transparent 40%),
                radial-gradient(ellipse at 40% 80%, rgba(139, 115, 85, 0.12) 0%, transparent 45%),
                linear-gradient(180deg, var(--fog) 0%, var(--sand) 100%);
        }

        .results-card .supergraphic {
            position: absolute;
            top: -80px;
            right: -120px;
            width: 550px;
            height: 550px;
            pointer-events: none;
        }

        .results-card .supergraphic::before,
        .results-card .supergraphic::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            border: 36px solid var(--blue);
        }

        .results-card .supergraphic::before {
            width: 420px;
            height: 420px;
            top: 0;
            right: 0;
            border-color: transparent transparent var(--blue) var(--blue);
            transform: rotate(-45deg);
        }

        .results-card .supergraphic::after {
            width: 320px;
            height: 320px;
            top: 50px;
            right: 50px;
            border-color: transparent transparent var(--blue) var(--blue);
            transform: rotate(-45deg);
            opacity: 0.7;
        }

        /* ═══════════════════════════════════════════════════════════════
           NOTEBOOK - Barbara Stauffacher Solomon Supergraphic Style
           Bold curves, geometric shapes, Sea Ranch aesthetic
           ═══════════════════════════════════════════════════════════════ */
        .results-card .notebook {
            position: relative;
            z-index: 10;
            width: 380px;
            min-height: 300px;
            background: #e8e4dc;
            box-shadow: 0 12px 40px rgba(0,0,0,0.25);
            border: 3px solid #2E5DA8;
            overflow: visible;
        }

        /* Giant sweeping blue curve - the signature supergraphic */
        .results-card .notebook::before {
            content: '';
            position: absolute;
            width: 500px;
            height: 500px;
            top: -320px;
            right: -180px;
            border: 50px solid var(--blue);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1;
        }

        /* Second concentric curve */
        .results-card .notebook::after {
            content: '';
            position: absolute;
            width: 380px;
            height: 380px;
            top: -240px;
            right: -100px;
            border: 32px solid var(--blue);
            border-radius: 50%;
            opacity: 0.5;
            pointer-events: none;
            z-index: 1;
        }

        .results-card .notebook-header {
            position: relative;
            z-index: 5;
            background: var(--blue);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 2px;
        }

        .results-card .notebook-body {
            position: relative;
            z-index: 5;
            padding: 20px 24px 16px;
            text-align: center;
            background: linear-gradient(180deg, var(--fog) 0%, var(--sand) 100%);
        }

        /* Habitat tag - bold geometric pill */
        .results-card .habitat-tag {
            display: inline-block;
            background: #C41E3A !important;
            color: white !important;
            font-size: 9px;
            font-weight: 800;
            letter-spacing: 2px;
            padding: 5px 16px;
            margin-bottom: 14px;
            text-transform: uppercase;
        }

        /* Wildlife display - clean circle frame inspired by Sea Ranch ram logo */
        .results-card .wildlife-frame {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 0 auto 16px;
            background: white !important;
            border-radius: 50% !important;
            border: 4px solid #2E5DA8 !important;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(46, 93, 168, 0.2);
        }

        /* No corner marks - clean geometric circle */
        .results-card .wildlife-frame::before,
        .results-card .wildlife-frame::after {
            display: none;
        }

        .results-card .wildlife-icon {
            height: 70px;
            width: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .results-card .wildlife-name {
            font-size: 28px;
            font-weight: 800;
            color: var(--black);
            margin-bottom: 2px;
            letter-spacing: -1px;
            text-transform: uppercase;
        }

        /* Scientific name - elegant italic beneath */
        .results-card .wildlife-latin {
            font-size: 12px;
            font-style: italic;
            color: var(--blue);
            margin-bottom: 12px;
            font-weight: 400;
        }

        /* Bold geometric divider */
        .results-card .divider {
            width: 60px;
            height: 4px;
            background: var(--blue);
            margin: 0 auto 12px;
        }

        .results-card .wildlife-fact {
            font-size: 13px;
            color: var(--wood);
            line-height: 1.5;
            margin-bottom: 16px;
            min-height: 40px;
            font-style: normal;
            font-weight: 500;
        }

        /* Sighting quality - bold bar design */
        .results-card .sighting-section {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
            padding: 12px 0 4px;
            border-top: 3px solid var(--blue);
        }

        .results-card .quality-badge {
            font-size: 12px;
            font-weight: 800;
            letter-spacing: 2px;
            padding: 6px 16px;
            background: var(--black);
            color: white;
        }

        .results-card .quality-badge.missed {
            background: var(--red);
            color: white;
        }
        .results-card .quality-badge.glimpse {
            background: var(--wood);
            color: white;
        }
        .results-card .quality-badge.good {
            background: var(--blue);
            color: white;
        }
        .results-card .quality-badge.excellent {
            background: #2a8a4a;
            color: white;
        }

        .results-card .rating-dots {
            display: flex;
            justify-content: center;
            gap: 8px;
        }

        .results-card .rating-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 3px solid var(--wood);
            background: transparent;
            transition: all 0.2s ease;
        }

        .results-card .rating-dot.filled.missed { background: var(--red); border-color: var(--red); }
        .results-card .rating-dot.filled.glimpse { background: var(--wood); border-color: var(--wood); }
        .results-card .rating-dot.filled.good { background: var(--blue); border-color: var(--blue); }
        .results-card .rating-dot.filled.excellent { background: #2a8a4a; border-color: #2a8a4a; }

        .results-card .controls {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: 30px;
            margin-top: 20px;
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 2px;
        }

        .results-card .control-continue {
            color: var(--blue);
        }

        .results-card .control-menu {
            color: var(--red);
        }

        .results-card .grain {
            position: absolute;
            inset: 0;
            opacity: 0.3;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%' height='100%' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* Allow keyboard events to pass through overlays */
        .results-card, .complete-card {
            pointer-events: none;
        }
        .results-card *, .complete-card * {
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- HTML/CSS Title Card -->
        <div class="title-card" id="title-card">
            <div class="wood-bg"></div>
            <div class="supergraphic"></div>
            <div class="arrow-accent"></div>
            <div class="title-content">
                <div class="level-title">Naturalist Trail</div>
                <div class="level-subtitle">A 10-Mile Photo Journey</div>
            </div>
            <div class="continue-hint">A to start · B to menu</div>
            <div class="title-grain"></div>
        </div>

        <!-- HTML/CSS Results Card -->
        <div class="results-card" id="results-card">
            <div class="wood-bg"></div>
            <div class="supergraphic"></div>
            <div class="notebook">
                <div class="notebook-header">
                    <span id="results-stop">STOP 1 OF 10</span>
                    <span id="results-location">SEA RANCH LODGE</span>
                </div>
                <div class="notebook-body">
                    <div class="habitat-tag" id="results-habitat">MEADOW</div>
                    <div class="wildlife-frame">
                        <div class="wildlife-icon" id="results-icon"></div>
                    </div>
                    <div class="wildlife-name" id="results-wildlife">Black Phoebe</div>
                    <div class="wildlife-latin" id="results-latin">Sayornis nigricans</div>
                    <div class="divider"></div>
                    <div class="wildlife-fact" id="results-fact">Bobs its tail constantly while perched—a behavior unique among flycatchers!</div>
                    <div class="sighting-section">
                        <div class="quality-badge" id="results-quality">GLIMPSE</div>
                        <div class="rating-dots" id="results-dots"></div>
                    </div>
                </div>
            </div>
            <div class="controls">
                <span class="control-continue">A: CONTINUE</span>
                <span class="control-menu">B: MENU</span>
            </div>
            <div class="grain"></div>
        </div>

        <!-- HTML/CSS Complete Card -->
        <div class="complete-card" id="complete-card">
            <div class="wood-bg"></div>
            <div class="supergraphic"></div>
            <div class="complete-header">
                <div class="complete-title">Trail Complete</div>
                <div class="complete-subtitle">Bluff Trail • Sea Ranch, CA</div>
            </div>
            <div class="species-card">
                <div class="species-header">SPECIES OBSERVED</div>
                <div class="species-grid" id="species-grid">
                    <!-- Species items will be populated by JavaScript -->
                </div>
                <div class="species-footer"></div>
            </div>
            <div class="controls">
                <span class="control-replay">A: REPLAY</span>
                <span class="control-menu">B: MENU</span>
            </div>
            <div class="success-msg">All species documented!</div>
            <div class="grain"></div>
        </div>

        <canvas id="gameCanvas" width="640" height="480"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        let ctx = canvas.getContext('2d');  // let instead of const so we can temporarily swap for icon drawing
        const width = canvas.width;
        const height = canvas.height;

        // ============== BACKGROUND IMAGE LOADING ==============
        // Static pixel art backgrounds for each scene
        const sceneBackgrounds = {};
        let imagesLoaded = 0;
        const totalImages = 10;

        // Scene background paths - chunky pixel art PNGs for each scene
        const SCENE_IMAGES = [
            'level-6/backgrounds/second-draft/scene-1-chunky.png',
            'level-6/backgrounds/second-draft/scene-2-chunky.png',
            'level-6/backgrounds/second-draft/scene-3-chunky.png',
            'level-6/backgrounds/second-draft/scene-4-chunky.png',
            'level-6/backgrounds/second-draft/scene-5-chunky.png',
            'level-6/backgrounds/second-draft/scene-6-chunky.png',
            'level-6/backgrounds/second-draft/scene-7-chunky.png',
            'level-6/backgrounds/second-draft/scene-8-chunky.png',
            'level-6/backgrounds/second-draft/scene-9-chunky.png',
            'level-6/backgrounds/second-draft/scene-10-chunky.png'
        ];

        // Load all background images
        function loadBackgroundImages() {
            SCENE_IMAGES.forEach((src, index) => {
                const img = new Image();
                img.onload = () => {
                    sceneBackgrounds[index] = img;
                    imagesLoaded++;
                    console.log(`Loaded scene ${index + 1}: ${src}`);
                };
                img.onerror = () => {
                    // If image doesn't exist, we'll fall back to procedural rendering
                    console.log(`Scene ${index + 1} image not found, using procedural fallback`);
                    sceneBackgrounds[index] = null;
                    imagesLoaded++;
                };
                img.src = src;
            });
        }

        // Draw background - uses static image if available, falls back to procedural
        function drawSceneBackground(sceneIndex) {
            if (sceneBackgrounds[sceneIndex]) {
                // Draw the static pixel art background
                ctx.drawImage(sceneBackgrounds[sceneIndex], 0, 0, width, height);
                return true; // Image was drawn
            }
            return false; // No image, use procedural fallback
        }

        // Start loading images immediately
        loadBackgroundImages();

        // ============== TITLE SCREEN ASSETS ==============
        // Lodge background and cyclist sprite for opening scene
        let lodgeImage = null;
        let cyclistImage = null;

        function loadTitleAssets() {
            // Load lodge background
            const lodge = new Image();
            lodge.onload = () => {
                lodgeImage = lodge;
                console.log('Loaded lodge background');
            };
            lodge.onerror = () => {
                console.log('Lodge image not found, using procedural fallback');
            };
            lodge.src = 'level-6/assets/lodge.jpg';

            // Load cyclist sprite
            const cyclist = new Image();
            cyclist.onload = () => {
                cyclistImage = cyclist;
                console.log('Loaded cyclist sprite');
            };
            cyclist.onerror = () => {
                console.log('Cyclist image not found, using procedural fallback');
            };
            cyclist.src = 'level-6/assets/cyclist.png';

            // Load post sprite
            const post = new Image();
            post.onload = () => {
                postImage = post;
                console.log('Loaded post sprite');
            };
            post.onerror = () => {
                console.log('Post image not found, using procedural fallback');
            };
            post.src = 'level-6/assets/post-sprite.png';
        }

        let postImage = null;

        // Start loading title assets immediately
        loadTitleAssets();

        // Game state
        let gameState = 'title'; // title, departure, biking, photo, results, complete
        let departureTimer = 0;
        let currentStop = 0;
        let time = 0;
        let keys = {};

        // Biking cutscene state
        let bikeProgress = 0;
        let bikeRoadOffset = 0;
        const BIKE_DURATION = 210; // 3.5 seconds at 60fps
        const ARRIVING_DURATION = 45; // 0.75 seconds at 60fps - snappy arrival
        let arrivingTimer = 0;

        // Photo mode state
        let camera = { x: 320, y: 240, zoom: 1 };
        let photoTaken = false;
        let photoScore = 0;
        let photoTimer = 0;
        const PHOTO_TIME_LIMIT = 900; // 15 seconds at 60fps
        let photoFlashTimer = 0;

        // Binocular mechanic
        let binocularsRaised = false;
        let binocularLiftProgress = 0; // 0 = lowered, 1 = fully raised
        const BINOCULAR_LIFT_SPEED = 0.12; // Faster lift for snappier feel
        let focusX = 320;
        let focusY = 240;
        const BINOCULAR_RADIUS = 85; // Slightly larger view circles
        let binocularHoldTime = 0; // Track how long binoculars held up

        // Wildlife state - enhanced for playful behavior
        let wildlife = {
            x: 0, y: 0,
            vx: 0, vy: 0,
            targetX: 0, targetY: 0,
            homeX: 0, homeY: 0,
            visible: false,
            animFrame: 0,
            behavior: 'idle',
            shyness: 0.5, // 0-1, how scared of camera
            energy: 1.0,  // affects movement speed
            restTimer: 0,
            fleeTimer: 0
        };

        // ============== PIXEL ART PALETTE ==============
        // Sea Ranch inspired limited palette for cohesive pixel art look
        const PALETTE = {
            // Sky colors
            skyLight: '#87CEEB',
            skyMid: '#5BA3C6',
            skyDark: '#3A7CA5',
            skyFog: '#B8C8D0',

            // Ocean colors
            oceanDeep: '#1A4A5A',
            oceanMid: '#2A6A7A',
            oceanLight: '#4A9AAA',
            oceanFoam: '#E8F4F8',

            // Land colors
            grassLight: '#9ACA6A',
            grassMid: '#7AAA5A',
            grassDark: '#5A8A4A',
            grassDry: '#B8A870',

            // Wood colors (weathered redwood)
            woodLight: '#A89078',
            woodMid: '#8A7060',
            woodDark: '#6A5040',
            woodWeathered: '#9A9080',

            // Sand/stone
            sandLight: '#D8C8A8',
            sandMid: '#C0B090',
            sandDark: '#A09070',
            stone: '#7A7A70',

            // Supergraphic colors
            superRed: '#C41E3A',
            superBlue: '#2E5DA8',
            superWhite: '#FFFFFF',
            superCream: '#F5F5F0',

            // UI colors
            uiDark: '#1A2A2E',
            uiBorder: '#2D4A3E',
            uiText: '#AAC4B4',
            uiAccent: '#C4A77D'
        };

        // ============== PIXEL ART DRAWING HELPERS ==============
        const PIXEL_SIZE = 2; // Base pixel size for chunky look

        function pixelRect(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(
                Math.floor(x / PIXEL_SIZE) * PIXEL_SIZE,
                Math.floor(y / PIXEL_SIZE) * PIXEL_SIZE,
                Math.ceil(w / PIXEL_SIZE) * PIXEL_SIZE,
                Math.ceil(h / PIXEL_SIZE) * PIXEL_SIZE
            );
        }

        function pixelCircle(cx, cy, r, color) {
            ctx.fillStyle = color;
            const px = PIXEL_SIZE;
            for (let y = -r; y <= r; y += px) {
                for (let x = -r; x <= r; x += px) {
                    if (x * x + y * y <= r * r) {
                        ctx.fillRect(
                            Math.floor((cx + x) / px) * px,
                            Math.floor((cy + y) / px) * px,
                            px, px
                        );
                    }
                }
            }
        }

        function pixelLine(x1, y1, x2, y2, color, thickness = PIXEL_SIZE) {
            ctx.strokeStyle = color;
            ctx.lineWidth = thickness;
            ctx.lineCap = 'square';
            ctx.beginPath();
            ctx.moveTo(Math.floor(x1 / PIXEL_SIZE) * PIXEL_SIZE, Math.floor(y1 / PIXEL_SIZE) * PIXEL_SIZE);
            ctx.lineTo(Math.floor(x2 / PIXEL_SIZE) * PIXEL_SIZE, Math.floor(y2 / PIXEL_SIZE) * PIXEL_SIZE);
            ctx.stroke();
        }

        // Dithering pattern for gradients
        function ditherFill(x, y, w, h, color1, color2, density = 0.5) {
            ctx.fillStyle = color1;
            ctx.fillRect(x, y, w, h);
            ctx.fillStyle = color2;
            const px = PIXEL_SIZE;
            for (let py = y; py < y + h; py += px * 2) {
                for (let px2 = x; px2 < x + w; px2 += px * 2) {
                    if (Math.random() < density) {
                        ctx.fillRect(px2, py, px, px);
                    }
                    if (Math.random() < density) {
                        ctx.fillRect(px2 + px, py + px, px, px);
                    }
                }
            }
        }

        // Ordered dithering for consistent patterns (Bayer 4x4)
        const BAYER_4X4 = [
            [ 0,  8,  2, 10],
            [12,  4, 14,  6],
            [ 3, 11,  1,  9],
            [15,  7, 13,  5]
        ];

        function orderedDither(x, y, w, h, color1, color2, threshold = 0.5) {
            const px = PIXEL_SIZE;
            for (let py = 0; py < h; py += px) {
                for (let px2 = 0; px2 < w; px2 += px) {
                    const bx = Math.floor(px2 / px) % 4;
                    const by = Math.floor(py / px) % 4;
                    const t = BAYER_4X4[by][bx] / 16;
                    ctx.fillStyle = t < threshold ? color1 : color2;
                    ctx.fillRect(x + px2, y + py, px, px);
                }
            }
        }

        // ============== CHUNKY PIXEL ART FLORA ==============
        // Designed to match the chunky background art style

        function drawChunkyPoppy(x, y) {
            const px = PIXEL_SIZE;
            // Stem
            ctx.fillStyle = '#5A7A4A';
            pixelRect(x, y, px * 2, px * 8, '#5A7A4A');

            // Petals - bold orange/yellow
            const petalColor = '#FFB020';
            const petalDark = '#E89010';
            pixelRect(x - px * 3, y - px * 2, px * 3, px * 4, petalColor);
            pixelRect(x + px * 2, y - px * 2, px * 3, px * 4, petalColor);
            pixelRect(x - px * 1, y - px * 4, px * 4, px * 3, petalColor);
            pixelRect(x - px * 1, y + px, px * 4, px * 2, petalDark);

            // Center
            pixelRect(x, y - px, px * 2, px * 2, '#804000');
        }

        function drawChunkyLupine(x, y) {
            const px = PIXEL_SIZE;
            // Stem
            pixelRect(x, y, px * 2, px * 12, '#4A6A3A');

            // Flower spike - yellow blooms
            for (let i = 0; i < 4; i++) {
                const fy = y - px * 2 - i * px * 3;
                pixelRect(x - px * 2, fy, px * 2, px * 2, '#E8D44A');
                pixelRect(x + px * 2, fy, px * 2, px * 2, '#E8D44A');
            }
            // Top
            pixelRect(x, y - px * 14, px * 2, px * 2, '#F0E050');

            // Leaves
            pixelRect(x - px * 4, y + px * 4, px * 4, px * 2, '#5A8A4A');
            pixelRect(x + px * 2, y + px * 4, px * 4, px * 2, '#5A8A4A');
        }

        function drawChunkyDudleya(x, y) {
            const px = PIXEL_SIZE;
            // Succulent rosette - blue-gray
            const colors = ['#7A9080', '#8AA090', '#9AB0A0'];

            // Outer ring
            pixelRect(x - px * 6, y - px * 2, px * 4, px * 4, colors[0]);
            pixelRect(x + px * 4, y - px * 2, px * 4, px * 4, colors[0]);
            pixelRect(x - px * 2, y - px * 6, px * 4, px * 4, colors[0]);
            pixelRect(x - px * 2, y + px * 4, px * 4, px * 4, colors[0]);

            // Middle ring
            pixelRect(x - px * 4, y - px * 2, px * 3, px * 4, colors[1]);
            pixelRect(x + px * 3, y - px * 2, px * 3, px * 4, colors[1]);

            // Center
            pixelRect(x - px, y - px, px * 4, px * 4, colors[2]);
        }

        function drawChunkyPaintbrush(x, y) {
            const px = PIXEL_SIZE;
            // Stem
            pixelRect(x, y, px * 2, px * 10, '#4A6A4A');

            // Red brush bracts
            const reds = ['#D43020', '#E84030', '#C42010'];
            pixelRect(x - px * 2, y - px * 6, px * 2, px * 8, reds[0]);
            pixelRect(x, y - px * 8, px * 2, px * 10, reds[1]);
            pixelRect(x + px * 2, y - px * 6, px * 2, px * 8, reds[2]);

            // Yellow tips
            pixelRect(x - px, y - px * 10, px * 4, px * 2, '#C4D44A');
        }

        function drawChunkySeaThrift(x, y) {
            const px = PIXEL_SIZE;
            // Grass-like leaves
            pixelRect(x - px * 2, y, px * 2, px * 8, '#5A7A5A');
            pixelRect(x + px * 2, y, px * 2, px * 8, '#5A7A5A');

            // Pink pom-pom flower
            pixelRect(x - px * 3, y - px * 4, px * 8, px * 4, '#E090A0');
            pixelRect(x - px * 2, y - px * 6, px * 6, px * 2, '#E090A0');
            pixelRect(x - px * 2, y, px * 6, px * 2, '#D08090');
        }

        function drawChunkyBuckwheat(x, y) {
            const px = PIXEL_SIZE;
            // Stem
            pixelRect(x, y, px * 2, px * 8, '#8A7A5A');

            // Flower cluster - cream/white
            pixelRect(x - px * 4, y - px * 4, px * 10, px * 4, '#F0E8D8');
            pixelRect(x - px * 2, y - px * 6, px * 6, px * 2, '#F8F0E0');
        }

        function drawChunkySwordFern(x, y) {
            const px = PIXEL_SIZE;
            // Central stem
            pixelRect(x, y - px * 16, px * 2, px * 20, '#3A5A3A');

            // Fronds - alternating
            const fernGreen = '#4A7A4A';
            for (let i = 0; i < 6; i++) {
                const fy = y - px * 4 - i * px * 3;
                // Left frond
                pixelRect(x - px * 6 + i, fy, px * 6, px * 2, fernGreen);
                // Right frond
                pixelRect(x + px * 2, fy - px, px * 6 - i, px * 2, fernGreen);
            }
        }

        function drawChunkyPickleweed(x, y) {
            const px = PIXEL_SIZE;
            // Succulent marsh plant - green/red segments
            const segments = [
                {dx: 0, dy: 0, c: '#6A8A5A'},
                {dx: -px * 2, dy: -px * 3, c: '#7A9A6A'},
                {dx: px * 2, dy: -px * 3, c: '#8A6A5A'},
                {dx: 0, dy: -px * 6, c: '#9A5A4A'},
                {dx: -px * 3, dy: -px * 8, c: '#AA6A5A'},
                {dx: px * 3, dy: -px * 8, c: '#7A8A5A'},
            ];
            for (const s of segments) {
                pixelRect(x + s.dx, y + s.dy, px * 3, px * 4, s.c);
            }
        }

        function drawChunkyBeachStrawberry(x, y) {
            const px = PIXEL_SIZE;
            // Low spreading leaves
            pixelRect(x - px * 4, y, px * 10, px * 3, '#4A7A4A');
            pixelRect(x - px * 6, y + px, px * 4, px * 2, '#5A8A5A');
            pixelRect(x + px * 4, y + px, px * 4, px * 2, '#5A8A5A');

            // Small white flower
            pixelRect(x - px, y - px * 2, px * 4, px * 2, '#FFFFFF');
            pixelRect(x, y - px * 3, px * 2, px, '#FFFF80');
        }

        function drawChunkyMinersLettuce(x, y) {
            const px = PIXEL_SIZE;
            // Round leaf with stem through center
            pixelRect(x - px * 4, y - px * 2, px * 10, px * 6, '#8ABA7A');
            pixelRect(x - px * 2, y - px * 4, px * 6, px * 2, '#8ABA7A');
            pixelRect(x - px * 2, y + px * 4, px * 6, px * 2, '#8ABA7A');

            // Tiny white flowers in center
            pixelRect(x, y, px * 2, px * 2, '#FFFFFF');
        }

        // ============== CHARLEY HARPER STYLE FAUNA ==============
        // Bold geometric shapes, flat colors, simplified forms, strong silhouettes

        function drawChunkyBlackPhoebe(x, y, isStatic = false) {
            const px = PIXEL_SIZE;
            const tailBob = isStatic ? 0 : Math.sin(time * 0.25) * 3;

            ctx.save();
            ctx.translate(x, y);

            // Main body - bold black circle/oval
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.ellipse(0, 0, px * 7, px * 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // White belly - clean half circle
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.ellipse(0, px * 2, px * 5, px * 3, 0, 0, Math.PI);
            ctx.fill();

            // Head - perfect circle
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(-px * 6, -px * 2, px * 4, 0, Math.PI * 2);
            ctx.fill();

            // Eye - bold white circle
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(-px * 7, -px * 3, px * 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Beak - simple triangle
            ctx.fillStyle = '#2A2A2A';
            ctx.beginPath();
            ctx.moveTo(-px * 10, -px * 2);
            ctx.lineTo(-px * 14, -px * 1);
            ctx.lineTo(-px * 10, 0);
            ctx.fill();

            // Tail - distinctive bobbing rectangle
            ctx.fillStyle = '#1A1A1A';
            ctx.fillRect(px * 5, -px * 2 + tailBob, px * 12, px * 3);

            // Legs - thin lines
            ctx.strokeStyle = '#2A2A2A';
            ctx.lineWidth = px;
            ctx.beginPath();
            ctx.moveTo(-px * 2, px * 4);
            ctx.lineTo(-px * 2, px * 8);
            ctx.moveTo(px * 2, px * 4);
            ctx.lineTo(px * 2, px * 8);
            ctx.stroke();

            ctx.restore();
        }

        function drawChunkyHawk(x, y, isStatic = false) {
            const px = PIXEL_SIZE;
            const glide = isStatic ? 0 : Math.sin(time * 0.04) * 3;
            const wingTilt = isStatic ? 0 : Math.sin(time * 0.08) * 0.1;

            ctx.save();
            ctx.translate(x, y + glide);

            // Wings - bold angular shapes
            ctx.fillStyle = '#8B5A2B';
            ctx.save();
            ctx.rotate(wingTilt);
            // Left wing - triangle
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-px * 28, -px * 2);
            ctx.lineTo(-px * 24, px * 3);
            ctx.fill();
            ctx.restore();

            ctx.save();
            ctx.rotate(-wingTilt);
            // Right wing
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(px * 28, -px * 2);
            ctx.lineTo(px * 24, px * 3);
            ctx.fill();
            ctx.restore();

            // Body - sleek oval
            ctx.fillStyle = '#6B4423';
            ctx.beginPath();
            ctx.ellipse(0, px, px * 6, px * 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head - small circle
            ctx.fillStyle = '#7A5A3A';
            ctx.beginPath();
            ctx.arc(-px * 5, -px, px * 3, 0, Math.PI * 2);
            ctx.fill();

            // Hooked beak
            ctx.fillStyle = '#3A3A2A';
            ctx.beginPath();
            ctx.moveTo(-px * 8, -px);
            ctx.lineTo(-px * 12, 0);
            ctx.lineTo(-px * 10, px * 2);
            ctx.lineTo(-px * 8, px);
            ctx.fill();

            // Red tail - signature feature
            ctx.fillStyle = '#C44030';
            ctx.beginPath();
            ctx.moveTo(px * 4, 0);
            ctx.lineTo(px * 14, -px);
            ctx.lineTo(px * 14, px * 3);
            ctx.lineTo(px * 4, px * 2);
            ctx.fill();

            // Eye - fierce
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(-px * 6, -px * 2, px, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(-px * 6, -px * 2, px * 0.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawChunkyLizard(x, y, isStatic = false) {
            const px = PIXEL_SIZE;
            const scurry = isStatic ? 0 : Math.sin(time * 0.35) * 2;

            ctx.save();
            ctx.translate(x + scurry, y);

            // Body - streamlined oval
            ctx.fillStyle = '#5A6A6A';
            ctx.beginPath();
            ctx.ellipse(0, 0, px * 8, px * 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Blue belly patches - bold color blocks
            ctx.fillStyle = '#3A9ADA';
            ctx.beginPath();
            ctx.ellipse(-px * 2, px, px * 3, px * 1.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(px * 3, px, px * 2, px * 1.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head - triangular
            ctx.fillStyle = '#5A6A6A';
            ctx.beginPath();
            ctx.moveTo(-px * 8, 0);
            ctx.lineTo(-px * 14, -px * 2);
            ctx.lineTo(-px * 14, px * 2);
            ctx.fill();

            // Eye - bright
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(-px * 11, -px, px, 0, Math.PI * 2);
            ctx.fill();

            // Legs - angular, splayed
            ctx.fillStyle = '#4A5A5A';
            ctx.fillRect(-px * 5, px * 2, px * 2, px * 5);
            ctx.fillRect(px * 3, px * 2, px * 2, px * 5);
            ctx.fillRect(-px * 6, -px * 5, px * 2, px * 4);
            ctx.fillRect(px * 4, -px * 5, px * 2, px * 4);

            // Long tail - tapered
            ctx.fillStyle = '#5A6A6A';
            ctx.beginPath();
            ctx.moveTo(px * 7, -px);
            ctx.lineTo(px * 22, 0);
            ctx.lineTo(px * 7, px);
            ctx.fill();

            ctx.restore();
        }

        function drawChunkyHummingbird(x, y, isStatic = false) {
            const px = PIXEL_SIZE;
            const hover = isStatic ? 0 : Math.sin(time * 0.4) * 4;
            const wingPhase = isStatic ? 0 : time * 0.8;

            ctx.save();
            ctx.translate(x, y + hover);

            // Wings - blur effect with transparency
            ctx.fillStyle = 'rgba(100, 180, 140, 0.4)';
            const wingY = isStatic ? 0 : Math.sin(wingPhase) * px * 4;
            ctx.beginPath();
            ctx.ellipse(px * 2, -px * 2 + wingY, px * 8, px * 3, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Body - iridescent teardrop
            ctx.fillStyle = '#2A9A5A';
            ctx.beginPath();
            ctx.moveTo(-px * 4, 0);
            ctx.quadraticCurveTo(-px * 2, -px * 4, px * 4, 0);
            ctx.quadraticCurveTo(-px * 2, px * 4, -px * 4, 0);
            ctx.fill();

            // Gorget - brilliant magenta throat
            ctx.fillStyle = '#E020A0';
            ctx.beginPath();
            ctx.arc(-px * 3, 0, px * 2.5, 0, Math.PI * 2);
            ctx.fill();

            // Head - tiny
            ctx.fillStyle = '#2A8A5A';
            ctx.beginPath();
            ctx.arc(-px * 5, -px, px * 2, 0, Math.PI * 2);
            ctx.fill();

            // Beak - needle-like
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.moveTo(-px * 7, -px);
            ctx.lineTo(-px * 18, 0);
            ctx.lineTo(-px * 7, px);
            ctx.fill();

            // Eye - tiny dot
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(-px * 6, -px * 2, px * 0.8, 0, Math.PI * 2);
            ctx.fill();

            // Tail feathers
            ctx.fillStyle = '#1A6A4A';
            ctx.fillRect(px * 3, -px, px * 6, px * 2);

            ctx.restore();
        }

        function drawChunkyWoodpecker(x, y, isStatic = false) {
            const px = PIXEL_SIZE;
            const peck = isStatic ? 0 : Math.abs(Math.sin(time * 0.25)) * 3;

            ctx.save();
            ctx.translate(x, y);

            // Body - bold black oval
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.ellipse(0, px * 3, px * 5, px * 7, 0, 0, Math.PI * 2);
            ctx.fill();

            // White belly stripe
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(-px * 2, px, px * 4, px * 6);

            // Head - with red cap
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(-peck, -px * 5, px * 4, 0, Math.PI * 2);
            ctx.fill();

            // Red crown - bold
            ctx.fillStyle = '#DD2020';
            ctx.beginPath();
            ctx.arc(-peck, -px * 7, px * 3, Math.PI, 0);
            ctx.fill();

            // White face patch
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(-peck - px, -px * 4, px * 2, 0, Math.PI * 2);
            ctx.fill();

            // Eye - in white patch
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(-peck - px, -px * 4, px * 0.8, 0, Math.PI * 2);
            ctx.fill();

            // Chisel beak
            ctx.fillStyle = '#3A3A3A';
            ctx.beginPath();
            ctx.moveTo(-px * 4 - peck, -px * 5);
            ctx.lineTo(-px * 10 - peck, -px * 4);
            ctx.lineTo(-px * 4 - peck, -px * 3);
            ctx.fill();

            // Feet gripping
            ctx.fillStyle = '#3A3A3A';
            ctx.fillRect(-px * 6, px * 6, px * 3, px * 4);
            ctx.fillRect(px * 3, px * 6, px * 3, px * 4);

            ctx.restore();
        }

        function drawChunkyOystercatcher(x, y, isStatic = false) {
            const px = PIXEL_SIZE;
            const walk = isStatic ? 0 : Math.sin(time * 0.18) * 3;

            ctx.save();
            ctx.translate(x + walk, y);

            // Body - sleek black oval
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.ellipse(0, 0, px * 8, px * 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head - round
            ctx.beginPath();
            ctx.arc(-px * 7, -px * 2, px * 4, 0, Math.PI * 2);
            ctx.fill();

            // Striking orange-red beak - chisel shape
            ctx.fillStyle = '#E84420';
            ctx.beginPath();
            ctx.moveTo(-px * 11, -px * 2);
            ctx.lineTo(-px * 22, -px);
            ctx.lineTo(-px * 22, px);
            ctx.lineTo(-px * 11, 0);
            ctx.fill();

            // Eye ring - red
            ctx.fillStyle = '#DD2020';
            ctx.beginPath();
            ctx.arc(-px * 8, -px * 3, px * 1.8, 0, Math.PI * 2);
            ctx.fill();
            // Eye - yellow with black pupil
            ctx.fillStyle = '#FFDD00';
            ctx.beginPath();
            ctx.arc(-px * 8, -px * 3, px, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(-px * 8, -px * 3, px * 0.4, 0, Math.PI * 2);
            ctx.fill();

            // Pink legs - thin
            ctx.fillStyle = '#E090A0';
            ctx.fillRect(-px * 3, px * 4, px * 2, px * 8);
            ctx.fillRect(px * 2, px * 4, px * 2, px * 8);

            ctx.restore();
        }

        function drawChunkyMonarch(x, y, isStatic = false) {
            const px = PIXEL_SIZE;
            const flutter = isStatic ? 0 : Math.sin(time * 0.25) * 6;
            const wingAngle = isStatic ? 0 : Math.sin(time * 0.35) * 0.3;

            ctx.save();
            ctx.translate(x, y + flutter);

            // Wings - bold orange with black borders
            ctx.save();
            ctx.rotate(wingAngle);
            // Left wing
            ctx.fillStyle = '#F07020';
            ctx.beginPath();
            ctx.ellipse(-px * 8, 0, px * 7, px * 5, -0.2, 0, Math.PI * 2);
            ctx.fill();
            // Black border
            ctx.strokeStyle = '#1A1A1A';
            ctx.lineWidth = px * 2;
            ctx.stroke();
            // White spots
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(-px * 10, -px * 2, px, 0, Math.PI * 2);
            ctx.arc(-px * 10, px * 2, px, 0, Math.PI * 2);
            ctx.arc(-px * 6, 0, px, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            ctx.save();
            ctx.rotate(-wingAngle);
            // Right wing
            ctx.fillStyle = '#F07020';
            ctx.beginPath();
            ctx.ellipse(px * 8, 0, px * 7, px * 5, 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#1A1A1A';
            ctx.lineWidth = px * 2;
            ctx.stroke();
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(px * 10, -px * 2, px, 0, Math.PI * 2);
            ctx.arc(px * 10, px * 2, px, 0, Math.PI * 2);
            ctx.arc(px * 6, 0, px, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Body - thin black
            ctx.fillStyle = '#1A1A1A';
            ctx.fillRect(-px, -px * 4, px * 2, px * 10);

            // Antennae - curved
            ctx.strokeStyle = '#1A1A1A';
            ctx.lineWidth = px * 0.8;
            ctx.beginPath();
            ctx.moveTo(-px, -px * 4);
            ctx.quadraticCurveTo(-px * 3, -px * 7, -px * 2, -px * 8);
            ctx.moveTo(px, -px * 4);
            ctx.quadraticCurveTo(px * 3, -px * 7, px * 2, -px * 8);
            ctx.stroke();

            ctx.restore();
        }

        function drawChunkyNewt(x, y, isStatic = false) {
            const px = PIXEL_SIZE;
            const wiggle = isStatic ? 0 : Math.sin(time * 0.15) * 2;

            ctx.save();
            ctx.translate(x, y);

            // Body - smooth curved shape
            ctx.fillStyle = '#8B6B4B';
            ctx.beginPath();
            ctx.ellipse(0, 0, px * 9, px * 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Orange belly - warning colors
            ctx.fillStyle = '#FF6B30';
            ctx.beginPath();
            ctx.ellipse(0, px * 1.5, px * 7, px * 2, 0, 0, Math.PI);
            ctx.fill();

            // Head - rounded
            ctx.fillStyle = '#7A5A3A';
            ctx.beginPath();
            ctx.arc(-px * 9, 0, px * 3, 0, Math.PI * 2);
            ctx.fill();

            // Eye - bulging
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(-px * 10, -px * 1.5, px * 1.2, 0, Math.PI * 2);
            ctx.fill();

            // Tiny legs
            ctx.fillStyle = '#6A4A3A';
            ctx.fillRect(-px * 5, px * 2, px * 2, px * 4);
            ctx.fillRect(px * 3, px * 2, px * 2, px * 4);

            // Tail - long and wavy
            ctx.fillStyle = '#7A5A3A';
            ctx.beginPath();
            ctx.moveTo(px * 8, -px);
            ctx.quadraticCurveTo(px * 14, wiggle, px * 20, 0);
            ctx.quadraticCurveTo(px * 14, wiggle + px * 2, px * 8, px);
            ctx.fill();

            ctx.restore();
        }

        function drawChunkyHeron(x, y, isStatic = false) {
            const px = PIXEL_SIZE;
            const sway = isStatic ? 0 : Math.sin(time * 0.08) * 2;

            ctx.save();
            ctx.translate(x + sway, y);

            // Body - elegant oval
            ctx.fillStyle = '#7A8A9A';
            ctx.beginPath();
            ctx.ellipse(px * 2, px * 8, px * 8, px * 6, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Long S-curved neck
            ctx.fillStyle = '#8A9AAA';
            ctx.beginPath();
            ctx.moveTo(-px * 2, px * 4);
            ctx.quadraticCurveTo(-px * 6, -px * 4, -px * 2, -px * 12);
            ctx.quadraticCurveTo(px * 2, -px * 14, px * 2, -px * 12);
            ctx.quadraticCurveTo(px * 4, -px * 4, px * 2, px * 4);
            ctx.fill();

            // Head - small elegant
            ctx.fillStyle = '#8A9AAA';
            ctx.beginPath();
            ctx.arc(0, -px * 14, px * 3, 0, Math.PI * 2);
            ctx.fill();

            // Black cap and plume
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(0, -px * 16, px * 2.5, Math.PI, 0);
            ctx.fill();
            // Trailing plume
            ctx.fillRect(px * 2, -px * 17, px * 10, px * 1.5);

            // Dagger beak - yellow
            ctx.fillStyle = '#D4A030';
            ctx.beginPath();
            ctx.moveTo(-px * 3, -px * 14);
            ctx.lineTo(-px * 16, -px * 13);
            ctx.lineTo(-px * 3, -px * 12);
            ctx.fill();

            // Eye
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(-px, -px * 14, px, 0, Math.PI * 2);
            ctx.fill();

            // Stilt legs
            ctx.fillStyle = '#4A4A4A';
            ctx.fillRect(-px, px * 13, px * 1.5, px * 18);
            ctx.fillRect(px * 4, px * 13, px * 1.5, px * 18);

            // Wing detail
            ctx.fillStyle = '#6A7A8A';
            ctx.beginPath();
            ctx.ellipse(px * 4, px * 8, px * 6, px * 4, 0.3, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawChunkySeal(x, y, isStatic = false) {
            const px = PIXEL_SIZE;
            const breathe = isStatic ? 0 : Math.sin(time * 0.12) * 2;

            ctx.save();
            ctx.translate(x, y + breathe);

            // Body - rotund blob shape
            ctx.fillStyle = '#8A8A8A';
            ctx.beginPath();
            ctx.ellipse(0, 0, px * 14, px * 7, 0, 0, Math.PI * 2);
            ctx.fill();

            // Spots - characteristic pattern
            ctx.fillStyle = '#6A6A6A';
            ctx.beginPath();
            ctx.arc(-px * 4, -px * 2, px * 2, 0, Math.PI * 2);
            ctx.arc(px * 3, px, px * 1.5, 0, Math.PI * 2);
            ctx.arc(px * 8, -px, px * 1.5, 0, Math.PI * 2);
            ctx.arc(-px * 2, px * 3, px * 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Head - round with cute snout
            ctx.fillStyle = '#9A9A9A';
            ctx.beginPath();
            ctx.arc(-px * 14, -px, px * 5, 0, Math.PI * 2);
            ctx.fill();

            // Snout
            ctx.fillStyle = '#8A8A8A';
            ctx.beginPath();
            ctx.ellipse(-px * 18, 0, px * 3, px * 2.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nose - black dot
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(-px * 20, 0, px * 1.2, 0, Math.PI * 2);
            ctx.fill();

            // Eye - big and soulful
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(-px * 13, -px * 2, px * 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(-px * 13.5, -px * 2.5, px * 0.7, 0, Math.PI * 2);
            ctx.fill();

            // Whiskers
            ctx.strokeStyle = '#4A4A4A';
            ctx.lineWidth = px * 0.5;
            ctx.beginPath();
            ctx.moveTo(-px * 19, -px);
            ctx.lineTo(-px * 24, -px * 2);
            ctx.moveTo(-px * 19, 0);
            ctx.lineTo(-px * 25, 0);
            ctx.moveTo(-px * 19, px);
            ctx.lineTo(-px * 24, px * 2);
            ctx.stroke();

            // Flippers - simplified shapes
            ctx.fillStyle = '#7A7A7A';
            ctx.beginPath();
            ctx.ellipse(-px * 8, px * 5, px * 4, px * 2, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(px * 10, px * 3, px * 5, px * 3, 0.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // ============== SCENE FLORA OVERLAYS ==============
        // Draw flora on top of static backgrounds based on scene

        function drawSceneFloraOverlay(sceneIndex) {
            switch(sceneIndex) {
                case 0: // Sea Ranch Lodge - Barn with fence and meadow
                    // Poppies scattered in the grassy meadow foreground
                    drawChunkyPoppy(45, 295);
                    drawChunkyPoppy(85, 305);
                    drawChunkyPoppy(130, 290);
                    drawChunkyPoppy(420, 300);
                    drawChunkyPoppy(455, 285);
                    break;

                case 1: // Airstrip - Open grassland with runway
                    // Lupines in the grass along runway edges
                    drawChunkyLupine(35, 280);
                    drawChunkyLupine(65, 295);
                    drawChunkyLupine(440, 275);
                    drawChunkyLupine(460, 290);
                    break;

                case 2: // Ohlson Rec Center - Pool with modernist architecture
                    // Dudleya succulents on the rocky coastal edge
                    drawChunkyDudleya(455, 285);
                    drawChunkyDudleya(430, 295);
                    drawChunkyDudleya(40, 275);
                    break;

                case 3: // Sea Ranch Chapel - Dramatic roof among cypress
                    // Indian Paintbrush wildflowers in the meadow
                    drawChunkyPaintbrush(50, 295);
                    drawChunkyPaintbrush(85, 305);
                    drawChunkyPaintbrush(420, 290);
                    drawChunkyPaintbrush(450, 300);
                    break;

                case 4: // One Eyed Jack's - Dark forest playground
                    // Miner's Lettuce on the shady forest floor
                    drawChunkyMinersLettuce(55, 305);
                    drawChunkyMinersLettuce(130, 295);
                    drawChunkyMinersLettuce(380, 300);
                    drawChunkyMinersLettuce(430, 305);
                    break;

                case 5: // Walk On Beach - Coastal bluffs over ocean
                    // Sea Thrift clinging to the bluff tops (higher up)
                    drawChunkySeaThrift(80, 175);
                    drawChunkySeaThrift(150, 180);
                    drawChunkySeaThrift(400, 170);
                    break;

                case 6: // Del Mar Rec Center - Pool with M building
                    // Buckwheat attracting butterflies near the building
                    drawChunkyBuckwheat(40, 290);
                    drawChunkyBuckwheat(80, 300);
                    drawChunkyBuckwheat(440, 285);
                    break;

                case 7: // Salal Trail Waterfall - Redwood forest stream
                    // Sword Ferns throughout the forest floor
                    drawChunkySwordFern(35, 305);
                    drawChunkySwordFern(80, 295);
                    drawChunkySwordFern(420, 300);
                    drawChunkySwordFern(455, 310);
                    break;

                case 8: // Gualala Point Park - River estuary view
                    // Pickleweed in the foreground marsh grasses
                    drawChunkyPickleweed(60, 305);
                    drawChunkyPickleweed(120, 295);
                    drawChunkyPickleweed(380, 300);
                    drawChunkyPickleweed(440, 290);
                    break;

                case 9: // Driftwood Beach - Driftwood fort on beach
                    // Beach Strawberry in the sandy dunes
                    drawChunkyBeachStrawberry(60, 300);
                    drawChunkyBeachStrawberry(130, 295);
                    drawChunkyBeachStrawberry(400, 305);
                    break;
            }
        }

        // ============== SEA RANCH RAM HORN SUPERGRAPHIC ==============
        // The iconic Barbara Stauffacher Solomon design
        function drawRamHornSupergraphic(x, y, scale = 1.0, color = PALETTE.superCream) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);

            const px = PIXEL_SIZE;
            ctx.fillStyle = color;

            // Left horn - spiral curving left then down
            // Main horn curve (thick pixel strokes)
            const leftHorn = [
                // Starting from center, curving left and down
                {x: -2, y: 0}, {x: -4, y: -2}, {x: -8, y: -4}, {x: -12, y: -4},
                {x: -16, y: -2}, {x: -18, y: 2}, {x: -18, y: 8}, {x: -16, y: 14},
                {x: -12, y: 18}, {x: -8, y: 20}, {x: -4, y: 20}, {x: -2, y: 18}
            ];

            // Draw left horn as thick pixel line
            ctx.lineWidth = 8;
            ctx.strokeStyle = color;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(leftHorn[0].x * px, leftHorn[0].y * px);
            for (let i = 1; i < leftHorn.length; i++) {
                ctx.lineTo(leftHorn[i].x * px, leftHorn[i].y * px);
            }
            ctx.stroke();

            // Right horn - mirror spiral
            const rightHorn = leftHorn.map(p => ({x: -p.x, y: p.y}));
            ctx.beginPath();
            ctx.moveTo(rightHorn[0].x * px, rightHorn[0].y * px);
            for (let i = 1; i < rightHorn.length; i++) {
                ctx.lineTo(rightHorn[i].x * px, rightHorn[i].y * px);
            }
            ctx.stroke();

            // Center connection piece
            pixelRect(-4 * px, -4 * px, 8 * px, 8 * px, color);

            ctx.restore();
        }

        // Simplified pixel art ram horns for smaller sizes
        function drawPixelRamHorns(x, y, size = 'medium', color = PALETTE.superCream) {
            const px = PIXEL_SIZE;
            ctx.fillStyle = color;

            if (size === 'large') {
                // 32x24 pixel ram horns
                const pattern = [
                    "    ████████████████████    ",
                    "  ████              ████  ",
                    " ███                  ███ ",
                    "███                    ███",
                    "██                      ██",
                    "██                      ██",
                    " ██                    ██ ",
                    "  ███                ███  ",
                    "    ████          ████    ",
                    "      ██████████████      ",
                    "        ████████          "
                ];

                pattern.forEach((row, ry) => {
                    for (let rx = 0; rx < row.length; rx++) {
                        if (row[rx] === '█') {
                            ctx.fillRect(x + rx * px, y + ry * px, px, px);
                        }
                    }
                });
            } else if (size === 'medium') {
                // Compact 16x12 ram horns
                const pattern = [
                    "  ████████████  ",
                    " ██          ██ ",
                    "██            ██",
                    "██            ██",
                    " ██          ██ ",
                    "  ████    ████  ",
                    "    ████████    "
                ];

                pattern.forEach((row, ry) => {
                    for (let rx = 0; rx < row.length; rx++) {
                        if (row[rx] === '█') {
                            ctx.fillRect(x + rx * px, y + ry * px, px, px);
                        }
                    }
                });
            } else {
                // Tiny 8x6 ram horns (for small UI)
                const pattern = [
                    " ██████ ",
                    "██    ██",
                    "██    ██",
                    " ██  ██ ",
                    "  ████  "
                ];

                pattern.forEach((row, ry) => {
                    for (let rx = 0; rx < row.length; rx++) {
                        if (row[rx] === '█') {
                            ctx.fillRect(x + rx * px, y + ry * px, px, px);
                        }
                    }
                });
            }
        }

        // ============== SEA RANCH WAYFINDING POST ==============
        // White redwood post with angled top and vertical text
        function drawWayfindingPost(x, y, postHeight, text, textColor = '#1A1A1A') {
            if (postImage) {
                // Use the post sprite image
                // Original image is 114x504, scale to desired height
                const scale = postHeight / postImage.height;
                const drawWidth = postImage.width * scale;
                const drawHeight = postHeight;

                // Draw the post sprite (x,y is bottom-left position)
                ctx.drawImage(postImage, x - drawWidth / 2, y - drawHeight, drawWidth, drawHeight);

                // Vertical text on the post
                ctx.save();
                ctx.translate(x + 2, y - 20);
                ctx.rotate(-Math.PI / 2);
                ctx.fillStyle = textColor;
                ctx.font = SeaRanchStyle.makeFont(Math.max(8, Math.floor(postHeight / 12)), 'bold');
                ctx.textAlign = 'center';
                ctx.fillText(text.toUpperCase(), 0, 0);
                ctx.restore();
            } else {
                // Fallback to procedural drawing
                const px = PIXEL_SIZE;
                const postWidth = 24 * px;

                // Post shadow
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                pixelRect(x + 4, y - postHeight + 4, postWidth, postHeight, 'rgba(0,0,0,0.2)');

                // Main post - weathered white/cream
                const postGrad = ctx.createLinearGradient(x, 0, x + postWidth, 0);
                postGrad.addColorStop(0, '#F8F8F4');
                postGrad.addColorStop(0.3, '#FFFFFF');
                postGrad.addColorStop(0.7, '#F0F0EC');
                postGrad.addColorStop(1, '#E8E8E4');
                ctx.fillStyle = postGrad;
                ctx.fillRect(x, y - postHeight, postWidth, postHeight);

                // Angled top (cut at 45 degrees)
                ctx.fillStyle = '#E8E8E4';
                ctx.beginPath();
                ctx.moveTo(x, y - postHeight);
                ctx.lineTo(x + postWidth / 2, y - postHeight - 12 * px);
                ctx.lineTo(x + postWidth, y - postHeight);
                ctx.fill();

                // Top cap line
                ctx.strokeStyle = '#D0D0CC';
                ctx.lineWidth = px;
                ctx.beginPath();
                ctx.moveTo(x, y - postHeight);
                ctx.lineTo(x + postWidth / 2, y - postHeight - 12 * px);
                ctx.lineTo(x + postWidth, y - postHeight);
                ctx.stroke();

                // Vertical text
                ctx.save();
                ctx.translate(x + postWidth / 2 + 2, y - 20);
                ctx.rotate(-Math.PI / 2);
                ctx.fillStyle = textColor;
                ctx.font = SeaRanchStyle.makeFont(10, 'bold');
                ctx.textAlign = 'center';
                ctx.letterSpacing = '2px';
                ctx.fillText(text.toUpperCase(), 0, 0);
                ctx.restore();

                // Subtle wood grain lines
                ctx.strokeStyle = 'rgba(0,0,0,0.05)';
                ctx.lineWidth = 1;
                for (let i = 0; i < postHeight; i += 8 * px) {
                    if (Math.random() > 0.5) {
                        ctx.beginPath();
                        ctx.moveTo(x + 2, y - i);
                        ctx.lineTo(x + postWidth - 2, y - i - 2);
                        ctx.stroke();
                    }
                }
            }
        }

        // ============== BIKING CUTSCENE ==============
        function drawBikingCutscene() {
            const progress = bikeProgress / BIKE_DURATION;
            bikeRoadOffset = (bikeRoadOffset + 2) % 80; // Slowed down road movement

            // Sky - pixel gradient with dithering (expanded for 480 height)
            pixelRect(0, 0, width, 140, PALETTE.skyLight);
            orderedDither(0, 140, width, 50, PALETTE.skyLight, PALETTE.skyMid, 0.5);

            // Distant ocean - layered for depth
            pixelRect(0, 175, width, 12, PALETTE.oceanDeep);  // Horizon line (darkest)
            pixelRect(0, 187, width, 18, PALETTE.oceanMid);   // Mid ocean
            pixelRect(0, 205, width, 22, PALETTE.oceanLight); // Near ocean (lighter)

            // Ocean wave layers - multiple rows with different speeds (all slowed)
            // Far waves (slower, smaller)
            for (let i = 0; i < 8; i++) {
                const wx = (i * 70 + time * 0.06) % (width + 70) - 35;
                const wy = 180 + Math.sin(i * 1.5 + time * 0.015) * 1;
                pixelRect(wx, wy, 20, 2, PALETTE.oceanMid);
            }

            // Mid waves
            for (let i = 0; i < 10; i++) {
                const wx = (i * 55 + time * 0.1) % (width + 55) - 27;
                const wy = 195 + Math.sin(i * 1.2 + time * 0.02) * 2;
                pixelRect(wx, wy, 25, 3, '#6ABACC');
            }

            // Near waves (faster, larger, with foam caps)
            for (let i = 0; i < 12; i++) {
                const wx = (i * 45 + time * 0.15) % (width + 45) - 22;
                const wy = 212 + Math.sin(i + time * 0.025) * 2;
                // Wave body
                pixelRect(wx, wy, 30, 4, PALETTE.oceanLight);
                // Foam cap
                pixelRect(wx + 5, wy - 2, 15, 2, PALETTE.oceanFoam);
            }

            // Shoreline foam
            for (let i = 0; i < 15; i++) {
                const fx = (i * 35 + time * 0.2 + Math.sin(i * 2) * 10) % (width + 35) - 17;
                const fy = 222 + Math.sin(i * 0.8 + time * 0.03) * 1;
                pixelRect(fx, fy, 18, 2, PALETTE.oceanFoam);
            }

            // Coastal bluff/meadow (larger area)
            pixelRect(0, 225, width, 70, PALETTE.grassMid);
            orderedDither(0, 280, width, 15, PALETTE.grassMid, PALETTE.grassLight, 0.4);

            // Road (flat, side view - cyclist going left to right)
            const roadY = 310;
            const roadHeight = 60;
            pixelRect(0, roadY, width, roadHeight, '#4A4A4A');

            // Road center dashed line (horizontal, animated moving left - slower)
            ctx.fillStyle = '#CCCC88';
            for (let i = 0; i < 10; i++) {
                const dashX = (i * 80 - bikeRoadOffset) % (width + 80) - 40;
                pixelRect(dashX, roadY + roadHeight / 2 - 2, 40, 4, '#CCCC88');
            }

            // Road edge stripes (top and bottom of road)
            pixelRect(0, roadY, width, 4, '#FFFFFF');
            pixelRect(0, roadY + roadHeight - 4, width, 4, '#FFFFFF');

            // Road shoulder/gravel below road
            pixelRect(0, roadY + roadHeight, width, 50, '#6B5B4F');
            orderedDither(0, roadY + roadHeight + 40, width, 25, '#6B5B4F', '#5A4A3F', 0.3);

            // Bottom ground area - fills to bottom of screen
            pixelRect(0, roadY + roadHeight + 65, width, height - (roadY + roadHeight + 65), '#4A3A2F');

            // Distant cypress trees (background)
            for (let i = 0; i < 6; i++) {
                const tx = 50 + i * 90;
                const th = 65 + Math.sin(i * 2) * 20;
                drawPixelCypressTree(tx, roadY - 8, th);
            }

            // Wayfinding post moving from right to left (passing by - slower)
            const postProgress = ((time * 0.35 + 200) % 500) / 500; // Slower cycling
            const postX = width + 50 - postProgress * (width + 100);
            const postLabel = STOPS[currentStop].shortName || STOPS[currentStop].name.slice(0, 7);
            if (postX > -30 && postX < width + 30) {
                const postHeight = 110; // Taller for larger scene
                if (postImage) {
                    const scale = postHeight / postImage.height;
                    const drawWidth = postImage.width * scale;
                    const postDrawX = postX - drawWidth / 2;
                    const postDrawY = roadY - postHeight + 15;
                    ctx.drawImage(postImage, postDrawX, postDrawY, drawWidth, postHeight);

                    // Draw stop name vertically on the post (stacked letters)
                    ctx.fillStyle = '#2A2A2A';
                    ctx.font = SeaRanchStyle.makeFont(8, 'bold');
                    ctx.textAlign = 'center';
                    const letters = postLabel.split('');
                    const letterSpacing = 9;
                    const startY = postDrawY + 14;
                    letters.forEach((letter, i) => {
                        ctx.fillText(letter, postDrawX + drawWidth / 2 + 2, startY + i * letterSpacing);
                    });
                } else {
                    drawWayfindingPost(postX, roadY + 15, postHeight, postLabel);
                }
            }

            // The cyclist sprite (left side, moving right visually)
            const bobY = Math.sin(time * 0.15) * 2; // Gentler, slower bob
            if (cyclistImage) {
                const cyclistScale = 0.28; // Larger cyclist for bigger scene
                const cyclistW = cyclistImage.width * cyclistScale;
                const cyclistH = cyclistImage.height * cyclistScale;
                const cyclistX = 140; // Position on left side of screen
                const cyclistY = roadY - cyclistH + 35 + bobY;
                ctx.drawImage(cyclistImage, cyclistX, cyclistY, cyclistW, cyclistH);
            } else {
                drawPixelCyclist(170, roadY + 20 + bobY, time * 0.3);
            }

            // Progress text bar at top
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            pixelRect(0, 0, width, 40, 'rgba(0,0,0,0.6)');

            ctx.fillStyle = PALETTE.superCream;
            ctx.font = SeaRanchStyle.makeFont(14, 'bold');
            ctx.textAlign = 'center';
            ctx.fillText(`Biking to ${STOPS[currentStop].name}...`, width / 2, 26);

            // Mile progress bar at bottom
            ctx.fillStyle = '#333';
            pixelRect(width / 2 - 100, height - 35, 200, 16, '#333');
            ctx.fillStyle = PALETTE.superRed;
            pixelRect(width / 2 - 97, height - 32, 194 * progress, 10, PALETTE.superRed);
        }

        // Pixel art cypress tree
        function drawPixelCypressTree(x, y, height) {
            const px = PIXEL_SIZE;
            const trunkH = height * 0.15;
            const crownH = height - trunkH;

            // Trunk
            pixelRect(x - 2 * px, y - trunkH, 4 * px, trunkH, PALETTE.woodDark);

            // Crown (tapered)
            for (let i = 0; i < crownH; i += px) {
                const t = i / crownH;
                const w = (1 - t * 0.7) * 12 * px;
                const shade = t > 0.5 ? PALETTE.grassDark : '#3A5A4A';
                pixelRect(x - w / 2, y - trunkH - i, w, px, shade);
            }
        }

        // Pixel art cyclist
        function drawPixelCyclist(x, y, pedalAngle) {
            const px = PIXEL_SIZE;

            // Wheels
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x - 20, y + 15, 12, 0, Math.PI * 2);
            ctx.arc(x + 20, y + 15, 12, 0, Math.PI * 2);
            ctx.stroke();

            // Wheel spokes
            ctx.lineWidth = 1;
            for (let i = 0; i < 4; i++) {
                const a = i * Math.PI / 2 + pedalAngle;
                ctx.beginPath();
                ctx.moveTo(x - 20, y + 15);
                ctx.lineTo(x - 20 + Math.cos(a) * 10, y + 15 + Math.sin(a) * 10);
                ctx.moveTo(x + 20, y + 15);
                ctx.lineTo(x + 20 + Math.cos(a) * 10, y + 15 + Math.sin(a) * 10);
                ctx.stroke();
            }

            // Frame
            ctx.strokeStyle = PALETTE.superBlue;
            ctx.lineWidth = 3;
            ctx.beginPath();
            // Main triangle
            ctx.moveTo(x - 20, y + 15); // rear wheel
            ctx.lineTo(x, y - 5); // seat post top
            ctx.lineTo(x + 20, y + 15); // front wheel
            ctx.moveTo(x, y - 5);
            ctx.lineTo(x - 10, y + 10); // down tube
            ctx.lineTo(x - 20, y + 15);
            ctx.stroke();

            // Handlebars
            ctx.beginPath();
            ctx.moveTo(x, y - 5);
            ctx.lineTo(x + 15, y - 10);
            ctx.lineTo(x + 18, y - 8);
            ctx.stroke();

            // Seat
            pixelRect(x - 6, y - 10, 12, 4, '#333');

            // Rider body
            pixelRect(x - 4, y - 25, 8, 15, PALETTE.superRed); // torso

            // Rider head
            ctx.fillStyle = '#DEB887';
            ctx.beginPath();
            ctx.arc(x, y - 32, 6, 0, Math.PI * 2);
            ctx.fill();

            // Helmet
            pixelRect(x - 6, y - 40, 12, 6, PALETTE.superBlue);

            // Legs (pedaling)
            const legAngle = Math.sin(pedalAngle) * 0.3;
            ctx.strokeStyle = '#4A4A4A';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(x - 2, y - 10);
            ctx.lineTo(x - 5 + Math.cos(pedalAngle) * 8, y + 8 + Math.sin(pedalAngle) * 5);
            ctx.moveTo(x + 2, y - 10);
            ctx.lineTo(x + 5 + Math.cos(pedalAngle + Math.PI) * 8, y + 8 + Math.sin(pedalAngle + Math.PI) * 5);
            ctx.stroke();

            // Arms
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#DEB887';
            ctx.beginPath();
            ctx.moveTo(x + 2, y - 22);
            ctx.lineTo(x + 16, y - 10);
            ctx.stroke();
        }

        // ============== PLAYFUL WILDLIFE AI ==============
        function updateWildlifePlayful() {
            if (!wildlife.visible) return;

            // Calculate distance from camera viewfinder center to wildlife
            const dx = camera.x - wildlife.x;
            const dy = camera.y - wildlife.y;
            const distToCamera = Math.sqrt(dx * dx + dy * dy);

            // Is the camera pointing at us?
            const cameraOnUs = distToCamera < 80;

            // Update energy (recovers over time)
            wildlife.energy = Math.min(1.0, wildlife.energy + 0.002);

            // PLAYFUL DARTING - random small movements to make them harder to snap
            // Different species have different "fidget" rates
            const fidgetRates = [
                0.06, // Black Phoebe - tail bobbing, active
                0.02, // Red-tailed Hawk - smooth soaring
                0.12, // Western Fence Lizard - quick little darts!
                0.15, // Anna's Hummingbird - constantly moving!
                0.05, // Acorn Woodpecker - pecks and hops
                0.04, // Black Oystercatcher - walks along shore
                0.10, // Monarch Butterfly - fluttery path
                0.03, // Rough-skinned Newt - slow crawler
                0.02, // Great Blue Heron - mostly still, occasional step
                0.01  // Harbor Seal - lazy blob
            ];

            const fidgetRate = fidgetRates[currentStop] || 0.05;

            // Random playful movements
            if (Math.random() < fidgetRate) {
                const dartStrength = 2 + Math.random() * 3;
                wildlife.vx += (Math.random() - 0.5) * dartStrength;
                wildlife.vy += (Math.random() - 0.5) * dartStrength * 0.7;
            }

            // Rest timer countdown
            if (wildlife.restTimer > 0) {
                wildlife.restTimer--;
                // Still allow tiny movements while resting
                wildlife.x += Math.sin(time * 0.1) * 0.3;
                wildlife.y += Math.cos(time * 0.08) * 0.2;
                return;
            }

            // Flee timer countdown
            if (wildlife.fleeTimer > 0) {
                wildlife.fleeTimer--;
            }

            // Different behaviors based on species shyness and camera
            // Higher = more reactive to camera focus
            const shynessFactors = [
                0.6, // Black Phoebe - fairly bold but will dart
                0.35, // Red-tailed Hawk - confident soaring
                0.9, // Western Fence Lizard - very skittish!
                0.95, // Anna's Hummingbird - extremely quick to flee
                0.6, // Acorn Woodpecker - will hop around tree
                0.75, // Black Oystercatcher - wary shorebird
                0.8, // Monarch Butterfly - fluttery, unpredictable
                0.55, // Rough-skinned Newt - slow but will crawl away
                0.65, // Great Blue Heron - patient but will take flight
                0.4  // Harbor Seal - lazy, barely moves
            ];

            wildlife.shyness = shynessFactors[currentStop] || 0.5;

            // Only react when binoculars are raised!
            const binocularsActive = binocularsRaised && binocularLiftProgress > 0.5;

            if (binocularsActive && cameraOnUs && wildlife.fleeTimer <= 0) {
                // We're being watched! React based on shyness
                if (Math.random() < wildlife.shyness * 0.18) {
                    // Start fleeing!
                    wildlife.behavior = 'flee';
                    wildlife.fleeTimer = 45 + Math.random() * 75; // Flee for 0.75-2 seconds

                    // Pick flee direction (away from camera)
                    const fleeAngle = Math.atan2(wildlife.y - camera.y, wildlife.x - camera.x);
                    const fleeDist = 30 + Math.random() * 40;
                    wildlife.targetX = wildlife.x + Math.cos(fleeAngle) * fleeDist;
                    wildlife.targetY = wildlife.y + Math.sin(fleeAngle) * fleeDist;

                    // Clamp to scene bounds
                    wildlife.targetX = Math.max(50, Math.min(430, wildlife.targetX));
                    wildlife.targetY = Math.max(80, Math.min(280, wildlife.targetY));
                }
            }

            // Apply behavior
            if (wildlife.behavior === 'flee') {
                // Move quickly toward flee target
                const speed = 2.5 * wildlife.energy;
                wildlife.vx += (wildlife.targetX - wildlife.x) * 0.15;
                wildlife.vy += (wildlife.targetY - wildlife.y) * 0.15;

                // Apply velocity with damping
                wildlife.x += wildlife.vx;
                wildlife.y += wildlife.vy;
                wildlife.vx *= 0.85;
                wildlife.vy *= 0.85;

                // Reached target?
                const distToTarget = Math.sqrt(
                    (wildlife.targetX - wildlife.x) ** 2 +
                    (wildlife.targetY - wildlife.y) ** 2
                );

                if (distToTarget < 10 || wildlife.fleeTimer <= 0) {
                    wildlife.behavior = 'rest';
                    wildlife.restTimer = 30 + Math.random() * 60;
                    wildlife.energy *= 0.7; // Tired from fleeing
                    wildlife.vx = 0;
                    wildlife.vy = 0;
                }
            } else if (wildlife.behavior === 'rest') {
                // Just chilling, maybe slight idle movement
                wildlife.x += Math.sin(time * 0.1) * 0.2;
                wildlife.y += Math.cos(time * 0.08) * 0.1;

                if (wildlife.restTimer <= 0) {
                    wildlife.behavior = 'wander';
                }
            } else if (wildlife.behavior === 'wander') {
                // Random gentle wandering back toward home
                if (Math.random() < 0.02) {
                    wildlife.targetX = wildlife.homeX + (Math.random() - 0.5) * 60;
                    wildlife.targetY = wildlife.homeY + (Math.random() - 0.5) * 40;
                }

                wildlife.vx += (wildlife.targetX - wildlife.x) * 0.02;
                wildlife.vy += (wildlife.targetY - wildlife.y) * 0.02;

                wildlife.x += wildlife.vx;
                wildlife.y += wildlife.vy;
                wildlife.vx *= 0.95;
                wildlife.vy *= 0.95;

                // Occasionally rest
                if (Math.random() < 0.005) {
                    wildlife.behavior = 'rest';
                    wildlife.restTimer = 60 + Math.random() * 120;
                }
            } else {
                // Default idle - original behavior but with slight movement
                wildlife.behavior = 'wander';
            }
        }

        // The 10 stops with real Sea Ranch species
        const STOPS = [
            {
                name: "Sea Ranch Lodge",
                shortName: "LODGE",
                mile: 0,
                wildlife: "Black Phoebe",
                plant: "California Poppy",
                habitatType: "meadow",
                description: "Start your journey at the iconic lodge"
            },
            {
                name: "Airstrip",
                shortName: "AIRSTRP",
                mile: 1,
                wildlife: "Red-tailed Hawk",
                plant: "Yellow Bush Lupine",
                habitatType: "grassland",
                description: "Open skies attract raptors"
            },
            {
                name: "Ohlson Rec Center",
                shortName: "OHLSON",
                mile: 2,
                wildlife: "Western Fence Lizard",
                plant: "Dudleya",
                habitatType: "coastal",
                description: "Modernist architecture meets nature"
            },
            {
                name: "Sea Ranch Chapel",
                shortName: "CHAPEL",
                mile: 3,
                wildlife: "Anna's Hummingbird",
                plant: "Indian Paintbrush",
                habitatType: "forest-edge",
                description: "A sanctuary for all creatures"
            },
            {
                name: "One Eyed Jack's",
                shortName: "JACKS",
                mile: 4,
                wildlife: "Acorn Woodpecker",
                plant: "Miner's Lettuce",
                habitatType: "cypress-forest",
                description: "Ancient cypress grove playground"
            },
            {
                name: "Walk On Beach",
                shortName: "WALKON",
                mile: 5,
                wildlife: "Black Oystercatcher",
                plant: "Sea Thrift",
                habitatType: "bluff",
                description: "Where bluffs meet the sea"
            },
            {
                name: "Del Mar Rec Center",
                shortName: "DELMAR",
                mile: 6,
                wildlife: "Monarch Butterfly",
                plant: "Seaside Buckwheat",
                habitatType: "meadow",
                description: "Butterflies gather in autumn"
            },
            {
                name: "Salal Trail Waterfall",
                shortName: "SALAL",
                mile: 7,
                wildlife: "Rough-skinned Newt",
                plant: "Sword Fern",
                habitatType: "redwood-forest",
                description: "Hidden waterfall in the redwoods"
            },
            {
                name: "Gualala Point Park",
                shortName: "GUALALA",
                mile: 9,
                wildlife: "Great Blue Heron",
                plant: "Pickleweed",
                habitatType: "estuary",
                description: "River meets the Pacific"
            },
            {
                name: "Driftwood Beach",
                shortName: "DRFTWOD",
                mile: 10,
                wildlife: "Harbor Seal",
                plant: "Beach Strawberry",
                habitatType: "beach",
                description: "Journey's end at the driftwood sculptures"
            }
        ];

        // Color palettes for different habitats
        const PALETTES = {
            meadow: {
                sky: ['#87CEEB', '#B0E0E6', '#E0F4FF'],
                grass: ['#7CB342', '#8BC34A', '#9CCC65', '#AED581'],
                accent: '#FFD54F'
            },
            coastal: {
                sky: ['#6BA3BE', '#89B4C4', '#A8C5D4'],
                grass: ['#A8B590', '#B5C29A', '#C2CFA5'],
                accent: '#5D9B9B'
            }
        };

        // Input handling
        document.addEventListener('keydown', e => {
            keys[e.key] = true;
            const isActionKey = e.key === ' ' || e.key === 'Enter' || e.key === 'a' || e.key === 'A';
            const isBackKey = e.key === 'Escape' || e.key === 'b' || e.key === 'B';

            if (gameState === 'title' && isActionKey) {
                document.getElementById('title-card').style.display = 'none';
                startGame();
            } else if (gameState === 'departure' && isActionKey) {
                // Skip departure cutscene
                gameState = 'photo';
                initPhotoMode();
            } else if (gameState === 'photo' && isActionKey) {
                if (!binocularsRaised) {
                    // First press - raise binoculars
                    binocularsRaised = true;
                    SeaRanchStyle.playSound('click');
                } else if (binocularLiftProgress > 0.7) {
                    // Binoculars are up - log the sighting! (lowered threshold for snappier feel)
                    takePhoto();
                }
            } else if (gameState === 'results' && isActionKey) {
                nextStop();
            } else if (gameState === 'complete' && isActionKey) {
                // Replay
                window.location.reload();
            }
            // B/ESC handling - contextual
            if (isBackKey) {
                if (gameState === 'photo' && binocularsRaised) {
                    // Lower binoculars instead of exiting
                    binocularsRaised = false;
                } else {
                    // Return to menu
                    window.location.href = 'level0-menu.html';
                }
            }
            e.preventDefault();
        });
        document.addEventListener('keyup', e => keys[e.key] = false);

        function startGame() {
            currentStop = 0;
            departureTimer = 0;
            // Start with departure cutscene from lodge
            gameState = 'departure';
        }

        function initPhotoMode() {
            photoTaken = false;
            photoScore = 0;
            photoTimer = PHOTO_TIME_LIMIT;
            camera = { x: 320, y: 240, zoom: 1 };

            // Reset binocular state
            binocularsRaised = false;
            binocularLiftProgress = 0;
            focusX = 320;
            focusY = 240;

            // Initialize wildlife position based on stop
            wildlife.visible = true;
            wildlife.animFrame = 0;
            wildlife.behavior = 'wander';
            wildlife.vx = 0;
            wildlife.vy = 0;
            wildlife.energy = 1.0;
            wildlife.restTimer = 0;
            wildlife.fleeTimer = 0;

            // Set initial position based on current stop (adjusted for chunky backgrounds)
            // Positioned to make sense with the scene content (scaled for 640x480)
            const wildlifePositions = [
                { x: 93, y: 293 },     // 0: Black Phoebe on fence post (left fence in barn scene)
                { x: 373, y: 83 },     // 1: Red-tailed Hawk soaring high (above runway)
                { x: 593, y: 413 },    // 2: Western Fence Lizard on warm rocks (right side pool area)
                { x: 333, y: 218 },    // 3: Anna's Hummingbird near chapel flowers
                { x: 160, y: 225 },    // 4: Acorn Woodpecker on cypress tree (left side playground)
                { x: 293, y: 180 },    // 5: Black Oystercatcher on bluff rocks (center bluff)
                { x: 200, y: 255 },    // 6: Monarch Butterfly near trees (left of pool building)
                { x: 320, y: 330 },    // 7: Rough-skinned Newt near stream (center forest floor)
                { x: 427, y: 300 },    // 8: Great Blue Heron in river shallows
                { x: 373, y: 398 }     // 9: Harbor Seal lounging on beach near driftwood
            ];

            const pos = wildlifePositions[currentStop] || wildlifePositions[0];
            wildlife.x = pos.x;
            wildlife.y = pos.y;
            wildlife.homeX = pos.x;
            wildlife.homeY = pos.y;
            wildlife.targetX = pos.x;
            wildlife.targetY = pos.y;
        }

        function takePhoto() {
            if (photoTaken || !wildlife.visible || !binocularsRaised) return;

            photoTaken = true;

            // Calculate score based on binocular focus vs wildlife
            const wx = wildlife.x;
            const wy = wildlife.y;

            // Distance from center of view to wildlife
            const dist = Math.sqrt((wx - focusX) ** 2 + (wy - focusY) ** 2);

            // Score: closer to center = better sighting
            if (dist < BINOCULAR_RADIUS * 0.35) {
                photoScore = 3; // Perfect! Clear sighting
            } else if (dist < BINOCULAR_RADIUS * 0.6) {
                photoScore = 2; // Good sighting
            } else if (dist < BINOCULAR_RADIUS * 1.0) {
                photoScore = 1; // Glimpsed it
            } else {
                photoScore = 0; // Missed!
            }

            // Juice effects based on photo quality
            if (photoScore > 0) {
                // Success - sparkles on the wildlife!
                SeaRanchStyle.spawnSparkles(wx, wy, SeaRanchStyle.colors.cream);
            } else {
                // Missed - shake and flash
                SeaRanchStyle.shake(8, 0.88);
                SeaRanchStyle.flash(SeaRanchStyle.colors.red, 0.25);
            }

            // Brief highlight effect then show results
            photoFlashTimer = 20;
            setTimeout(() => {
                gameState = 'results';
                showResultsCard();  // Show the HTML overlay
            }, 600);
        }

        function nextStop() {
            // Hide the HTML results overlay
            document.getElementById('results-card').classList.remove('visible');

            currentStop++;
            if (currentStop >= STOPS.length) {
                gameState = 'complete';
                // Save completion (Level 4 in narrative order)
                SeaRanchStyle.saveCompletion(4);
                showCompleteCard();  // Show the HTML complete overlay
            } else {
                // Start biking cutscene to next stop
                gameState = 'biking';
                bikeProgress = 0;
            }
        }

        function update() {
            time++;

            if (gameState === 'biking') {
                // Update biking cutscene
                bikeProgress++;
                if (bikeProgress >= BIKE_DURATION) {
                    // Skip arriving scene, go directly to photo mode
                    gameState = 'photo';
                    initPhotoMode();
                }
            } else if (gameState === 'photo') {
                // Animate binocular lift
                if (binocularsRaised && binocularLiftProgress < 1) {
                    binocularLiftProgress = Math.min(1, binocularLiftProgress + BINOCULAR_LIFT_SPEED);
                } else if (!binocularsRaised && binocularLiftProgress > 0) {
                    binocularLiftProgress = Math.max(0, binocularLiftProgress - BINOCULAR_LIFT_SPEED);
                }

                // Move focus with arrow keys (only when binoculars are raised)
                if (binocularsRaised && binocularLiftProgress > 0.3) {
                    const moveSpeed = 3.5; // Faster panning for snappier feel
                    if (keys['ArrowLeft']) focusX -= moveSpeed;
                    if (keys['ArrowRight']) focusX += moveSpeed;
                    if (keys['ArrowUp']) focusY -= moveSpeed;
                    if (keys['ArrowDown']) focusY += moveSpeed;

                    // Clamp focus to screen bounds (expanded range for more coverage)
                    focusX = Math.max(95, Math.min(545, focusX));
                    focusY = Math.max(95, Math.min(385, focusY));

                    // Update camera to match focus (for wildlife AI reaction)
                    camera.x = focusX;
                    camera.y = focusY;
                }

                // Update wildlife animation
                wildlife.animFrame += 0.1;

                // Playful wildlife behavior (reacts to binoculars!)
                updateWildlifePlayful();

                // Timer
                if (!photoTaken) {
                    photoTimer--;
                    if (photoTimer <= 0) {
                        wildlife.visible = false;
                        photoScore = 0; // Missed due to timeout
                        // Juice effects for timeout failure
                        SeaRanchStyle.shake(8, 0.88);
                        SeaRanchStyle.flash(SeaRanchStyle.colors.red, 0.25);
                        setTimeout(() => {
                            gameState = 'results';
                            showResultsCard();  // Show the HTML overlay
                        }, 1000);
                    }
                }
            }
        }

        function updateWildlife() {
            if (currentStop === 0) {
                // Black Phoebe - tail bobbing, occasional fly-catch
                if (wildlife.behavior === 'idle') {
                    // Subtle tail bob
                    if (Math.random() < 0.005) {
                        wildlife.behavior = 'flycatch';
                        wildlife.targetX = wildlife.x + (Math.random() - 0.5) * 40;
                        wildlife.targetY = wildlife.y - 30;
                    }
                } else if (wildlife.behavior === 'flycatch') {
                    // Quick dart out and back
                    wildlife.x += (wildlife.targetX - wildlife.x) * 0.2;
                    wildlife.y += (wildlife.targetY - wildlife.y) * 0.2;
                    if (Math.abs(wildlife.x - wildlife.targetX) < 2) {
                        wildlife.behavior = 'return';
                        wildlife.targetX = 340;
                        wildlife.targetY = 180;
                    }
                } else if (wildlife.behavior === 'return') {
                    wildlife.x += (wildlife.targetX - wildlife.x) * 0.1;
                    wildlife.y += (wildlife.targetY - wildlife.y) * 0.1;
                    if (Math.abs(wildlife.x - wildlife.targetX) < 2) {
                        wildlife.behavior = 'idle';
                    }
                }
            } else if (currentStop === 1) {
                // Red-tailed Hawk - soaring circles, lands on post
                if (wildlife.behavior === 'idle') {
                    // Gentle soaring motion
                    wildlife.x = wildlife.targetX + Math.sin(time * 0.02) * 30;
                    wildlife.y = wildlife.targetY + Math.cos(time * 0.015) * 15;
                }
            }
        }

        // ============== DRAWING FUNCTIONS ==============

        function drawScene1_SeaRanchLodge() {
            // Sky gradient - clear coastal day
            const skyGrad = ctx.createLinearGradient(0, 0, 0, 180);
            skyGrad.addColorStop(0, '#4A90B8');
            skyGrad.addColorStop(0.5, '#7AB4D4');
            skyGrad.addColorStop(1, '#B8D4E8');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, width, 180);

            // Distant ocean line
            ctx.fillStyle = '#3A7CA5';
            ctx.fillRect(0, 145, width, 8);

            // Ocean shimmer
            ctx.fillStyle = '#5A9CC5';
            for (let i = 0; i < 20; i++) {
                const x = (i * 30 + time * 0.3) % width;
                ctx.fillRect(x, 147, 15, 2);
            }

            // Distant headland/bluffs
            ctx.fillStyle = '#6B8E7B';
            ctx.beginPath();
            ctx.moveTo(350, 153);
            ctx.quadraticCurveTo(400, 130, 480, 145);
            ctx.lineTo(480, 153);
            ctx.fill();

            // Rolling meadow - multiple layers
            // Far meadow
            ctx.fillStyle = '#8DB57A';
            ctx.fillRect(0, 153, width, 30);

            // Mid meadow with gentle hills
            ctx.fillStyle = '#9DC47A';
            ctx.beginPath();
            ctx.moveTo(0, 170);
            ctx.quadraticCurveTo(100, 160, 200, 172);
            ctx.quadraticCurveTo(300, 185, 400, 170);
            ctx.quadraticCurveTo(450, 165, 480, 175);
            ctx.lineTo(480, 200);
            ctx.lineTo(0, 200);
            ctx.fill();

            // Gravel path
            ctx.fillStyle = '#C4B59A';
            ctx.beginPath();
            ctx.moveTo(180, 320);
            ctx.lineTo(220, 320);
            ctx.lineTo(250, 200);
            ctx.lineTo(230, 200);
            ctx.fill();

            // Path texture
            ctx.fillStyle = '#B5A68A';
            for (let i = 0; i < 30; i++) {
                const y = 200 + i * 4;
                const xOff = (y - 200) * 0.15;
                ctx.fillRect(232 - xOff + Math.random() * 10, y, 2, 2);
            }

            // Wooden fence - left side
            drawWoodenFence(20, 190, 150);

            // The Barn (Sea Ranch Lodge style)
            drawBarn(280, 120, 120, 80);

            // Foreground meadow
            ctx.fillStyle = '#A8D48A';
            ctx.fillRect(0, 200, width, 120);

            // California Poppies in foreground (yellow coastal variety)
            drawCaliforniaPoppies();

            // Grass tufts
            drawGrassTufts();

            // Fence post for bird (right side)
            drawFencePost(335, 175, 45);
        }

        function drawWoodenFence(x, y, length) {
            const postColor = '#7A6855';
            const postHighlight = '#8B7A66';
            const postShadow = '#5A4A3A';

            // Posts
            for (let i = 0; i < length; i += 25) {
                // Post shadow
                ctx.fillStyle = postShadow;
                ctx.fillRect(x + i + 2, y - 35, 5, 40);

                // Main post
                ctx.fillStyle = postColor;
                ctx.fillRect(x + i, y - 38, 5, 43);

                // Highlight
                ctx.fillStyle = postHighlight;
                ctx.fillRect(x + i, y - 38, 2, 43);

                // Weathered top
                ctx.fillStyle = '#9A8A7A';
                ctx.fillRect(x + i - 1, y - 40, 7, 3);
            }

            // Horizontal rails (weathered)
            ctx.fillStyle = postColor;
            ctx.fillRect(x, y - 30, length, 4);
            ctx.fillRect(x, y - 15, length, 4);

            ctx.fillStyle = postHighlight;
            ctx.fillRect(x, y - 30, length, 1);
            ctx.fillRect(x, y - 15, length, 1);
        }

        function drawFencePost(x, y, height) {
            // Shadow
            ctx.fillStyle = '#5A4A3A';
            ctx.fillRect(x + 2, y - height + 2, 8, height);

            // Main post
            ctx.fillStyle = '#7A6855';
            ctx.fillRect(x, y - height, 8, height);

            // Highlight
            ctx.fillStyle = '#8B7A66';
            ctx.fillRect(x, y - height, 3, height);

            // Weathered top
            ctx.fillStyle = '#9A8A7A';
            ctx.beginPath();
            ctx.moveTo(x - 1, y - height);
            ctx.lineTo(x + 4, y - height - 5);
            ctx.lineTo(x + 9, y - height);
            ctx.fill();
        }

        function drawBarn(x, y, w, h) {
            // Barn shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(x + 5, y + 5, w, h);

            // Main barn body - weathered redwood
            const barnGrad = ctx.createLinearGradient(x, 0, x + w, 0);
            barnGrad.addColorStop(0, '#8B7355');
            barnGrad.addColorStop(0.5, '#9B8365');
            barnGrad.addColorStop(1, '#7B6345');
            ctx.fillStyle = barnGrad;
            ctx.fillRect(x, y, w, h);

            // Vertical board lines
            ctx.strokeStyle = '#6B5335';
            ctx.lineWidth = 1;
            for (let i = 0; i < w; i += 12) {
                ctx.beginPath();
                ctx.moveTo(x + i, y);
                ctx.lineTo(x + i, y + h);
                ctx.stroke();
            }

            // Slanted roof (Sea Ranch style - dramatic angle)
            ctx.fillStyle = '#6B5B4B';
            ctx.beginPath();
            ctx.moveTo(x - 10, y);
            ctx.lineTo(x + w * 0.7, y - 50);
            ctx.lineTo(x + w + 10, y);
            ctx.fill();

            // Roof shadow line
            ctx.strokeStyle = '#4B3B2B';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - 10, y);
            ctx.lineTo(x + w * 0.7, y - 50);
            ctx.lineTo(x + w + 10, y);
            ctx.stroke();

            // Ram horn supergraphic (simplified)
            ctx.fillStyle = '#F5F5F0';
            ctx.beginPath();
            // Left spiral
            ctx.arc(x + w * 0.35, y + 25, 15, 0, Math.PI * 1.7);
            ctx.lineWidth = 8;
            ctx.strokeStyle = '#F5F5F0';
            ctx.stroke();

            // Right spiral
            ctx.beginPath();
            ctx.arc(x + w * 0.65, y + 25, 15, Math.PI * 1.3, Math.PI * 3);
            ctx.stroke();

            // Barn entrance (dark)
            ctx.fillStyle = '#2A2015';
            ctx.fillRect(x + w * 0.3, y + h * 0.4, w * 0.4, h * 0.6);
        }

        function drawCaliforniaPoppies() {
            const poppyPositions = [
                {x: 50, y: 250}, {x: 80, y: 265}, {x: 110, y: 248},
                {x: 140, y: 270}, {x: 400, y: 255}, {x: 430, y: 268},
                {x: 380, y: 280}, {x: 60, y: 290}, {x: 450, y: 245}
            ];

            for (const p of poppyPositions) {
                // Stem
                ctx.strokeStyle = '#5A7A4A';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(p.x, p.y + 15);
                ctx.quadraticCurveTo(p.x + 2, p.y + 8, p.x, p.y);
                ctx.stroke();

                // Petals - yellow coastal variety with orange center
                ctx.fillStyle = '#FFD93D';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    const angle = (i / 4) * Math.PI * 2 + Math.sin(time * 0.05 + p.x) * 0.1;
                    ctx.ellipse(
                        p.x + Math.cos(angle) * 4,
                        p.y + Math.sin(angle) * 3,
                        6, 4, angle, 0, Math.PI * 2
                    );
                    ctx.fill();
                }

                // Orange center
                ctx.fillStyle = '#FF8C00';
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawGrassTufts() {
            ctx.strokeStyle = '#7AAA5A';
            ctx.lineWidth = 1;

            for (let i = 0; i < 40; i++) {
                const x = (i * 13 + 5) % width;
                const y = 210 + (i % 5) * 20;
                const sway = Math.sin(time * 0.03 + i) * 2;

                for (let j = 0; j < 5; j++) {
                    ctx.beginPath();
                    ctx.moveTo(x + j * 2, y);
                    ctx.quadraticCurveTo(
                        x + j * 2 + sway,
                        y - 8,
                        x + j * 2 + sway * 1.5,
                        y - 12 - Math.random() * 4
                    );
                    ctx.stroke();
                }
            }
        }

        function drawBlackPhoebe(x, y) {
            const bob = Math.sin(time * 0.3) * 2; // Tail bobbing
            const headTilt = Math.sin(time * 0.15) * 0.1;

            ctx.save();
            ctx.translate(x, y + bob * 0.3);

            // Body - black with dark gray belly
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.ellipse(0, 0, 12, 9, 0, 0, Math.PI * 2);
            ctx.fill();

            // White belly
            ctx.fillStyle = '#E8E8E8';
            ctx.beginPath();
            ctx.ellipse(0, 4, 7, 5, 0, 0, Math.PI);
            ctx.fill();

            // Head
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(-8, -6, 7, 0, Math.PI * 2);
            ctx.fill();

            // Small crest
            ctx.beginPath();
            ctx.moveTo(-10, -12);
            ctx.lineTo(-7, -13);
            ctx.lineTo(-6, -10);
            ctx.fill();

            // Beak
            ctx.fillStyle = '#2A2A2A';
            ctx.beginPath();
            ctx.moveTo(-14, -6);
            ctx.lineTo(-20, -5);
            ctx.lineTo(-14, -4);
            ctx.closePath();
            ctx.fill();

            // Eye
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(-10, -7, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(-10.5, -7.5, 0.8, 0, Math.PI * 2);
            ctx.fill();

            // Tail - bobs up and down!
            ctx.fillStyle = '#1A1A1A';
            ctx.save();
            ctx.translate(10, 2);
            ctx.rotate(bob * 0.08);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(18, -2);
            ctx.lineTo(20, 2);
            ctx.lineTo(18, 4);
            ctx.lineTo(0, 3);
            ctx.fill();
            ctx.restore();

            // Wing
            ctx.fillStyle = '#2A2A2A';
            ctx.beginPath();
            ctx.ellipse(2, -2, 9, 6, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.strokeStyle = '#2A2A2A';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(-2, 8);
            ctx.lineTo(-3, 16);
            ctx.moveTo(3, 8);
            ctx.lineTo(4, 16);
            ctx.stroke();

            ctx.restore();
        }

        function drawScene2_Airstrip() {
            // Sky - bigger, more open
            const skyGrad = ctx.createLinearGradient(0, 0, 0, 160);
            skyGrad.addColorStop(0, '#5A9ECE');
            skyGrad.addColorStop(1, '#9ECAE8');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, width, 160);

            // Wispy clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.ellipse(100, 40, 40, 12, 0, 0, Math.PI * 2);
            ctx.ellipse(130, 35, 30, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.ellipse(350, 55, 35, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Distant tree line - left
            ctx.fillStyle = '#3A5A4A';
            drawPineTreeLine(0, 140, 180, 50);

            // Distant tree line - right
            drawPineTreeLine(300, 140, 180, 45);

            // Meadow behind runway
            ctx.fillStyle = '#8DB86A';
            ctx.fillRect(0, 140, width, 40);

            // Runway
            ctx.fillStyle = '#4A4A4A';
            ctx.beginPath();
            ctx.moveTo(180, 180);
            ctx.lineTo(300, 180);
            ctx.lineTo(480, 280);
            ctx.lineTo(0, 280);
            ctx.lineTo(180, 180);
            ctx.fill();

            // Runway center line
            ctx.strokeStyle = '#CCCCCC';
            ctx.lineWidth = 3;
            ctx.setLineDash([20, 15]);
            ctx.beginPath();
            ctx.moveTo(240, 180);
            ctx.lineTo(240, 280);
            ctx.stroke();
            ctx.setLineDash([]);

            // Runway numbers "15"
            ctx.fillStyle = '#CCCCCC';
            ctx.font = SeaRanchStyle.makeFont(24, 'bold');
            ctx.textAlign = 'center';
            ctx.fillText('15', 240, 220);

            // Grass alongside runway
            ctx.fillStyle = '#9ACA6A';
            ctx.fillRect(0, 260, 100, 60);
            ctx.fillRect(380, 260, 100, 60);

            // Yellow lupine patches
            drawYellowLupine(50, 275);
            drawYellowLupine(420, 280);
            drawYellowLupine(80, 295);

            // Wooden hangar (right side)
            drawHangar(400, 200);

            // Windsock pole
            drawWindsock(370, 170);

            // Foreground grass
            ctx.fillStyle = '#A8D478';
            ctx.fillRect(0, 290, width, 30);

            drawGrassTufts();
        }

        function drawPineTreeLine(startX, baseY, length, maxHeight) {
            for (let x = startX; x < startX + length; x += 15) {
                const h = maxHeight * (0.7 + Math.random() * 0.3);
                const variation = Math.sin(x * 0.1) * 5;

                // Tree shadow
                ctx.fillStyle = '#2A4A3A';
                ctx.beginPath();
                ctx.moveTo(x + 2, baseY);
                ctx.lineTo(x + 8, baseY - h + variation);
                ctx.lineTo(x + 14, baseY);
                ctx.fill();

                // Tree
                ctx.fillStyle = '#3A5A4A';
                ctx.beginPath();
                ctx.moveTo(x, baseY);
                ctx.lineTo(x + 6, baseY - h + variation);
                ctx.lineTo(x + 12, baseY);
                ctx.fill();
            }
        }

        function drawYellowLupine(x, y) {
            // Stem
            ctx.strokeStyle = '#5A7A4A';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y + 10);
            ctx.lineTo(x, y - 15);
            ctx.stroke();

            // Flower spike
            ctx.fillStyle = '#E8D44A';
            for (let i = 0; i < 8; i++) {
                const fy = y - 15 + i * 3;
                const size = 4 - i * 0.3;
                ctx.beginPath();
                ctx.arc(x - 3, fy, size, 0, Math.PI * 2);
                ctx.arc(x + 3, fy, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Leaves
            ctx.fillStyle = '#6A8A5A';
            ctx.beginPath();
            ctx.ellipse(x - 8, y + 5, 8, 3, -0.5, 0, Math.PI * 2);
            ctx.ellipse(x + 8, y + 5, 8, 3, 0.5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawHangar(x, y) {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(x + 3, y + 3, 70, 50);

            // Main structure
            ctx.fillStyle = '#7A6A5A';
            ctx.fillRect(x, y, 70, 50);

            // Vertical boards
            ctx.strokeStyle = '#5A4A3A';
            ctx.lineWidth = 1;
            for (let i = 0; i < 70; i += 10) {
                ctx.beginPath();
                ctx.moveTo(x + i, y);
                ctx.lineTo(x + i, y + 50);
                ctx.stroke();
            }

            // Roof
            ctx.fillStyle = '#5A4A3A';
            ctx.beginPath();
            ctx.moveTo(x - 5, y);
            ctx.lineTo(x + 35, y - 25);
            ctx.lineTo(x + 75, y);
            ctx.fill();

            // Door opening
            ctx.fillStyle = '#2A1A1A';
            ctx.fillRect(x + 15, y + 20, 40, 30);
        }

        function drawWindsock(x, y) {
            // Pole
            ctx.fillStyle = '#888888';
            ctx.fillRect(x, y, 4, 50);

            // Windsock - animated
            const windDir = Math.sin(time * 0.05) * 0.3 + 0.8;
            ctx.save();
            ctx.translate(x + 2, y + 5);
            ctx.rotate(windDir);

            // Sock stripes
            const colors = ['#FF6B35', '#FFFFFF', '#FF6B35', '#FFFFFF', '#FF6B35'];
            for (let i = 0; i < 5; i++) {
                ctx.fillStyle = colors[i];
                ctx.beginPath();
                const startW = 10 - i * 1.5;
                const endW = 8 - i * 1.5;
                ctx.moveTo(i * 8, -startW / 2);
                ctx.lineTo((i + 1) * 8, -endW / 2);
                ctx.lineTo((i + 1) * 8, endW / 2);
                ctx.lineTo(i * 8, startW / 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawRedTailedHawk(x, y) {
            const soar = Math.sin(time * 0.04);
            const wingAngle = soar * 0.15;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(soar * 0.05);

            // Wing span - soaring position
            ctx.fillStyle = '#5A4030';

            // Left wing
            ctx.save();
            ctx.rotate(-wingAngle);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-30, -10, -50, 5);
            ctx.quadraticCurveTo(-30, 8, 0, 5);
            ctx.fill();
            ctx.restore();

            // Right wing
            ctx.save();
            ctx.rotate(wingAngle);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(30, -10, 50, 5);
            ctx.quadraticCurveTo(30, 8, 0, 5);
            ctx.fill();
            ctx.restore();

            // Body
            ctx.fillStyle = '#6A5040';
            ctx.beginPath();
            ctx.ellipse(0, 3, 8, 15, Math.PI / 2, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = '#7A6050';
            ctx.beginPath();
            ctx.arc(-12, 2, 6, 0, Math.PI * 2);
            ctx.fill();

            // Beak
            ctx.fillStyle = '#3A3030';
            ctx.beginPath();
            ctx.moveTo(-17, 1);
            ctx.lineTo(-22, 3);
            ctx.lineTo(-17, 4);
            ctx.fill();

            // Red tail
            ctx.fillStyle = '#A64A30';
            ctx.beginPath();
            ctx.moveTo(8, 0);
            ctx.lineTo(25, -3);
            ctx.lineTo(28, 3);
            ctx.lineTo(25, 8);
            ctx.lineTo(8, 5);
            ctx.fill();

            // Eye
            ctx.fillStyle = '#FFCC00';
            ctx.beginPath();
            ctx.arc(-13, 1, 1.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // ============== SCENE 3: OHLSON REC CENTER ==============
        function drawScene3_OhlsonRecCenter() {
            // Sky - clear coastal blue
            const skyGrad = ctx.createLinearGradient(0, 0, 0, 140);
            skyGrad.addColorStop(0, '#4A8EC2');
            skyGrad.addColorStop(1, '#7FBCE8');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, width, 140);

            // Distant ocean
            ctx.fillStyle = '#3A7CA5';
            ctx.fillRect(350, 115, 130, 25);

            // Ocean shimmer
            ctx.fillStyle = '#5A9CC5';
            for (let i = 0; i < 8; i++) {
                const x = 350 + (i * 18 + time * 0.2) % 130;
                ctx.fillRect(x, 120 + Math.sin(i) * 3, 10, 2);
            }

            // Coastal bluff/meadow behind pool
            ctx.fillStyle = '#8DB57A';
            ctx.fillRect(0, 130, width, 30);

            // The iconic diving tower (center-right)
            drawDivingTower(320, 100);

            // Main pool building (left)
            drawPoolBuilding(40, 95, 180, 80);

            // The pool itself
            drawSwimmingPool(120, 175, 200, 70);

            // Concrete pool deck
            ctx.fillStyle = '#C4B8A8';
            ctx.fillRect(0, 160, width, 160);

            // Pool deck texture - subtle expansion joints
            ctx.strokeStyle = '#B0A494';
            ctx.lineWidth = 1;
            for (let x = 30; x < width; x += 60) {
                ctx.beginPath();
                ctx.moveTo(x, 160);
                ctx.lineTo(x, 320);
                ctx.stroke();
            }

            // Dudleya succulent patches on deck edge
            drawDudleya(50, 280);
            drawDudleya(420, 275);
            drawDudleya(380, 290);

            // Grass patches
            ctx.fillStyle = '#9ACA6A';
            ctx.beginPath();
            ctx.ellipse(30, 250, 35, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(460, 260, 25, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Sunny warm rock for lizard
            drawSunnyRock(380, 220);
        }

        function drawDivingTower(x, y) {
            // Sea Ranch iconic modernist diving tower
            // Weathered redwood with geometric forms

            // Main tower shadow
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(x + 4, y + 4, 50, 100);

            // Main tower body - weathered redwood
            const woodGrad = ctx.createLinearGradient(x, 0, x + 50, 0);
            woodGrad.addColorStop(0, '#9B8A72');
            woodGrad.addColorStop(0.3, '#A89880');
            woodGrad.addColorStop(0.7, '#8B7A62');
            woodGrad.addColorStop(1, '#7A6952');
            ctx.fillStyle = woodGrad;
            ctx.fillRect(x, y, 50, 100);

            // Vertical board lines
            ctx.strokeStyle = '#6A5942';
            ctx.lineWidth = 1;
            for (let i = 0; i < 50; i += 8) {
                ctx.beginPath();
                ctx.moveTo(x + i, y);
                ctx.lineTo(x + i, y + 100);
                ctx.stroke();
            }

            // Upper platform/observation box
            ctx.fillStyle = '#A89880';
            ctx.fillRect(x - 5, y - 25, 60, 30);

            // Window in observation box
            ctx.fillStyle = '#2A4A5A';
            ctx.fillRect(x + 15, y - 20, 20, 15);

            // Platform extension to the left (diving board area)
            ctx.fillStyle = '#8B7A62';
            ctx.beginPath();
            ctx.moveTo(x, y + 30);
            ctx.lineTo(x - 40, y + 35);
            ctx.lineTo(x - 40, y + 45);
            ctx.lineTo(x, y + 45);
            ctx.fill();

            // Stair silhouette on left
            ctx.fillStyle = '#7A6952';
            ctx.beginPath();
            ctx.moveTo(x - 35, y + 100);
            ctx.lineTo(x - 35, y + 45);
            ctx.lineTo(x - 25, y + 45);
            ctx.lineTo(x - 25, y + 100);
            ctx.fill();
        }

        function drawPoolBuilding(x, y, w, h) {
            // Main building shadow
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(x + 3, y + 3, w, h);

            // Main building - weathered wood siding
            const buildingGrad = ctx.createLinearGradient(x, 0, x + w, 0);
            buildingGrad.addColorStop(0, '#8B7A65');
            buildingGrad.addColorStop(0.5, '#9A8975');
            buildingGrad.addColorStop(1, '#7A6955');
            ctx.fillStyle = buildingGrad;
            ctx.fillRect(x, y, w, h);

            // Vertical board texture
            ctx.strokeStyle = '#5A4935';
            ctx.lineWidth = 1;
            for (let i = 0; i < w; i += 10) {
                ctx.beginPath();
                ctx.moveTo(x + i, y);
                ctx.lineTo(x + i, y + h);
                ctx.stroke();
            }

            // Slanted metal roof
            ctx.fillStyle = '#5A6A6A';
            ctx.beginPath();
            ctx.moveTo(x - 5, y);
            ctx.lineTo(x + w * 0.6, y - 30);
            ctx.lineTo(x + w + 5, y);
            ctx.fill();

            // Roof highlight
            ctx.strokeStyle = '#7A8A8A';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - 5, y);
            ctx.lineTo(x + w * 0.6, y - 30);
            ctx.stroke();

            // Door openings
            ctx.fillStyle = '#2A1A1A';
            ctx.fillRect(x + 30, y + 40, 25, 40);
            ctx.fillRect(x + 80, y + 40, 25, 40);

            // Supergraphic accent - M and W letters (like real Ohlson)
            ctx.fillStyle = '#C41E3A';
            ctx.font = SeaRanchStyle.makeFont(20, 'bold');
            ctx.fillText('M', x + 120, y + 50);
            ctx.fillStyle = '#2E5DA8';
            ctx.fillText('W', x + 145, y + 50);
        }

        function drawSwimmingPool(x, y, w, h) {
            // Pool shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(x + 2, y + 2, w, h);

            // Pool water - beautiful turquoise
            const poolGrad = ctx.createLinearGradient(x, y, x, y + h);
            poolGrad.addColorStop(0, '#4AC4E0');
            poolGrad.addColorStop(0.5, '#38B4D0');
            poolGrad.addColorStop(1, '#2A9AB8');
            ctx.fillStyle = poolGrad;
            ctx.fillRect(x, y, w, h);

            // Lane lines
            ctx.strokeStyle = '#1A5A70';
            ctx.lineWidth = 2;
            for (let i = 1; i < 5; i++) {
                const laneY = y + (h / 5) * i;
                ctx.beginPath();
                ctx.moveTo(x + 10, laneY);
                ctx.lineTo(x + w - 10, laneY);
                ctx.stroke();
            }

            // Water ripple/sparkle effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            for (let i = 0; i < 15; i++) {
                const rx = x + 20 + (i * 15 + time * 0.5) % (w - 40);
                const ry = y + 10 + Math.sin(time * 0.1 + i) * 5 + (i % 4) * 15;
                ctx.beginPath();
                ctx.ellipse(rx, ry, 4, 2, time * 0.02 + i, 0, Math.PI * 2);
                ctx.fill();
            }

            // Pool edge/coping
            ctx.strokeStyle = '#E8E0D8';
            ctx.lineWidth = 4;
            ctx.strokeRect(x, y, w, h);
        }

        function drawDudleya(x, y) {
            // Dudleya succulent - rosette shape, blue-gray color
            const petalCount = 12;
            for (let ring = 2; ring >= 0; ring--) {
                const ringRadius = 8 + ring * 5;
                const petals = petalCount - ring * 2;
                for (let i = 0; i < petals; i++) {
                    const angle = (i / petals) * Math.PI * 2 + ring * 0.3;
                    const px = x + Math.cos(angle) * ringRadius * 0.6;
                    const py = y + Math.sin(angle) * ringRadius * 0.3;

                    ctx.fillStyle = ring === 0 ? '#8AA090' : (ring === 1 ? '#9AB0A0' : '#7A9080');
                    ctx.beginPath();
                    ctx.ellipse(px, py, 5, 8, angle, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            // Center
            ctx.fillStyle = '#A8C0B0';
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawSunnyRock(x, y) {
            // Warm sandstone rock - perfect basking spot
            ctx.fillStyle = '#B8A890';
            ctx.beginPath();
            ctx.ellipse(x, y, 25, 12, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Rock highlight (sunny side)
            ctx.fillStyle = '#D0C4B0';
            ctx.beginPath();
            ctx.ellipse(x - 5, y - 3, 15, 7, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Rock shadow
            ctx.fillStyle = '#9A8A78';
            ctx.beginPath();
            ctx.ellipse(x + 8, y + 5, 10, 4, 0, 0, Math.PI);
            ctx.fill();
        }

        function drawWesternFenceLizard(x, y) {
            // Western Fence Lizard - doing push-ups!
            const pushUp = Math.sin(time * 0.15) * 3; // Push-up animation
            const breathing = Math.sin(time * 0.1) * 0.5;

            ctx.save();
            ctx.translate(x, y + pushUp);

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(2, 8 - pushUp, 20, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tail - long and tapering
            ctx.fillStyle = '#5A5040';
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.quadraticCurveTo(35, -2, 50, 5);
            ctx.quadraticCurveTo(35, 8, 15, 3);
            ctx.fill();

            // Tail stripes
            ctx.strokeStyle = '#4A4030';
            ctx.lineWidth = 1;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(20 + i * 8, -1 + i * 0.5);
                ctx.lineTo(22 + i * 8, 4 + i * 0.3);
                ctx.stroke();
            }

            // Back legs
            ctx.fillStyle = '#5A5040';
            // Right back leg
            ctx.beginPath();
            ctx.moveTo(10, 2);
            ctx.lineTo(18, 10);
            ctx.lineTo(25, 12);
            ctx.lineTo(18, 8);
            ctx.lineTo(10, 4);
            ctx.fill();

            // Body
            ctx.fillStyle = '#6A6050';
            ctx.beginPath();
            ctx.ellipse(0, 0, 18, 8 + breathing, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body pattern - dorsal scales
            ctx.fillStyle = '#5A5040';
            for (let i = -12; i < 12; i += 4) {
                ctx.beginPath();
                ctx.arc(i, -2, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Blue belly patches (visible during push-up)
            if (pushUp > 1) {
                ctx.fillStyle = '#4A7AAA';
                ctx.beginPath();
                ctx.ellipse(-5, 5, 6, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(5, 5, 6, 3, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Front legs (doing push-ups!)
            ctx.fillStyle = '#5A5040';
            // Left front
            ctx.beginPath();
            ctx.moveTo(-12, 0);
            ctx.lineTo(-20, 6 - pushUp * 0.5);
            ctx.lineTo(-25, 4 - pushUp * 0.5);
            ctx.lineTo(-20, 4 - pushUp * 0.5);
            ctx.lineTo(-12, 2);
            ctx.fill();
            // Right front
            ctx.beginPath();
            ctx.moveTo(-12, 0);
            ctx.lineTo(-18, -6 + pushUp * 0.3);
            ctx.lineTo(-24, -8 + pushUp * 0.3);
            ctx.lineTo(-18, -5 + pushUp * 0.3);
            ctx.fill();

            // Head
            ctx.fillStyle = '#6A6050';
            ctx.beginPath();
            ctx.ellipse(-18, -1, 8, 6, -0.2, 0, Math.PI * 2);
            ctx.fill();

            // Head scales
            ctx.fillStyle = '#5A5040';
            ctx.beginPath();
            ctx.arc(-20, -3, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(-16, -4, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Eye
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(-22, -2, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(-22.5, -2.5, 0.8, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // ============== SCENE 4: SEA RANCH CHAPEL ==============
        function drawScene4_SeaRanchChapel() {
            // Sky - soft morning light
            const skyGrad = ctx.createLinearGradient(0, 0, 0, 160);
            skyGrad.addColorStop(0, '#5A9AC8');
            skyGrad.addColorStop(0.7, '#8AC4E4');
            skyGrad.addColorStop(1, '#C4DDE8');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, width, 160);

            // Distant forest tree line
            ctx.fillStyle = '#3A5A4A';
            for (let x = 0; x < width; x += 20) {
                const h = 30 + Math.sin(x * 0.1) * 15;
                ctx.beginPath();
                ctx.moveTo(x, 160);
                ctx.lineTo(x + 10, 160 - h);
                ctx.lineTo(x + 20, 160);
                ctx.fill();
            }

            // Ground/meadow
            ctx.fillStyle = '#8DB57A';
            ctx.fillRect(0, 150, width, 170);

            // Stone foundation/path area
            ctx.fillStyle = '#9A8A7A';
            ctx.beginPath();
            ctx.moveTo(150, 280);
            ctx.quadraticCurveTo(240, 260, 330, 280);
            ctx.lineTo(330, 320);
            ctx.lineTo(150, 320);
            ctx.fill();

            // The Chapel - organic sculptural form
            drawChapel(200, 120);

            // Indian Paintbrush flowers
            drawIndianPaintbrush(80, 270);
            drawIndianPaintbrush(120, 285);
            drawIndianPaintbrush(380, 275);
            drawIndianPaintbrush(420, 260);
            drawIndianPaintbrush(60, 290);

            // Foreground grass
            ctx.fillStyle = '#9ACA7A';
            ctx.fillRect(0, 290, width, 30);

            // Grass blades
            ctx.strokeStyle = '#7AAA5A';
            ctx.lineWidth = 1;
            for (let i = 0; i < 50; i++) {
                const gx = i * 10 + Math.sin(i) * 5;
                const sway = Math.sin(time * 0.02 + i * 0.5) * 2;
                ctx.beginPath();
                ctx.moveTo(gx, 295);
                ctx.quadraticCurveTo(gx + sway, 285, gx + sway * 1.5, 278);
                ctx.stroke();
            }
        }

        function drawChapel(x, y) {
            // The Sea Ranch Chapel - organic shell-like form
            // Two swooping shingled "wings" meeting at a spire

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.moveTo(x + 5, y + 135);
            ctx.quadraticCurveTo(x - 50, y + 60, x + 40, y - 30);
            ctx.quadraticCurveTo(x + 90, y + 20, x + 140, y + 60);
            ctx.quadraticCurveTo(x + 100, y + 100, x + 85, y + 135);
            ctx.fill();

            // Left wing - swooping shingle roof
            const leftWingGrad = ctx.createLinearGradient(x - 60, y, x + 40, y + 100);
            leftWingGrad.addColorStop(0, '#6A5A4A');
            leftWingGrad.addColorStop(0.5, '#7A6A5A');
            leftWingGrad.addColorStop(1, '#5A4A3A');
            ctx.fillStyle = leftWingGrad;
            ctx.beginPath();
            ctx.moveTo(x, y + 130);
            ctx.quadraticCurveTo(x - 60, y + 80, x - 40, y + 30);
            ctx.quadraticCurveTo(x - 20, y - 20, x + 35, y - 40);
            ctx.quadraticCurveTo(x + 30, y + 30, x + 30, y + 130);
            ctx.fill();

            // Right wing
            const rightWingGrad = ctx.createLinearGradient(x + 40, y, x + 140, y + 100);
            rightWingGrad.addColorStop(0, '#7A6A5A');
            rightWingGrad.addColorStop(0.5, '#8A7A6A');
            rightWingGrad.addColorStop(1, '#6A5A4A');
            ctx.fillStyle = rightWingGrad;
            ctx.beginPath();
            ctx.moveTo(x + 50, y + 130);
            ctx.quadraticCurveTo(x + 50, y + 30, x + 45, y - 40);
            ctx.quadraticCurveTo(x + 100, y - 20, x + 120, y + 30);
            ctx.quadraticCurveTo(x + 140, y + 80, x + 80, y + 130);
            ctx.fill();

            // Shingle texture - horizontal lines
            ctx.strokeStyle = '#4A3A2A';
            ctx.lineWidth = 1;
            for (let row = 0; row < 12; row++) {
                const rowY = y - 30 + row * 13;
                // Left wing shingles
                ctx.beginPath();
                const leftStart = x - 40 + row * 5;
                const leftEnd = x + 35;
                ctx.moveTo(leftStart, rowY);
                ctx.quadraticCurveTo((leftStart + leftEnd) / 2, rowY + 3, leftEnd, rowY + 5);
                ctx.stroke();

                // Right wing shingles
                ctx.beginPath();
                const rightStart = x + 45;
                const rightEnd = x + 120 - row * 3;
                ctx.moveTo(rightStart, rowY + 5);
                ctx.quadraticCurveTo((rightStart + rightEnd) / 2, rowY + 3, rightEnd, rowY);
                ctx.stroke();
            }

            // Central spire
            ctx.fillStyle = '#4A5A5A';
            ctx.beginPath();
            ctx.moveTo(x + 35, y - 40);
            ctx.lineTo(x + 40, y - 90);
            ctx.lineTo(x + 45, y - 40);
            ctx.fill();

            // Decorative bronze/copper elements at spire
            ctx.strokeStyle = '#5A8070';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + 40, y - 90);
            ctx.lineTo(x + 38, y - 110);
            ctx.moveTo(x + 40, y - 90);
            ctx.lineTo(x + 45, y - 105);
            ctx.moveTo(x + 40, y - 90);
            ctx.lineTo(x + 35, y - 102);
            ctx.stroke();

            // Wooden base/entrance
            ctx.fillStyle = '#8B6B4B';
            ctx.fillRect(x + 10, y + 100, 60, 30);

            // Vertical wood slats on base
            ctx.strokeStyle = '#6B4B2B';
            ctx.lineWidth = 1;
            for (let i = 0; i < 60; i += 5) {
                ctx.beginPath();
                ctx.moveTo(x + 10 + i, y + 100);
                ctx.lineTo(x + 10 + i, y + 130);
                ctx.stroke();
            }

            // Central window/entrance
            ctx.fillStyle = '#C4D4E4';
            ctx.beginPath();
            ctx.moveTo(x + 35, y + 20);
            ctx.lineTo(x + 25, y + 100);
            ctx.lineTo(x + 55, y + 100);
            ctx.lineTo(x + 45, y + 20);
            ctx.fill();

            // Window reflection
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.moveTo(x + 33, y + 30);
            ctx.lineTo(x + 28, y + 80);
            ctx.lineTo(x + 35, y + 80);
            ctx.lineTo(x + 38, y + 30);
            ctx.fill();
        }

        function drawIndianPaintbrush(x, y) {
            // Indian Paintbrush - red-orange brush-like flower
            // Stem
            ctx.strokeStyle = '#4A6A4A';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y + 20);
            ctx.quadraticCurveTo(x + 1, y + 10, x, y);
            ctx.stroke();

            // Leaves along stem
            ctx.fillStyle = '#5A7A5A';
            ctx.beginPath();
            ctx.ellipse(x - 4, y + 15, 6, 2, -0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + 4, y + 10, 5, 2, 0.5, 0, Math.PI * 2);
            ctx.fill();

            // The "brush" - red bracts
            const brushColors = ['#E84A30', '#D43A20', '#C82A10', '#F45A40'];
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI - Math.PI / 2;
                const bx = x + Math.cos(angle) * 4;
                const by = y - 5 + Math.sin(angle) * 2;
                const bHeight = 10 + Math.random() * 5;

                ctx.fillStyle = brushColors[i % brushColors.length];
                ctx.beginPath();
                ctx.moveTo(bx - 2, by);
                ctx.lineTo(bx, by - bHeight);
                ctx.lineTo(bx + 2, by);
                ctx.fill();
            }

            // Yellow-green tips (actual flowers)
            ctx.fillStyle = '#C4D44A';
            for (let i = 0; i < 5; i++) {
                const tx = x - 3 + i * 1.5;
                const ty = y - 12 - Math.random() * 3;
                ctx.beginPath();
                ctx.arc(tx, ty, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawAnnasHummingbird(x, y) {
            // Anna's Hummingbird - iridescent magenta gorget
            const hover = Math.sin(time * 0.5) * 3;
            const wingPhase = time * 0.8;

            ctx.save();
            ctx.translate(x, y + hover);

            // Wings - blur effect for rapid beating
            ctx.fillStyle = 'rgba(100, 120, 100, 0.4)';
            // Wing blur ellipses
            ctx.beginPath();
            ctx.ellipse(-8, 0, 15, 5, Math.sin(wingPhase) * 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(8, 0, 15, 5, -Math.sin(wingPhase) * 0.5, 0, Math.PI * 2);
            ctx.fill();

            // Tail
            ctx.fillStyle = '#3A4A3A';
            ctx.beginPath();
            ctx.moveTo(0, 8);
            ctx.lineTo(-5, 22);
            ctx.lineTo(0, 20);
            ctx.lineTo(5, 22);
            ctx.lineTo(0, 8);
            ctx.fill();

            // Body
            ctx.fillStyle = '#4A5A4A';
            ctx.beginPath();
            ctx.ellipse(0, 5, 6, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Belly - lighter
            ctx.fillStyle = '#7A8A7A';
            ctx.beginPath();
            ctx.ellipse(0, 8, 4, 6, 0, 0, Math.PI);
            ctx.fill();

            // Head
            ctx.fillStyle = '#3A4A3A';
            ctx.beginPath();
            ctx.arc(0, -6, 6, 0, Math.PI * 2);
            ctx.fill();

            // Gorget - iridescent magenta/rose (the key feature!)
            // Create shimmer effect
            const shimmer = Math.sin(time * 0.1) * 0.3 + 0.7;
            const gorgetGrad = ctx.createRadialGradient(0, -4, 0, 0, -4, 8);
            gorgetGrad.addColorStop(0, `rgba(220, 50, 100, ${shimmer})`);
            gorgetGrad.addColorStop(0.5, `rgba(180, 30, 80, ${shimmer})`);
            gorgetGrad.addColorStop(1, `rgba(100, 20, 50, ${shimmer * 0.5})`);
            ctx.fillStyle = gorgetGrad;
            ctx.beginPath();
            ctx.ellipse(0, -3, 5, 4, 0, 0.3, Math.PI - 0.3);
            ctx.fill();

            // Crown - also iridescent on males
            ctx.fillStyle = `rgba(200, 40, 90, ${shimmer * 0.8})`;
            ctx.beginPath();
            ctx.ellipse(0, -9, 4, 2, 0, Math.PI, Math.PI * 2);
            ctx.fill();

            // Beak - long and thin
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.moveTo(0, -6);
            ctx.lineTo(-18, -8);
            ctx.lineTo(0, -5);
            ctx.fill();

            // Eye
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(3, -7, 1.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // ============== SCENE 5: ONE EYED JACK'S ==============
        function drawScene5_OneEyedJacks() {
            // Sky through cypress canopy - dappled light
            ctx.fillStyle = '#4A7A9A';
            ctx.fillRect(0, 0, width, height);

            // Cypress trees - tall, dramatic, windswept
            drawCypressForest();

            // Ground - bark mulch and dirt
            ctx.fillStyle = '#5A4A3A';
            ctx.fillRect(0, 220, width, 100);

            // Playground structure
            drawPlayground(180, 150);

            // Miner's Lettuce patches
            drawMinersLettuce(50, 280);
            drawMinersLettuce(400, 270);
            drawMinersLettuce(100, 295);

            // Dappled light effect
            ctx.fillStyle = 'rgba(255, 250, 220, 0.15)';
            for (let i = 0; i < 20; i++) {
                const lx = 50 + Math.sin(time * 0.01 + i * 2) * 20 + i * 22;
                const ly = 180 + Math.cos(time * 0.015 + i) * 10 + (i % 4) * 25;
                ctx.beginPath();
                ctx.ellipse(lx, ly, 15 + Math.sin(i) * 5, 10, i * 0.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawCypressForest() {
            // Multiple layers of cypress trees
            const trees = [
                {x: -20, scale: 1.2, shade: 0.3},
                {x: 60, scale: 1.0, shade: 0.4},
                {x: 150, scale: 0.9, shade: 0.5},
                {x: 280, scale: 1.1, shade: 0.35},
                {x: 380, scale: 1.0, shade: 0.45},
                {x: 460, scale: 0.95, shade: 0.4}
            ];

            for (const tree of trees) {
                drawCypressTree(tree.x, 220, tree.scale, tree.shade);
            }
        }

        function drawCypressTree(x, baseY, scale, shade) {
            const h = 200 * scale;

            // Trunk - thick, gnarled
            ctx.fillStyle = `rgb(${80 - shade * 50}, ${60 - shade * 40}, ${50 - shade * 30})`;
            ctx.beginPath();
            ctx.moveTo(x + 20, baseY);
            ctx.quadraticCurveTo(x + 15, baseY - h * 0.3, x + 25, baseY - h * 0.6);
            ctx.lineTo(x + 35, baseY - h * 0.6);
            ctx.quadraticCurveTo(x + 45, baseY - h * 0.3, x + 40, baseY);
            ctx.fill();

            // Foliage - windswept, spreading
            const foliageColor = `rgb(${40 + shade * 30}, ${70 + shade * 20}, ${50 + shade * 20})`;
            ctx.fillStyle = foliageColor;

            // Main canopy - spreading shape
            ctx.beginPath();
            ctx.moveTo(x - 30 * scale, baseY - h * 0.4);
            ctx.quadraticCurveTo(x + 30, baseY - h * 0.9, x + 80 * scale, baseY - h * 0.5);
            ctx.quadraticCurveTo(x + 60, baseY - h * 0.5, x + 30, baseY - h * 0.4);
            ctx.quadraticCurveTo(x, baseY - h * 0.45, x - 30 * scale, baseY - h * 0.4);
            ctx.fill();

            // Secondary foliage mass
            ctx.beginPath();
            ctx.ellipse(x + 20, baseY - h * 0.65, 35 * scale, 25 * scale, 0.2, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPlayground(x, y) {
            // Weathered redwood playground structure

            // Main platform
            ctx.fillStyle = '#6A5A4A';
            ctx.fillRect(x, y, 120, 8);

            // Support posts
            ctx.fillStyle = '#5A4A3A';
            ctx.fillRect(x + 10, y + 8, 10, 70);
            ctx.fillRect(x + 100, y + 8, 10, 70);

            // Railing
            ctx.fillStyle = '#6A5A4A';
            ctx.fillRect(x, y - 25, 120, 5);

            // Railing posts
            for (let i = 0; i < 5; i++) {
                ctx.fillRect(x + 5 + i * 28, y - 25, 5, 25);
            }

            // Slide
            ctx.fillStyle = '#7A7A7A';
            ctx.beginPath();
            ctx.moveTo(x + 120, y + 5);
            ctx.lineTo(x + 180, y + 70);
            ctx.lineTo(x + 190, y + 70);
            ctx.lineTo(x + 130, y + 5);
            ctx.fill();

            // Slide sides
            ctx.strokeStyle = '#5A5A5A';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x + 120, y);
            ctx.lineTo(x + 180, y + 65);
            ctx.moveTo(x + 130, y);
            ctx.lineTo(x + 190, y + 65);
            ctx.stroke();
        }

        function drawMinersLettuce(x, y) {
            // Miner's Lettuce - round leaves with stem through center
            for (let i = 0; i < 5; i++) {
                const lx = x + (i - 2) * 12 + Math.random() * 5;
                const ly = y + Math.random() * 10;
                const size = 8 + Math.random() * 4;

                // Round leaf
                ctx.fillStyle = '#7ABA6A';
                ctx.beginPath();
                ctx.arc(lx, ly, size, 0, Math.PI * 2);
                ctx.fill();

                // Stem through center (the distinctive feature)
                ctx.fillStyle = '#5A9A4A';
                ctx.beginPath();
                ctx.arc(lx, ly, 2, 0, Math.PI * 2);
                ctx.fill();

                // Small white flower cluster
                if (i % 2 === 0) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(lx, ly - 2, 1.5, 0, Math.PI * 2);
                    ctx.arc(lx - 1, ly, 1, 0, Math.PI * 2);
                    ctx.arc(lx + 1, ly, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawAcornWoodpecker(x, y) {
            // Acorn Woodpecker - clown-faced, black/white/red
            const headBob = Math.sin(time * 0.2) * 2;

            ctx.save();
            ctx.translate(x, y);

            // Tail
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.moveTo(5, 10);
            ctx.lineTo(0, 28);
            ctx.lineTo(10, 28);
            ctx.lineTo(10, 10);
            ctx.fill();

            // Body
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.ellipse(5, 5, 10, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // White rump patch
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.ellipse(5, 12, 6, 5, 0, 0, Math.PI);
            ctx.fill();

            // Wing
            ctx.fillStyle = '#2A2A2A';
            ctx.beginPath();
            ctx.ellipse(8, 5, 8, 12, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // White wing patch
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.ellipse(12, 8, 3, 5, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.save();
            ctx.translate(0, headBob);

            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(0, -12, 10, 0, Math.PI * 2);
            ctx.fill();

            // Red cap
            ctx.fillStyle = '#CC2222';
            ctx.beginPath();
            ctx.arc(0, -18, 6, Math.PI, Math.PI * 2);
            ctx.fill();

            // White face - the "clown" pattern
            ctx.fillStyle = '#F5F5F0';
            ctx.beginPath();
            ctx.ellipse(-3, -10, 5, 6, -0.2, 0, Math.PI * 2);
            ctx.fill();

            // Yellow/white forehead
            ctx.fillStyle = '#E8E0A0';
            ctx.beginPath();
            ctx.ellipse(0, -15, 4, 3, 0, Math.PI, Math.PI * 2);
            ctx.fill();

            // Eye - staring, wild look
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(-5, -11, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(-5, -11, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Beak
            ctx.fillStyle = '#3A3A3A';
            ctx.beginPath();
            ctx.moveTo(-8, -10);
            ctx.lineTo(-20, -8);
            ctx.lineTo(-8, -7);
            ctx.fill();

            ctx.restore(); // head bob
            ctx.restore(); // main transform
        }

        // ============== SCENE 6: WALK ON BEACH (BLUFFS) ==============
        function drawScene6_WalkOnBeach() {
            // Sky - coastal overcast
            const skyGrad = ctx.createLinearGradient(0, 0, 0, 120);
            skyGrad.addColorStop(0, '#8AA8C0');
            skyGrad.addColorStop(1, '#B8D0E0');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, width, 120);

            // Ocean - deep blue
            const oceanGrad = ctx.createLinearGradient(0, 120, 0, 200);
            oceanGrad.addColorStop(0, '#2A5A7A');
            oceanGrad.addColorStop(1, '#3A6A8A');
            ctx.fillStyle = oceanGrad;
            ctx.fillRect(0, 120, width, 80);

            // Ocean waves
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            for (let i = 0; i < 6; i++) {
                const waveY = 130 + i * 12;
                const waveOffset = (time * 0.5 + i * 50) % width;
                ctx.beginPath();
                ctx.moveTo(0, waveY);
                for (let x = 0; x < width; x += 20) {
                    ctx.lineTo(x, waveY + Math.sin((x + waveOffset) * 0.05) * 3);
                }
                ctx.lineTo(width, waveY + 5);
                ctx.lineTo(0, waveY + 5);
                ctx.fill();
            }

            // Coastal bluff
            ctx.fillStyle = '#8A7A5A';
            ctx.beginPath();
            ctx.moveTo(0, 200);
            ctx.quadraticCurveTo(100, 180, 200, 195);
            ctx.quadraticCurveTo(350, 210, 480, 190);
            ctx.lineTo(480, 320);
            ctx.lineTo(0, 320);
            ctx.fill();

            // Bluff grass
            ctx.fillStyle = '#8AAA6A';
            ctx.beginPath();
            ctx.moveTo(0, 195);
            ctx.quadraticCurveTo(100, 175, 200, 190);
            ctx.quadraticCurveTo(350, 205, 480, 185);
            ctx.lineTo(480, 210);
            ctx.quadraticCurveTo(350, 230, 200, 215);
            ctx.quadraticCurveTo(100, 200, 0, 220);
            ctx.fill();

            // Rocky outcrop where oystercatcher lives
            drawRockyOutcrop(320, 200);

            // Sea Thrift flowers (pink puffs)
            drawSeaThrift(80, 220);
            drawSeaThrift(150, 235);
            drawSeaThrift(400, 215);

            // Trail
            ctx.fillStyle = '#A89A7A';
            ctx.beginPath();
            ctx.moveTo(0, 280);
            ctx.quadraticCurveTo(240, 260, 480, 275);
            ctx.lineTo(480, 295);
            ctx.quadraticCurveTo(240, 280, 0, 300);
            ctx.fill();
        }

        function drawRockyOutcrop(x, y) {
            // Dark rocks jutting into water
            ctx.fillStyle = '#4A4A4A';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + 20, y - 30);
            ctx.lineTo(x + 50, y - 25);
            ctx.lineTo(x + 70, y - 35);
            ctx.lineTo(x + 90, y - 20);
            ctx.lineTo(x + 100, y + 10);
            ctx.lineTo(x + 80, y + 20);
            ctx.lineTo(x + 30, y + 15);
            ctx.fill();

            // Rock highlights
            ctx.fillStyle = '#6A6A6A';
            ctx.beginPath();
            ctx.ellipse(x + 40, y - 15, 15, 8, -0.2, 0, Math.PI * 2);
            ctx.fill();

            // Wet rock shine
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.beginPath();
            ctx.ellipse(x + 35, y - 20, 8, 4, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawSeaThrift(x, y) {
            // Sea Thrift - pink pom-pom flowers on thin stems
            // Stems
            ctx.strokeStyle = '#5A7A5A';
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
                const sx = x + (i - 1) * 8;
                const sway = Math.sin(time * 0.03 + i) * 2;
                ctx.beginPath();
                ctx.moveTo(sx, y + 15);
                ctx.quadraticCurveTo(sx + sway, y + 5, sx + sway, y - 10);
                ctx.stroke();

                // Pink flower puff
                ctx.fillStyle = '#E8A0B0';
                ctx.beginPath();
                ctx.arc(sx + sway, y - 13, 6, 0, Math.PI * 2);
                ctx.fill();

                // Flower details
                ctx.fillStyle = '#D090A0';
                for (let j = 0; j < 5; j++) {
                    const angle = (j / 5) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(sx + sway + Math.cos(angle) * 3, y - 13 + Math.sin(angle) * 3, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Grass-like leaves at base
            ctx.fillStyle = '#6A8A5A';
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI - Math.PI / 2;
                ctx.beginPath();
                ctx.ellipse(x + Math.cos(angle) * 8, y + 12, 2, 8, angle, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawBlackOystercatcher(x, y) {
            // Black Oystercatcher - all black with bright orange beak
            const bob = Math.sin(time * 0.1) * 1;

            ctx.save();
            ctx.translate(x, y + bob);

            // Legs - pink/orange
            ctx.strokeStyle = '#E8A080';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-5, 12);
            ctx.lineTo(-5, 22);
            ctx.moveTo(5, 12);
            ctx.lineTo(5, 22);
            ctx.stroke();

            // Body - jet black
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.ellipse(0, 5, 15, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wing
            ctx.fillStyle = '#2A2A2A';
            ctx.beginPath();
            ctx.ellipse(5, 5, 12, 10, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(-12, -3, 8, 0, Math.PI * 2);
            ctx.fill();

            // Eye ring - red
            ctx.strokeStyle = '#CC3030';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(-14, -4, 3, 0, Math.PI * 2);
            ctx.stroke();

            // Eye
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(-14, -4, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(-14, -4, 1, 0, Math.PI * 2);
            ctx.fill();

            // BEAK - the iconic orange chisel beak!
            ctx.fillStyle = '#FF6030';
            ctx.beginPath();
            ctx.moveTo(-18, -3);
            ctx.lineTo(-45, -1);
            ctx.lineTo(-45, 1);
            ctx.lineTo(-18, 0);
            ctx.fill();

            // Beak highlight
            ctx.fillStyle = '#FF8050';
            ctx.beginPath();
            ctx.moveTo(-18, -3);
            ctx.lineTo(-40, -2);
            ctx.lineTo(-18, -1);
            ctx.fill();

            ctx.restore();
        }

        // ============== SCENE 7: DEL MAR REC CENTER ==============
        function drawScene7_DelMarRecCenter() {
            // Sky - golden afternoon
            const skyGrad = ctx.createLinearGradient(0, 0, 0, 150);
            skyGrad.addColorStop(0, '#6A9AC8');
            skyGrad.addColorStop(1, '#C8D8E8');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, width, 150);

            // Meadow
            ctx.fillStyle = '#9ABA7A';
            ctx.fillRect(0, 140, width, 180);

            // Building in background
            ctx.fillStyle = '#8A7A6A';
            ctx.fillRect(320, 120, 100, 60);
            ctx.fillStyle = '#6A6A6A';
            ctx.beginPath();
            ctx.moveTo(315, 120);
            ctx.lineTo(370, 90);
            ctx.lineTo(425, 120);
            ctx.fill();

            // Seaside Buckwheat patches (butterfly host plant)
            drawSeasideBuckwheat(100, 200);
            drawSeasideBuckwheat(200, 220);
            drawSeasideBuckwheat(350, 210);
            drawSeasideBuckwheat(80, 250);
            drawSeasideBuckwheat(420, 240);

            // Milkweed for monarchs
            drawMilkweed(150, 230);
            drawMilkweed(280, 215);

            // Foreground grass
            ctx.fillStyle = '#8AAA6A';
            ctx.fillRect(0, 270, width, 50);

            // Grass texture
            ctx.strokeStyle = '#7A9A5A';
            for (let i = 0; i < 60; i++) {
                const gx = i * 8;
                const sway = Math.sin(time * 0.02 + i * 0.3) * 2;
                ctx.beginPath();
                ctx.moveTo(gx, 275);
                ctx.quadraticCurveTo(gx + sway, 265, gx + sway * 1.5, 260);
                ctx.stroke();
            }
        }

        function drawSeasideBuckwheat(x, y) {
            // Seaside Buckwheat - rust/pink flower clusters
            // Woody base
            ctx.strokeStyle = '#6A5040';
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 0.8 - Math.PI * 0.4;
                ctx.beginPath();
                ctx.moveTo(x, y + 10);
                ctx.quadraticCurveTo(x + Math.cos(angle) * 10, y, x + Math.cos(angle) * 20, y - 10 + Math.sin(i) * 5);
                ctx.stroke();
            }

            // Flower clusters - rusty pink
            const colors = ['#D8A090', '#C89080', '#E8B0A0'];
            for (let i = 0; i < 5; i++) {
                const fx = x + (i - 2) * 12 + Math.sin(i * 2) * 5;
                const fy = y - 8 + Math.cos(i) * 8;
                ctx.fillStyle = colors[i % 3];
                ctx.beginPath();
                ctx.arc(fx, fy, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawMilkweed(x, y) {
            // Milkweed - monarch butterfly host plant
            // Stem
            ctx.strokeStyle = '#5A8050';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x, y + 25);
            ctx.lineTo(x, y - 10);
            ctx.stroke();

            // Leaves - opposite, broad
            ctx.fillStyle = '#6A9060';
            for (let i = 0; i < 3; i++) {
                const ly = y + 15 - i * 12;
                // Left leaf
                ctx.beginPath();
                ctx.ellipse(x - 12, ly, 10, 5, -0.3, 0, Math.PI * 2);
                ctx.fill();
                // Right leaf
                ctx.beginPath();
                ctx.ellipse(x + 12, ly, 10, 5, 0.3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Flower cluster - pink globe
            ctx.fillStyle = '#E8A0C0';
            ctx.beginPath();
            ctx.arc(x, y - 15, 10, 0, Math.PI * 2);
            ctx.fill();

            // Individual florets
            ctx.fillStyle = '#D080A0';
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                ctx.beginPath();
                ctx.arc(x + Math.cos(angle) * 6, y - 15 + Math.sin(angle) * 6, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawMonarchButterfly(x, y) {
            // Monarch Butterfly - orange and black, fluttering
            const flutter = Math.sin(time * 0.3) * 0.4;
            const drift = Math.sin(time * 0.05) * 10;

            ctx.save();
            ctx.translate(x + drift, y);

            // Wings - orange with black borders
            // Left wing
            ctx.save();
            ctx.scale(1, Math.cos(flutter));
            ctx.fillStyle = '#E87020';
            ctx.beginPath();
            ctx.ellipse(-12, 0, 15, 12, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Wing pattern - black
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.ellipse(-12, 0, 15, 12, -0.3, 0, Math.PI * 2);
            ctx.stroke();
            // Veins
            ctx.strokeStyle = '#1A1A1A';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-5, 0);
            ctx.lineTo(-20, -5);
            ctx.moveTo(-5, 0);
            ctx.lineTo(-22, 3);
            ctx.moveTo(-5, 0);
            ctx.lineTo(-15, 8);
            ctx.stroke();

            // White spots
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(-20, -8, 2, 0, Math.PI * 2);
            ctx.arc(-22, -3, 1.5, 0, Math.PI * 2);
            ctx.arc(-18, 8, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Right wing
            ctx.save();
            ctx.scale(1, Math.cos(flutter));
            ctx.fillStyle = '#E87020';
            ctx.beginPath();
            ctx.ellipse(12, 0, 15, 12, 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#1A1A1A';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(5, 0);
            ctx.lineTo(20, -5);
            ctx.moveTo(5, 0);
            ctx.lineTo(22, 3);
            ctx.moveTo(5, 0);
            ctx.lineTo(15, 8);
            ctx.stroke();
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(20, -8, 2, 0, Math.PI * 2);
            ctx.arc(22, -3, 1.5, 0, Math.PI * 2);
            ctx.arc(18, 8, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Body
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.ellipse(0, 0, 3, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.beginPath();
            ctx.arc(0, -12, 3, 0, Math.PI * 2);
            ctx.fill();

            // Antennae
            ctx.strokeStyle = '#1A1A1A';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-1, -14);
            ctx.quadraticCurveTo(-5, -20, -3, -22);
            ctx.moveTo(1, -14);
            ctx.quadraticCurveTo(5, -20, 3, -22);
            ctx.stroke();

            ctx.restore();
        }

        // ============== SCENE 8: SALAL TRAIL WATERFALL ==============
        function drawScene8_SalalTrailWaterfall() {
            // Deep forest - dark, mysterious, green
            ctx.fillStyle = '#1A3020';
            ctx.fillRect(0, 0, width, height);

            // Layered forest canopy
            drawForestCanopy();

            // Massive redwood trunks
            drawRedwoodTrunk(50, 320, 40, 280);
            drawRedwoodTrunk(400, 320, 50, 300);

            // Fallen log framing the waterfall
            drawFallenLog(150, 160);

            // The waterfall
            drawWaterfall(220, 80);

            // Stream/pool at bottom
            drawForestPool(180, 260);

            // Sword Ferns
            drawSwordFern(30, 280);
            drawSwordFern(100, 300);
            drawSwordFern(380, 290);
            drawSwordFern(450, 275);

            // Moss patches
            ctx.fillStyle = '#4A7040';
            ctx.beginPath();
            ctx.ellipse(300, 290, 30, 10, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawForestCanopy() {
            // Layers of foliage creating dappled darkness
            for (let layer = 0; layer < 3; layer++) {
                const shade = 0.1 + layer * 0.1;
                ctx.fillStyle = `rgba(30, ${60 + layer * 20}, 40, ${0.8 - layer * 0.2})`;
                for (let i = 0; i < 10; i++) {
                    const x = i * 50 + layer * 20;
                    const y = 20 + layer * 40 + Math.sin(i + layer) * 20;
                    ctx.beginPath();
                    ctx.ellipse(x, y, 40, 30, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawRedwoodTrunk(x, baseY, w, h) {
            // Massive redwood trunk with fibrous bark
            const barkGrad = ctx.createLinearGradient(x, 0, x + w, 0);
            barkGrad.addColorStop(0, '#5A3020');
            barkGrad.addColorStop(0.3, '#6A4030');
            barkGrad.addColorStop(0.7, '#5A3020');
            barkGrad.addColorStop(1, '#4A2010');
            ctx.fillStyle = barkGrad;
            ctx.fillRect(x, baseY - h, w, h);

            // Bark texture - vertical furrows
            ctx.strokeStyle = '#3A2010';
            ctx.lineWidth = 2;
            for (let i = 0; i < w; i += 6) {
                const furrowX = x + i + Math.sin(i * 0.5) * 2;
                ctx.beginPath();
                ctx.moveTo(furrowX, baseY - h);
                for (let y = baseY - h; y < baseY; y += 20) {
                    ctx.lineTo(furrowX + Math.sin(y * 0.1) * 2, y);
                }
                ctx.stroke();
            }

            // Moss on trunk
            ctx.fillStyle = '#4A7040';
            ctx.beginPath();
            ctx.ellipse(x + w * 0.3, baseY - h * 0.3, 8, 15, 0.2, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawFallenLog(x, y) {
            // Fallen log spanning view - natural frame
            ctx.fillStyle = '#4A3025';
            ctx.beginPath();
            ctx.moveTo(x - 50, y + 30);
            ctx.quadraticCurveTo(x + 100, y - 20, x + 250, y + 20);
            ctx.lineTo(x + 250, y + 50);
            ctx.quadraticCurveTo(x + 100, y + 10, x - 50, y + 60);
            ctx.fill();

            // Bark texture
            ctx.strokeStyle = '#3A2015';
            ctx.lineWidth = 1;
            for (let i = 0; i < 300; i += 15) {
                ctx.beginPath();
                ctx.moveTo(x - 50 + i, y + 35 + Math.sin(i * 0.1) * 5);
                ctx.lineTo(x - 50 + i, y + 55 + Math.sin(i * 0.1) * 5);
                ctx.stroke();
            }

            // Moss on log
            ctx.fillStyle = '#5A8050';
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.ellipse(x + i * 50, y + 25, 15, 8, 0, Math.PI, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawWaterfall(x, y) {
            // Cascading waterfall with mist
            // Water streams
            ctx.fillStyle = 'rgba(200, 220, 230, 0.7)';
            for (let i = 0; i < 5; i++) {
                const streamX = x + i * 15 - 30;
                const wobble = Math.sin(time * 0.1 + i) * 3;
                ctx.beginPath();
                ctx.moveTo(streamX + wobble, y);
                ctx.quadraticCurveTo(streamX + wobble * 2, y + 80, streamX, y + 160);
                ctx.lineTo(streamX + 8, y + 160);
                ctx.quadraticCurveTo(streamX + 8 + wobble * 2, y + 80, streamX + 8 + wobble, y);
                ctx.fill();
            }

            // Mist at base
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            for (let i = 0; i < 8; i++) {
                const mx = x - 40 + i * 15 + Math.sin(time * 0.05 + i) * 10;
                const my = y + 150 + Math.cos(time * 0.03 + i) * 5;
                ctx.beginPath();
                ctx.ellipse(mx, my, 20, 10, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Splash highlights
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            for (let i = 0; i < 10; i++) {
                const sx = x - 30 + Math.random() * 60;
                const sy = y + 155 + Math.random() * 10;
                ctx.beginPath();
                ctx.arc(sx, sy, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawForestPool(x, y) {
            // Dark forest pool
            ctx.fillStyle = '#2A4A4A';
            ctx.beginPath();
            ctx.ellipse(x + 60, y + 20, 80, 25, 0, 0, Math.PI * 2);
            ctx.fill();

            // Reflection
            ctx.fillStyle = 'rgba(100, 150, 130, 0.3)';
            ctx.beginPath();
            ctx.ellipse(x + 60, y + 15, 60, 15, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawSwordFern(x, y) {
            // Sword Fern - classic PNW forest understory
            ctx.strokeStyle = '#3A6030';
            ctx.lineWidth = 2;

            for (let frond = 0; frond < 5; frond++) {
                const angle = (frond / 5) * Math.PI * 0.8 - Math.PI * 0.4;
                const length = 35 + Math.random() * 15;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);

                // Main stem
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -length);
                ctx.stroke();

                // Pinnae (leaflets)
                ctx.fillStyle = '#4A8040';
                for (let i = 0; i < length - 5; i += 4) {
                    const pinnaeLength = 8 * (1 - i / length);
                    // Left pinnae
                    ctx.beginPath();
                    ctx.ellipse(-pinnaeLength / 2, -i - 5, pinnaeLength, 2, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // Right pinnae
                    ctx.beginPath();
                    ctx.ellipse(pinnaeLength / 2, -i - 5, pinnaeLength, 2, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        function drawRoughSkinnedNewt(x, y) {
            // Rough-skinned Newt - brown top, bright orange belly
            const walk = Math.sin(time * 0.1) * 2;

            ctx.save();
            ctx.translate(x, y);

            // Tail
            ctx.fillStyle = '#5A4030';
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.quadraticCurveTo(35, -5, 45, 0);
            ctx.quadraticCurveTo(35, 5, 15, 2);
            ctx.fill();

            // Back legs
            ctx.fillStyle = '#5A4030';
            ctx.beginPath();
            ctx.ellipse(10 + walk, 8, 8, 4, 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(10 - walk, -6, 8, 4, -0.5, 0, Math.PI * 2);
            ctx.fill();

            // Body - brown/olive
            ctx.fillStyle = '#6A5040';
            ctx.beginPath();
            ctx.ellipse(0, 0, 18, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Warty texture
            ctx.fillStyle = '#5A4030';
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.arc(-10 + i * 3, -2 + (i % 2) * 4, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Orange belly (visible on sides)
            ctx.fillStyle = '#FF8040';
            ctx.beginPath();
            ctx.ellipse(0, 5, 12, 3, 0, 0, Math.PI);
            ctx.fill();

            // Front legs
            ctx.fillStyle = '#5A4030';
            ctx.beginPath();
            ctx.ellipse(-12 - walk, 6, 7, 3, 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(-12 + walk, -5, 7, 3, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = '#6A5040';
            ctx.beginPath();
            ctx.ellipse(-18, 0, 8, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eyes - bulging
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.arc(-20, -4, 2.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(-20, 4, 2.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // ============== SCENE 9: GUALALA POINT PARK ==============
        function drawScene9_GualalaPointPark() {
            // Sky - late afternoon
            const skyGrad = ctx.createLinearGradient(0, 0, 0, 130);
            skyGrad.addColorStop(0, '#6090B8');
            skyGrad.addColorStop(1, '#A0C0D8');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, width, 130);

            // River/estuary
            const waterGrad = ctx.createLinearGradient(0, 130, 0, 220);
            waterGrad.addColorStop(0, '#4A7A90');
            waterGrad.addColorStop(1, '#3A6A80');
            ctx.fillStyle = waterGrad;
            ctx.fillRect(0, 130, width, 90);

            // Water ripples
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                const wy = 140 + i * 10;
                ctx.beginPath();
                for (let x = 0; x < width; x += 10) {
                    ctx.lineTo(x, wy + Math.sin((x + time * 0.5 + i * 20) * 0.05) * 2);
                }
                ctx.stroke();
            }

            // Far bank with trees
            ctx.fillStyle = '#6A8A5A';
            ctx.fillRect(0, 120, width, 15);
            ctx.fillStyle = '#4A6A4A';
            for (let i = 0; i < width; i += 25) {
                ctx.beginPath();
                ctx.moveTo(i, 120);
                ctx.lineTo(i + 12, 90 + Math.sin(i * 0.1) * 10);
                ctx.lineTo(i + 24, 120);
                ctx.fill();
            }

            // Near bank - estuary marsh
            ctx.fillStyle = '#8AAA70';
            ctx.beginPath();
            ctx.moveTo(0, 220);
            ctx.quadraticCurveTo(150, 200, 300, 210);
            ctx.quadraticCurveTo(400, 220, 480, 205);
            ctx.lineTo(480, 320);
            ctx.lineTo(0, 320);
            ctx.fill();

            // Pickleweed patches
            drawPickleweed(80, 240);
            drawPickleweed(200, 250);
            drawPickleweed(350, 235);
            drawPickleweed(450, 255);

            // Mudflat
            ctx.fillStyle = '#7A7060';
            ctx.beginPath();
            ctx.ellipse(240, 230, 100, 20, 0, 0, Math.PI * 2);
            ctx.fill();

            // Driftwood
            ctx.fillStyle = '#9A8A7A';
            ctx.beginPath();
            ctx.ellipse(280, 260, 40, 6, 0.1, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPickleweed(x, y) {
            // Pickleweed - succulent marsh plant
            ctx.fillStyle = '#7AAA60';
            for (let i = 0; i < 8; i++) {
                const px = x + (i - 4) * 6;
                const py = y + Math.sin(i) * 3;
                const h = 15 + Math.random() * 10;

                // Segmented succulent stem
                for (let j = 0; j < h; j += 4) {
                    const segY = py - j;
                    const segWidth = 3 - j * 0.1;
                    ctx.beginPath();
                    ctx.ellipse(px, segY, segWidth, 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Some reddish tips (fall color)
            ctx.fillStyle = '#C07050';
            for (let i = 0; i < 3; i++) {
                const px = x + (i - 1) * 8;
                ctx.beginPath();
                ctx.arc(px, y - 20, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawGreatBlueHeron(x, y) {
            // Great Blue Heron - tall, elegant, patient
            const neckMove = Math.sin(time * 0.05) * 5;

            ctx.save();
            ctx.translate(x, y);

            // Legs - long, yellow-gray
            ctx.strokeStyle = '#8A8A60';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-5, 30);
            ctx.lineTo(-5, 70);
            ctx.moveTo(5, 30);
            ctx.lineTo(5, 70);
            ctx.stroke();

            // Body - blue-gray
            ctx.fillStyle = '#5A6A7A';
            ctx.beginPath();
            ctx.ellipse(0, 20, 20, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wing
            ctx.fillStyle = '#4A5A6A';
            ctx.beginPath();
            ctx.ellipse(8, 20, 18, 12, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Neck - S-curve
            ctx.strokeStyle = '#6A7A8A';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(-5, 10);
            ctx.quadraticCurveTo(-15 + neckMove, -20, -10, -50);
            ctx.stroke();

            // Neck feathers
            ctx.fillStyle = '#F5F5F0';
            ctx.beginPath();
            ctx.ellipse(-8, 0, 6, 10, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = '#F5F5F0';
            ctx.beginPath();
            ctx.ellipse(-10 + neckMove * 0.3, -55, 8, 6, -0.2, 0, Math.PI * 2);
            ctx.fill();

            // Black crown stripe
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.ellipse(-8 + neckMove * 0.3, -60, 10, 3, -0.1, 0, Math.PI * 2);
            ctx.fill();

            // Plume
            ctx.strokeStyle = '#1A1A1A';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-5 + neckMove * 0.3, -62);
            ctx.quadraticCurveTo(10, -65, 20, -58);
            ctx.stroke();

            // Beak - dagger-like
            ctx.fillStyle = '#D0A040';
            ctx.beginPath();
            ctx.moveTo(-15 + neckMove * 0.3, -55);
            ctx.lineTo(-45 + neckMove * 0.3, -52);
            ctx.lineTo(-15 + neckMove * 0.3, -50);
            ctx.fill();

            // Eye
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(-5 + neckMove * 0.3, -55, 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // ============== SCENE 10: DRIFTWOOD BEACH ==============
        function drawScene10_DriftwoodBeach() {
            // Foggy atmosphere
            const skyGrad = ctx.createLinearGradient(0, 0, 0, height);
            skyGrad.addColorStop(0, '#A0A8B0');
            skyGrad.addColorStop(0.3, '#B8C0C8');
            skyGrad.addColorStop(1, '#C8D0D8');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, width, height);

            // Distant fog/ocean blend
            ctx.fillStyle = 'rgba(180, 190, 200, 0.8)';
            ctx.fillRect(0, 80, width, 40);

            // Waves barely visible in fog
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            for (let i = 0; i < 4; i++) {
                const wy = 100 + i * 8;
                ctx.beginPath();
                ctx.moveTo(0, wy);
                for (let x = 0; x < width; x += 30) {
                    ctx.lineTo(x, wy + Math.sin((x + time * 0.3) * 0.03) * 2);
                }
                ctx.lineTo(width, wy + 3);
                ctx.lineTo(0, wy + 3);
                ctx.fill();
            }

            // Beach - gray sand
            ctx.fillStyle = '#8A8A85';
            ctx.fillRect(0, 130, width, 190);

            // Sand texture
            ctx.fillStyle = '#9A9A95';
            for (let i = 0; i < 100; i++) {
                ctx.beginPath();
                ctx.arc(Math.random() * width, 130 + Math.random() * 190, 1, 0, Math.PI * 2);
                ctx.fill();
            }

            // Driftwood structures - the iconic sculptures
            drawDriftwoodStructure(150, 180);
            drawDriftwoodStructure(350, 200);

            // Scattered driftwood pieces
            drawDriftwoodPiece(50, 250);
            drawDriftwoodPiece(420, 270);
            drawDriftwoodPiece(280, 290);

            // Beach Strawberry patches
            drawBeachStrawberry(80, 280);
            drawBeachStrawberry(400, 265);

            // Fog wisps
            ctx.fillStyle = 'rgba(200, 210, 220, 0.3)';
            for (let i = 0; i < 5; i++) {
                const fx = (i * 120 + time * 0.2) % (width + 100) - 50;
                ctx.beginPath();
                ctx.ellipse(fx, 100 + i * 30, 80, 20, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawDriftwoodStructure(x, y) {
            // Driftwood fort/sculpture - vertical logs leaning together
            const logs = [
                {dx: -30, dy: 0, h: 80, lean: -0.2},
                {dx: -15, dy: 5, h: 90, lean: -0.1},
                {dx: 0, dy: 0, h: 95, lean: 0},
                {dx: 15, dy: 5, h: 85, lean: 0.1},
                {dx: 30, dy: 0, h: 75, lean: 0.15}
            ];

            for (const log of logs) {
                ctx.save();
                ctx.translate(x + log.dx, y + log.dy);
                ctx.rotate(log.lean);

                // Log - weathered gray
                const logGrad = ctx.createLinearGradient(-5, 0, 5, 0);
                logGrad.addColorStop(0, '#9A9590');
                logGrad.addColorStop(0.5, '#B0AAA5');
                logGrad.addColorStop(1, '#8A8580');
                ctx.fillStyle = logGrad;
                ctx.fillRect(-5, -log.h, 10, log.h);

                // Wood grain
                ctx.strokeStyle = '#7A7570';
                ctx.lineWidth = 1;
                for (let i = 0; i < log.h; i += 8) {
                    ctx.beginPath();
                    ctx.moveTo(-4, -i);
                    ctx.lineTo(4, -i - 2);
                    ctx.stroke();
                }

                ctx.restore();
            }

            // Crossbeam
            ctx.fillStyle = '#A09A95';
            ctx.save();
            ctx.translate(x, y - 60);
            ctx.rotate(-0.1);
            ctx.fillRect(-35, 0, 70, 8);
            ctx.restore();
        }

        function drawDriftwoodPiece(x, y) {
            // Individual driftwood log
            ctx.fillStyle = '#A0A095';
            ctx.beginPath();
            ctx.ellipse(x, y, 25, 6, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Weathered end
            ctx.fillStyle = '#B0AAA5';
            ctx.beginPath();
            ctx.ellipse(x - 20, y, 6, 6, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawBeachStrawberry(x, y) {
            // Beach Strawberry - low-growing, green leaves, small red fruits
            // Leaves - trifoliate
            ctx.fillStyle = '#5A8A50';
            for (let i = 0; i < 4; i++) {
                const lx = x + (i - 1.5) * 15;
                const ly = y + Math.sin(i) * 5;

                // Three leaflets
                ctx.beginPath();
                ctx.ellipse(lx - 5, ly - 3, 6, 4, -0.3, 0, Math.PI * 2);
                ctx.ellipse(lx + 5, ly - 3, 6, 4, 0.3, 0, Math.PI * 2);
                ctx.ellipse(lx, ly - 8, 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Small red strawberries
            ctx.fillStyle = '#D04040';
            ctx.beginPath();
            ctx.arc(x + 5, y + 2, 4, 0, Math.PI * 2);
            ctx.arc(x - 10, y - 2, 3, 0, Math.PI * 2);
            ctx.fill();

            // Seeds
            ctx.fillStyle = '#FFE080';
            ctx.beginPath();
            ctx.arc(x + 4, y + 1, 0.8, 0, Math.PI * 2);
            ctx.arc(x + 6, y + 3, 0.8, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawHarborSeal(x, y) {
            // Harbor Seal - spotted, lounging on beach
            const breathe = Math.sin(time * 0.08) * 2;

            ctx.save();
            ctx.translate(x, y);

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.beginPath();
            ctx.ellipse(5, 12, 35, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body - elongated blob shape
            ctx.fillStyle = '#7A7A70';
            ctx.beginPath();
            ctx.ellipse(0, breathe, 35, 15 + breathe * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Spots
            ctx.fillStyle = '#5A5A50';
            const spots = [
                {x: -15, y: -5}, {x: -8, y: 3}, {x: 5, y: -3},
                {x: 12, y: 5}, {x: 20, y: -2}, {x: -20, y: 2}
            ];
            for (const spot of spots) {
                ctx.beginPath();
                ctx.ellipse(spot.x, spot.y + breathe, 4, 3, Math.random(), 0, Math.PI * 2);
                ctx.fill();
            }

            // Belly - lighter
            ctx.fillStyle = '#9A9A90';
            ctx.beginPath();
            ctx.ellipse(0, 8 + breathe, 25, 6, 0, 0, Math.PI);
            ctx.fill();

            // Back flippers
            ctx.fillStyle = '#6A6A60';
            ctx.beginPath();
            ctx.ellipse(30, 5 + breathe, 12, 6, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = '#7A7A70';
            ctx.beginPath();
            ctx.ellipse(-35, -5 + breathe * 0.5, 12, 10, -0.2, 0, Math.PI * 2);
            ctx.fill();

            // Snout
            ctx.fillStyle = '#8A8A80';
            ctx.beginPath();
            ctx.ellipse(-45, -3 + breathe * 0.5, 8, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nostrils
            ctx.fillStyle = '#3A3A30';
            ctx.beginPath();
            ctx.ellipse(-50, -4 + breathe * 0.5, 2, 1, 0, 0, Math.PI * 2);
            ctx.ellipse(-50, -1 + breathe * 0.5, 2, 1, 0, 0, Math.PI * 2);
            ctx.fill();

            // Whiskers
            ctx.strokeStyle = '#4A4A40';
            ctx.lineWidth = 1;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(-48, -2 + i * 2 + breathe * 0.5);
                ctx.lineTo(-58, -4 + i * 3 + breathe * 0.5);
                ctx.stroke();
            }

            // Eyes - large, dark, soulful
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.ellipse(-38, -8 + breathe * 0.5, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eye shine
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(-39, -9 + breathe * 0.5, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Front flipper
            ctx.fillStyle = '#6A6A60';
            ctx.beginPath();
            ctx.ellipse(-25, 10 + breathe, 10, 5, 0.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawViewfinder() {
            const px = PIXEL_SIZE;

            // Draw instruction prompt when binoculars are lowered
            if (!binocularsRaised) {
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                pixelRect(width/2 - 110, height - 55, 220, 45, 'rgba(0,0,0,0.6)');

                ctx.fillStyle = '#FFFFFF';
                ctx.font = SeaRanchStyle.makeFont(12, 'bold');
                ctx.textAlign = 'center';
                ctx.fillText('Press A to raise binoculars', width/2, height - 32);

                ctx.font = SeaRanchStyle.makeFont(10);
                ctx.fillStyle = '#AAA';
                ctx.fillText(`Spot: ${STOPS[currentStop].wildlife}`, width/2, height - 14);

                // Timer bar at top (subtle when not looking)
                const timerWidth = (photoTimer / PHOTO_TIME_LIMIT) * 100;
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                pixelRect(width/2 - 55, 8, 110, 10, 'rgba(0,0,0,0.3)');
                ctx.fillStyle = 'rgba(100,200,100,0.5)';
                pixelRect(width/2 - 50, 10, timerWidth, 6, ctx.fillStyle);
            }

            // Draw binocular view effect when raised
            if (binocularLiftProgress > 0) {
                drawBinocularView();
            }
        }

        function drawBinocularView() {
            const progress = binocularLiftProgress;
            const alpha = progress;

            // ═══════════════════════════════════════════════════════════════
            // BINOCULAR VIEW - Subtle figure-8 overlay, doesn't block scene
            // ═══════════════════════════════════════════════════════════════

            const leftEyeX = focusX - 48;
            const rightEyeX = focusX + 48;
            const eyeY = focusY;
            const radius = BINOCULAR_RADIUS * (0.85 + progress * 0.15);

            // ─────────────────────────────────────────────────────────────
            // Soft edge vignette (subtle binocular feel without blocking)
            // ─────────────────────────────────────────────────────────────
            const edgeGrad = ctx.createRadialGradient(
                width/2, height/2, Math.min(width, height) * 0.3,
                width/2, height/2, Math.min(width, height) * 0.75
            );
            edgeGrad.addColorStop(0, 'rgba(0,0,0,0)');
            edgeGrad.addColorStop(0.7, 'rgba(0,0,0,0)');
            edgeGrad.addColorStop(1, `rgba(0,0,0,${alpha * 0.4})`);
            ctx.fillStyle = edgeGrad;
            ctx.fillRect(0, 0, width, height);

            // ─────────────────────────────────────────────────────────────
            // Figure-8 binocular rings (clear but not blocking)
            // ─────────────────────────────────────────────────────────────
            // Outer dark rings - thicker for visibility
            ctx.strokeStyle = `rgba(20, 20, 20, ${alpha * 0.8})`;
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.arc(leftEyeX, eyeY, radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(rightEyeX, eyeY, radius, 0, Math.PI * 2);
            ctx.stroke();

            // Inner rings (metal barrel)
            ctx.strokeStyle = `rgba(60, 60, 65, ${alpha * 0.6})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(leftEyeX, eyeY, radius - 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(rightEyeX, eyeY, radius - 5, 0, Math.PI * 2);
            ctx.stroke();

            // Blue lens coating shimmer
            ctx.strokeStyle = `rgba(80, 130, 200, ${alpha * 0.25})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(leftEyeX, eyeY, radius - 8, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(rightEyeX, eyeY, radius - 8, 0, Math.PI * 2);
            ctx.stroke();

            // ─────────────────────────────────────────────────────────────
            // Center bridge (connects the circles)
            // ─────────────────────────────────────────────────────────────
            ctx.fillStyle = `rgba(25, 25, 28, ${alpha * 0.85})`;
            const bridgeLeft = leftEyeX + radius - 6;
            const bridgeRight = rightEyeX - radius + 6;
            ctx.beginPath();
            ctx.moveTo(bridgeLeft, eyeY - 8);
            ctx.lineTo(bridgeRight, eyeY - 8);
            ctx.lineTo(bridgeRight, eyeY + 8);
            ctx.lineTo(bridgeLeft, eyeY + 8);
            ctx.closePath();
            ctx.fill();

            // Focus knob
            ctx.fillStyle = `rgba(45, 45, 50, ${alpha * 0.7})`;
            ctx.beginPath();
            ctx.ellipse(focusX, eyeY - 12, 7, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // ─────────────────────────────────────────────────────────────
            // Crosshairs (subtle red reticle)
            // ─────────────────────────────────────────────────────────────
            if (progress > 0.5) {
                const crossAlpha = (progress - 0.5) * 2;
                ctx.strokeStyle = `rgba(180, 50, 50, ${crossAlpha * 0.65})`;
                ctx.lineWidth = 1;

                // Cross with gap
                ctx.beginPath();
                ctx.moveTo(focusX - 18, focusY);
                ctx.lineTo(focusX - 5, focusY);
                ctx.moveTo(focusX + 5, focusY);
                ctx.lineTo(focusX + 18, focusY);
                ctx.moveTo(focusX, focusY - 18);
                ctx.lineTo(focusX, focusY - 5);
                ctx.moveTo(focusX, focusY + 5);
                ctx.lineTo(focusX, focusY + 18);
                ctx.stroke();

                // Center dot
                ctx.fillStyle = `rgba(180, 50, 50, ${crossAlpha * 0.5})`;
                ctx.beginPath();
                ctx.arc(focusX, focusY, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // ─────────────────────────────────────────────────────────────
            // HUD elements
            // ─────────────────────────────────────────────────────────────
            const timerWidth = (photoTimer / PHOTO_TIME_LIMIT) * 100;
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            pixelRect(width/2 - 55, 6, 110, 12, 'rgba(0,0,0,0.4)');
            ctx.fillStyle = photoTimer > 400 ? '#4CAF50' : (photoTimer > 200 ? '#FFC107' : '#FF5722');
            pixelRect(width/2 - 50, 8, timerWidth, 8, ctx.fillStyle);

            if (progress > 0.5) {
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                pixelRect(width/2 - 85, 20, 170, 16, 'rgba(0,0,0,0.4)');
                ctx.fillStyle = '#FFF';
                ctx.font = SeaRanchStyle.makeFont(10);
                ctx.textAlign = 'center';
                ctx.fillText(`Spotting: ${STOPS[currentStop].wildlife}`, width/2, 32);

                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                pixelRect(width/2 - 105, height - 22, 210, 16, 'rgba(0,0,0,0.4)');
                ctx.fillStyle = '#DDD';
                ctx.fillText('A: Log sighting · B: Lower', width/2, height - 10);
            }
        }

        function drawPhotoFlash() {
            if (photoFlashTimer > 0) {
                photoFlashTimer--;
                const progress = photoFlashTimer / 20;

                // Green "logged" pulse effect radiating from center
                ctx.strokeStyle = `rgba(100, 220, 100, ${progress * 0.8})`;
                ctx.lineWidth = 4 + (1 - progress) * 10;
                ctx.beginPath();
                ctx.arc(focusX, focusY, 30 + (1 - progress) * 80, 0, Math.PI * 2);
                ctx.stroke();

                // Secondary ring
                if (photoFlashTimer > 10) {
                    ctx.strokeStyle = `rgba(150, 255, 150, ${(photoFlashTimer - 10) / 10 * 0.5})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(focusX, focusY, 20 + (1 - progress) * 50, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Brief "SPOTTED!" text
                if (photoFlashTimer > 12) {
                    ctx.fillStyle = `rgba(100, 255, 100, ${(photoFlashTimer - 12) / 8})`;
                    ctx.font = SeaRanchStyle.makeFont(14, 'bold');
                    ctx.textAlign = 'center';
                    ctx.fillText('SPOTTED!', focusX, focusY - 60);
                }
            }
        }

        function drawTitle() {
            // HTML overlay handles the title card now
        }

        function drawDeparture() {
            // Show cyclist departing from the lodge
            departureTimer += 0.016;

            // Draw lodge background - scale from 480x320 to 640x480
            if (lodgeImage) {
                // Scale to fill 640x480, maintaining aspect ratio and cropping if needed
                const imgAspect = lodgeImage.width / lodgeImage.height; // 480/320 = 1.5
                const canvasAspect = width / height; // 640/480 = 1.33

                let drawW, drawH, drawX, drawY;
                if (imgAspect > canvasAspect) {
                    // Image is wider - fit height, crop sides
                    drawH = height;
                    drawW = height * imgAspect;
                    drawX = (width - drawW) / 2;
                    drawY = 0;
                } else {
                    // Image is taller - fit width, crop top/bottom
                    drawW = width;
                    drawH = width / imgAspect;
                    drawX = 0;
                    drawY = (height - drawH) / 2;
                }
                ctx.drawImage(lodgeImage, drawX, drawY, drawW, drawH);
            } else {
                // Fallback: draw procedural lodge scene
                drawScene1_SeaRanchLodge();
            }

            // Add a slight vignette
            const vignetteGrad = ctx.createRadialGradient(width/2, height/2, height * 0.3, width/2, height/2, height * 0.8);
            vignetteGrad.addColorStop(0, 'rgba(0,0,0,0)');
            vignetteGrad.addColorStop(1, 'rgba(0,0,0,0.3)');
            ctx.fillStyle = vignetteGrad;
            ctx.fillRect(0, 0, width, height);

            // Cyclist starts near center and rides off to the right
            // Position on the road at the bottom of the screen
            const startX = width * 0.3;
            const endX = width + 200;
            const cyclistX = startX + departureTimer * 100;
            const cyclistY = height - 30;  // On the road near bottom
            const bobAmount = Math.sin(departureTimer * 10) * 3;

            // Cyclist sprite - we want it big on screen
            const cyclistW = 234;  // 180 * 1.3
            const cyclistH = cyclistImage ? cyclistW * (cyclistImage.height / cyclistImage.width) : cyclistW * 0.55;

            if (cyclistImage && cyclistX < endX) {
                ctx.drawImage(cyclistImage, cyclistX - cyclistW/2, cyclistY - cyclistH + bobAmount, cyclistW, cyclistH);
            } else if (cyclistX < endX) {
                // Fallback cyclist - larger
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(cyclistX, cyclistY - 55 + bobAmount, 22, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillRect(cyclistX - 28, cyclistY - 30 + bobAmount, 56, 28);
                // Wheels
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(cyclistX - 24, cyclistY + bobAmount, 20, 0, Math.PI * 2);
                ctx.arc(cyclistX + 24, cyclistY + bobAmount, 20, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Text overlay
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(0, 0, width, 50);

            ctx.fillStyle = '#f5f5f0';
            ctx.font = SeaRanchStyle.makeFont(20, 'bold');
            ctx.textAlign = 'center';
            ctx.fillText('Departing Sea Ranch Lodge...', width/2, 32);

            // Auto-advance to first photo stop after cyclist exits
            if (departureTimer > 3.5) {
                gameState = 'photo';
                initPhotoMode();
            }
        }

        function drawArriving() {
            const stop = STOPS[currentStop];

            // Pixel art background - misty coastal morning
            pixelRect(0, 0, width, 100, PALETTE.skyFog);
            orderedDither(0, 100, width, 30, PALETTE.skyFog, PALETTE.skyMid, 0.4);
            pixelRect(0, 130, width, 40, PALETTE.oceanMid);
            pixelRect(0, 170, width, height - 170, PALETTE.grassMid);

            // Subtle fog effect
            for (let i = 0; i < 5; i++) {
                const fogX = (i * 120 + time * 0.1) % (width + 100) - 50;
                ctx.fillStyle = 'rgba(184, 200, 208, 0.3)';
                ctx.beginPath();
                ctx.ellipse(fogX, 140 + Math.sin(i) * 10, 80, 20, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Main wayfinding post (center) - taller, more prominent
            const postX = width / 2 - 24;
            const postHeight = 160;

            // Post shadow
            pixelRect(postX + 6, height - 60, 48, 8, 'rgba(0,0,0,0.2)');

            // Main post body - white/cream
            const postGrad = ctx.createLinearGradient(postX, 0, postX + 48, 0);
            postGrad.addColorStop(0, '#F0F0EC');
            postGrad.addColorStop(0.3, '#FFFFFF');
            postGrad.addColorStop(0.7, '#F8F8F4');
            postGrad.addColorStop(1, '#E8E8E4');
            ctx.fillStyle = postGrad;
            ctx.fillRect(postX, height - 60 - postHeight, 48, postHeight);

            // Angled top (Sea Ranch signature cut)
            ctx.fillStyle = '#E0E0DC';
            ctx.beginPath();
            ctx.moveTo(postX, height - 60 - postHeight);
            ctx.lineTo(postX + 24, height - 60 - postHeight - 20);
            ctx.lineTo(postX + 48, height - 60 - postHeight);
            ctx.fill();

            // Top edge highlight
            ctx.strokeStyle = '#D0D0CC';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(postX, height - 60 - postHeight);
            ctx.lineTo(postX + 24, height - 60 - postHeight - 20);
            ctx.lineTo(postX + 48, height - 60 - postHeight);
            ctx.stroke();

            // Location name (vertical text on post)
            ctx.save();
            ctx.translate(postX + 28, height - 80);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = '#1A1A1A';
            ctx.font = SeaRanchStyle.makeFont(12, 'bold');
            ctx.textAlign = 'center';
            ctx.letterSpacing = '3px';
            ctx.fillText(stop.name.toUpperCase(), 0, 0);
            ctx.restore();

            // Secondary wayfinding posts on sides
            drawWayfindingPost(60, height - 40, 80, 'MILE ' + stop.mile);
            drawWayfindingPost(370, height - 45, 75, 'PHOTO');

            // Info panel at bottom
            pixelRect(0, height - 50, width, 50, 'rgba(0,0,0,0.6)');

            // Arriving text
            ctx.fillStyle = PALETTE.superCream;
            ctx.font = SeaRanchStyle.makeFont(12, 'bold');
            ctx.textAlign = 'center';
            ctx.fillText('Arriving at...', width / 2, height - 32);

            // Description
            ctx.font = SeaRanchStyle.makeFont(10);
            ctx.fillStyle = PALETTE.uiText;
            ctx.fillText(stop.description, width / 2, height - 15);

            // Wildlife hint
            ctx.fillStyle = PALETTE.superRed;
            ctx.font = SeaRanchStyle.makeFont(10, 'bold');
            ctx.fillText(`Look for: ${stop.wildlife}`, width / 2, 40);
        }

        // Fun facts about each animal species
        const WILDLIFE_FACTS = [
            "Bobs its tail constantly while perched—a behavior unique among flycatchers!",
            "Can spot a mouse from 100 feet in the air. Mates for life.",
            "Males do \"push-ups\" to show off their bright blue belly patches!",
            "Wings beat 80 times per second. Only bird that can fly backwards.",
            "Stores thousands of acorns in \"granary trees\" for winter.",
            "Uses its bright orange bill to pry open mussels and limpets.",
            "Migrates up to 3,000 miles from Mexico to Canada each year.",
            "Toxic skin protects it from predators—don't lick the newt!",
            "Stands motionless for hours, then strikes fish in 1/20th of a second.",
            "Can hold breath for 30 minutes. Pups can swim at birth!"
        ];

        // Scientific names for field guide authenticity
        const WILDLIFE_LATIN = [
            "Sayornis nigricans",
            "Buteo jamaicensis",
            "Sceloporus occidentalis",
            "Calypte anna",
            "Melanerpes formicivorus",
            "Haematopus bachmani",
            "Danaus plexippus",
            "Taricha granulosa",
            "Ardea herodias",
            "Phoca vitulina"
        ];

        // Habitat types for each stop (matches STOPS habitatType)
        const HABITAT_LABELS = {
            meadow: "COASTAL MEADOW",
            coastal: "COASTAL BLUFF",
            woodland: "CYPRESS GROVE",
            garden: "NATIVE GARDEN",
            forest: "REDWOOD FOREST",
            estuary: "RIVER ESTUARY",
            beach: "DRIFTWOOD BEACH"
        };

        // Show HTML results card overlay
        function showResultsCard() {
            console.log('showResultsCard called, currentStop:', currentStop, 'photoScore:', photoScore);

            // Validate currentStop
            if (currentStop < 0 || currentStop >= STOPS.length) {
                console.error('Invalid currentStop:', currentStop);
                return;
            }

            try {
            const resultsCard = document.getElementById('results-card');
            if (!resultsCard) {
                console.error('Results card element not found!');
                return;
            }
            const stop = STOPS[currentStop];
            if (!stop) {
                console.error('Stop not found for index:', currentStop);
                return;
            }

            // Update text content
            document.getElementById('results-stop').textContent = `STOP ${currentStop + 1} OF ${STOPS.length}`;
            document.getElementById('results-location').textContent = stop.name.toUpperCase();
            document.getElementById('results-wildlife').textContent = stop.wildlife;

            // Update habitat tag
            const habitatEl = document.getElementById('results-habitat');
            habitatEl.textContent = HABITAT_LABELS[stop.habitatType] || stop.habitatType.toUpperCase();

            // Update scientific name (only show if sighting was successful)
            const latinEl = document.getElementById('results-latin');
            if (photoScore > 0) {
                latinEl.textContent = WILDLIFE_LATIN[currentStop];
                latinEl.style.display = 'block';
            } else {
                latinEl.textContent = '???';
                latinEl.style.display = 'block';
            }

            // Update fact or missed message
            const factEl = document.getElementById('results-fact');
            if (photoScore > 0) {
                factEl.textContent = WILDLIFE_FACTS[currentStop];
            } else {
                factEl.textContent = 'Moved too quickly to observe. Try again next time!';
            }

            // Update quality badge
            const qualityEl = document.getElementById('results-quality');
            const messages = ['MISSED', 'GLIMPSE', 'GOOD SIGHTING', 'EXCELLENT'];
            const classes = ['missed', 'glimpse', 'good', 'excellent'];
            qualityEl.textContent = messages[photoScore];
            qualityEl.className = 'quality-badge ' + classes[photoScore];

            // Update rating dots
            const dotsEl = document.getElementById('results-dots');
            while (dotsEl.firstChild) {
                dotsEl.removeChild(dotsEl.firstChild);
            }
            for (let i = 0; i < 3; i++) {
                const dot = document.createElement('div');
                dot.className = 'rating-dot';
                if (i < photoScore) {
                    dot.classList.add('filled', classes[photoScore]);
                }
                dotsEl.appendChild(dot);
            }

            // Create wildlife icon canvas
            const iconEl = document.getElementById('results-icon');
            while (iconEl.firstChild) {
                iconEl.removeChild(iconEl.firstChild);
            }

            const iconCanvas = document.createElement('canvas');
            iconCanvas.width = 120;
            iconCanvas.height = 80;
            iconCanvas.style.width = '120px';
            iconCanvas.style.height = '80px';
            const iconCtx = iconCanvas.getContext('2d');

            if (photoScore > 0) {
                // Draw the wildlife sprite - use a temporary canvas to avoid ctx conflicts
                iconCtx.save();
                iconCtx.translate(60, 45);
                // Store original ctx and temporarily swap for wildlife drawing
                const originalCtx = ctx;
                ctx = iconCtx;
                try {
                    const drawFuncs = [
                        drawChunkyBlackPhoebe, drawChunkyHawk, drawChunkyLizard, drawChunkyHummingbird,
                        drawChunkyWoodpecker, drawChunkyOystercatcher, drawChunkyMonarch, drawChunkyNewt,
                        drawChunkyHeron, drawChunkySeal
                    ];
                    if (drawFuncs[currentStop]) {
                        drawFuncs[currentStop](0, 0, true);
                    }
                } catch (e) {
                    console.error('Error drawing wildlife icon:', e);
                }
                // ALWAYS restore ctx immediately
                ctx = originalCtx;
                iconCtx.restore();
            } else {
                // Question mark if missed
                iconCtx.fillStyle = 'rgba(139, 115, 85, 0.3)';
                iconCtx.font = "bold 48px 'Helvetica Neue', Helvetica, Arial, sans-serif";
                iconCtx.textAlign = 'center';
                iconCtx.fillText('?', 60, 55);
            }

            iconEl.appendChild(iconCanvas);
            resultsCard.classList.add('visible');
            console.log('Results card should now be visible');
            } catch (e) {
                console.error('Error in showResultsCard:', e);
            }
        }

        function drawResults() {
            // Fallback canvas rendering while HTML overlay loads
            const stop = STOPS[currentStop];

            // Sea Ranch style background
            const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
            bgGrad.addColorStop(0, '#e8e4dc');
            bgGrad.addColorStop(1, '#d4c4a8');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, width, height);

            // Card container
            const cardX = width / 2 - 190;
            const cardY = 40;
            const cardW = 380;
            const cardH = 360;

            // Card shadow and background
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(cardX + 4, cardY + 4, cardW, cardH);
            ctx.fillStyle = '#f5f5f0';
            ctx.fillRect(cardX, cardY, cardW, cardH);
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 3;
            ctx.strokeRect(cardX, cardY, cardW, cardH);

            // Header bar
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(cardX, cardY, cardW, 40);
            ctx.fillStyle = '#f5f5f0';
            ctx.font = SeaRanchStyle.makeFont(11, 'bold');
            ctx.textAlign = 'left';
            ctx.fillText(`STOP ${currentStop + 1} OF ${STOPS.length}`, cardX + 15, cardY + 26);
            ctx.textAlign = 'right';
            ctx.fillText(stop.name.toUpperCase(), cardX + cardW - 15, cardY + 26);

            // Wildlife area
            const illustrationY = cardY + 55;
            ctx.fillStyle = 'rgba(43, 90, 138, 0.08)';
            ctx.fillRect(cardX + 20, illustrationY, cardW - 40, 100);

            // Draw wildlife sprite
            if (photoScore > 0) {
                const spriteX = cardX + cardW / 2;
                const spriteY = illustrationY + 55;
                const drawFuncs = [
                    drawChunkyBlackPhoebe, drawChunkyHawk, drawChunkyLizard, drawChunkyHummingbird,
                    drawChunkyWoodpecker, drawChunkyOystercatcher, drawChunkyMonarch, drawChunkyNewt,
                    drawChunkyHeron, drawChunkySeal
                ];
                if (drawFuncs[currentStop]) drawFuncs[currentStop](spriteX, spriteY, true);
            } else {
                ctx.fillStyle = 'rgba(139, 115, 85, 0.3)';
                ctx.font = SeaRanchStyle.makeFont(48, 'bold');
                ctx.textAlign = 'center';
                ctx.fillText('?', cardX + cardW / 2, illustrationY + 65);
            }

            // Species name
            ctx.fillStyle = '#1a1a1a';
            ctx.font = SeaRanchStyle.makeFont(24, 'bold');
            ctx.textAlign = 'center';
            ctx.fillText(stop.wildlife, cardX + cardW / 2, illustrationY + 135);

            // Divider
            ctx.strokeStyle = '#8b7355';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(cardX + 40, illustrationY + 150);
            ctx.lineTo(cardX + cardW - 40, illustrationY + 150);
            ctx.stroke();

            // Fun fact
            ctx.font = SeaRanchStyle.makeFont(14);
            ctx.fillStyle = '#5a5a5a';
            const fact = photoScore > 0 ? WILDLIFE_FACTS[currentStop] : 'Moved too quickly to observe.';
            const words = fact.split(' ');
            let line = '';
            let lineY = illustrationY + 175;
            for (const word of words) {
                const testLine = line + word + ' ';
                if (ctx.measureText(testLine).width > cardW - 60 && line !== '') {
                    ctx.fillText(line.trim(), cardX + cardW / 2, lineY);
                    line = word + ' ';
                    lineY += 22;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line.trim(), cardX + cardW / 2, lineY);

            // Quality badge
            const messages = ['MISSED', 'GLIMPSE', 'GOOD SIGHTING', 'EXCELLENT'];
            const colors = ['#C41E3A', '#8b7355', '#2E5DA8', '#2a6a4a'];
            ctx.fillStyle = colors[photoScore];
            ctx.font = SeaRanchStyle.makeFont(12, 'bold');
            ctx.fillText(messages[photoScore], cardX + cardW / 2, cardY + cardH - 55);

            // Rating dots
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(cardX + cardW / 2 - 20 + i * 20, cardY + cardH - 35, 6, 0, Math.PI * 2);
                if (i < photoScore) {
                    ctx.fillStyle = colors[photoScore];
                    ctx.fill();
                } else {
                    ctx.strokeStyle = '#ccc';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            // Controls
            ctx.fillStyle = '#8b7355';
            ctx.font = SeaRanchStyle.makeFont(12);
            ctx.fillText('A: CONTINUE', width / 2, height - 25);
            ctx.fillStyle = '#C41E3A';
            ctx.fillText('B: MENU', width / 2, height - 10);
        }

        // Show HTML complete card overlay
        function showCompleteCard() {
            const completeCard = document.getElementById('complete-card');
            const speciesGrid = document.getElementById('species-grid');

            // Species data for the grid
            const speciesNames = [
                'Black Phoebe', 'Red-tailed Hawk', 'Fence Lizard', 'Hummingbird', 'Woodpecker',
                'Oystercatcher', 'Monarch', 'Newt', 'Blue Heron', 'Harbor Seal'
            ];

            // Clear existing children
            while (speciesGrid.firstChild) {
                speciesGrid.removeChild(speciesGrid.firstChild);
            }

            const speciesDrawFuncs = [
                drawChunkyBlackPhoebe, drawChunkyHawk, drawChunkyLizard, drawChunkyHummingbird,
                drawChunkyWoodpecker, drawChunkyOystercatcher, drawChunkyMonarch, drawChunkyNewt,
                drawChunkyHeron, drawChunkySeal
            ];

            speciesNames.forEach((name, i) => {
                const item = document.createElement('div');
                item.className = 'species-item';

                // Create mini canvas for the icon
                const iconCanvas = document.createElement('canvas');
                iconCanvas.width = 80;
                iconCanvas.height = 60;
                iconCanvas.style.width = '60px';
                iconCanvas.style.height = '45px';
                const iconCtx = iconCanvas.getContext('2d');

                // Draw the species on the mini canvas
                iconCtx.save();
                iconCtx.translate(40, 35);
                iconCtx.scale(0.6, 0.6);
                // Temporarily use the mini canvas context
                const mainCtx = ctx;
                try {
                    ctx = iconCtx;
                    speciesDrawFuncs[i](0, 0, true);
                } finally {
                    ctx = mainCtx;
                }
                iconCtx.restore();

                const iconDiv = document.createElement('div');
                iconDiv.className = 'species-icon';
                iconDiv.appendChild(iconCanvas);

                const check = document.createElement('div');
                check.className = 'species-check';

                const nameDiv = document.createElement('div');
                nameDiv.className = 'species-name';
                nameDiv.textContent = name;

                item.appendChild(iconDiv);
                item.appendChild(check);
                item.appendChild(nameDiv);
                speciesGrid.appendChild(item);
            });

            completeCard.classList.add('visible');
        }

        function drawComplete() {
            // Sea Ranch style background
            const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
            bgGrad.addColorStop(0, '#e8e4dc');
            bgGrad.addColorStop(1, '#d4c4a8');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, width, height);

            // Wood grain texture
            ctx.strokeStyle = 'rgba(139, 115, 85, 0.08)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 25; i++) {
                const y = i * 20 + Math.sin(i * 0.5) * 5;
                ctx.beginPath();
                ctx.moveTo(0, y);
                for (let x = 0; x < width; x += 20) {
                    ctx.lineTo(x, y + Math.sin(x * 0.02 + i) * 3);
                }
                ctx.stroke();
            }

            // Blue supergraphic curves
            ctx.strokeStyle = '#2E5DA8';
            ctx.lineWidth = 28;
            ctx.beginPath();
            ctx.arc(width + 60, -80, 280, Math.PI * 0.5, Math.PI);
            ctx.stroke();
            ctx.lineWidth = 14;
            ctx.beginPath();
            ctx.arc(width + 40, -60, 220, Math.PI * 0.5, Math.PI);
            ctx.stroke();

            // Title
            ctx.fillStyle = '#1a1a1a';
            ctx.font = SeaRanchStyle.makeFont(32, 'bold');
            ctx.textAlign = 'center';
            ctx.fillText('TRAIL COMPLETE', width / 2, 50);

            ctx.font = SeaRanchStyle.makeFont(14);
            ctx.fillStyle = '#8b7355';
            ctx.fillText('Bluff Trail \u2022 Sea Ranch, CA', width / 2, 75);

            // Species card
            const cardX = 30;
            const cardY = 95;
            const cardW = width - 60;
            const cardH = 300;

            // Card shadow and background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(cardX + 4, cardY + 4, cardW, cardH);
            ctx.fillStyle = '#f5f5f0';
            ctx.fillRect(cardX, cardY, cardW, cardH);

            // Card header
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(cardX, cardY, cardW, 32);
            ctx.fillStyle = '#ffffff';
            ctx.font = SeaRanchStyle.makeFont(11, 'bold');
            ctx.fillText('SPECIES OBSERVED', width / 2, cardY + 21);

            // Species grid
            const speciesData = [
                { name: 'Black Phoebe', draw: drawChunkyBlackPhoebe },
                { name: 'Red-tailed Hawk', draw: drawChunkyHawk },
                { name: 'Fence Lizard', draw: drawChunkyLizard },
                { name: 'Hummingbird', draw: drawChunkyHummingbird },
                { name: 'Woodpecker', draw: drawChunkyWoodpecker },
                { name: 'Oystercatcher', draw: drawChunkyOystercatcher },
                { name: 'Monarch', draw: drawChunkyMonarch },
                { name: 'Newt', draw: drawChunkyNewt },
                { name: 'Blue Heron', draw: drawChunkyHeron },
                { name: 'Harbor Seal', draw: drawChunkySeal }
            ];

            ctx.font = SeaRanchStyle.makeFont(9);
            for (let i = 0; i < speciesData.length; i++) {
                const col = i % 5;
                const row = Math.floor(i / 5);
                const cellX = cardX + 30 + col * 112;
                const cellY = cardY + 50 + row * 125;

                // Draw wildlife sprite
                ctx.save();
                ctx.translate(cellX + 28, cellY + 30);
                ctx.scale(0.55, 0.55);
                speciesData[i].draw(0, 0, true);
                ctx.restore();

                // Species name
                ctx.fillStyle = '#1a1a1a';
                ctx.textAlign = 'center';
                ctx.fillText(speciesData[i].name, cellX + 28, cellY + 70);

                // Green check
                ctx.beginPath();
                ctx.arc(cellX + 52, cellY + 8, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#7A9B6D';
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(cellX + 49, cellY + 8);
                ctx.lineTo(cellX + 52, cellY + 11);
                ctx.lineTo(cellX + 56, cellY + 5);
                ctx.stroke();
            }

            // Red accent at bottom of card
            ctx.fillStyle = '#C41E3A';
            ctx.fillRect(cardX, cardY + cardH - 4, cardW, 4);

            // Controls
            ctx.font = SeaRanchStyle.makeFont(12);
            ctx.textAlign = 'center';
            ctx.fillStyle = '#8b7355';
            ctx.fillText('A: REPLAY', width / 2 - 60, height - 45);
            ctx.fillStyle = '#C41E3A';
            ctx.fillText('B: MENU', width / 2 + 60, height - 45);

            // Success message
            ctx.fillStyle = '#7A9B6D';
            ctx.font = SeaRanchStyle.makeFont(14, 'bold');
            ctx.fillText('All species documented!', width / 2, height - 20);
        }

        function gameLoop() {
            update();

            // Clear
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);

            // Apply juice effects
            ctx.save();
            SeaRanchStyle.applyShake(ctx);

            if (gameState === 'title') {
                drawTitle();
            } else if (gameState === 'departure') {
                drawDeparture();
            } else if (gameState === 'biking') {
                drawBikingCutscene();
            } else if (gameState === 'photo') {
                // Try to draw static background image first
                const hasStaticBg = drawSceneBackground(currentStop);

                // If no static image, fall back to procedural scene
                if (!hasStaticBg) {
                    switch (currentStop) {
                        case 0: drawScene1_SeaRanchLodge(); break;
                        case 1: drawScene2_Airstrip(); break;
                        case 2: drawScene3_OhlsonRecCenter(); break;
                        case 3: drawScene4_SeaRanchChapel(); break;
                        case 4: drawScene5_OneEyedJacks(); break;
                        case 5: drawScene6_WalkOnBeach(); break;
                        case 6: drawScene7_DelMarRecCenter(); break;
                        case 7: drawScene8_SalalTrailWaterfall(); break;
                        case 8: drawScene9_GualalaPointPark(); break;
                        case 9: drawScene10_DriftwoodBeach(); break;
                        default: drawScene1_SeaRanchLodge();
                    }
                }

                // Draw flora overlay on top of background (chunky style)
                drawSceneFloraOverlay(currentStop);

                // Draw animated wildlife on top (chunky pixel art style)
                switch (currentStop) {
                    case 0: if (wildlife.visible) drawChunkyBlackPhoebe(wildlife.x, wildlife.y); break;
                    case 1: if (wildlife.visible) drawChunkyHawk(wildlife.x, wildlife.y); break;
                    case 2: if (wildlife.visible) drawChunkyLizard(wildlife.x, wildlife.y); break;
                    case 3: if (wildlife.visible) drawChunkyHummingbird(wildlife.x, wildlife.y); break;
                    case 4: if (wildlife.visible) drawChunkyWoodpecker(wildlife.x, wildlife.y); break;
                    case 5: if (wildlife.visible) drawChunkyOystercatcher(wildlife.x, wildlife.y); break;
                    case 6: if (wildlife.visible) drawChunkyMonarch(wildlife.x, wildlife.y); break;
                    case 7: if (wildlife.visible) drawChunkyNewt(wildlife.x, wildlife.y); break;
                    case 8: if (wildlife.visible) drawChunkyHeron(wildlife.x, wildlife.y); break;
                    case 9: if (wildlife.visible) drawChunkySeal(wildlife.x, wildlife.y); break;
                    default:
                }

                drawViewfinder();
                drawPhotoFlash();
            } else if (gameState === 'results') {
                // Don't draw canvas results - HTML overlay handles this
                // Just draw a simple background so canvas isn't blank
                const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
                bgGrad.addColorStop(0, '#e8e4dc');
                bgGrad.addColorStop(1, '#d4c4a8');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, width, height);
            } else if (gameState === 'complete') {
                // Don't draw canvas complete - HTML overlay handles this
                const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
                bgGrad.addColorStop(0, '#e8e4dc');
                bgGrad.addColorStop(1, '#d4c4a8');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, width, height);
            }

            // Update juice effects and restore context
            SeaRanchStyle.updateJuice(ctx);
            ctx.restore();

            // Apply weathered film grain effect for consistent Sea Ranch aesthetic
            if (gameState !== 'title') {
                SeaRanchStyle.applyWeatheredEffect(ctx, { grainOpacity: 0.06, vignetteIntensity: 0.15 });
            }

            requestAnimationFrame(gameLoop);
        }

        // Start the game
        SeaRanchStyle.setupTouchControls();
        gameLoop();
    </script>
</body>
</html>
