<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sea Ranch Quest - Level 7: Paddle Ball</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        #gameContainer {
            position: relative;
            width: 640px;
            height: 480px;
            max-width: 100vw;
            max-height: 100vh;
        }
        #gameCanvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #touchControls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: none;
        }
        .touchBtn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.4);
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
        }
        .touchBtn:active {
            background: rgba(255,255,255,0.4);
        }
        .dpad {
            display: flex;
            gap: 10px;
        }
        #backBtn {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            z-index: 100;
        }
        /* Controls always visible */
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="640" height="480"></canvas>
        <button id="backBtn" onclick="window.location.href='index.html'">Back</button>
        <div id="touchControls">
            <div class="dpad">
                <button class="touchBtn" id="leftBtn">&larr;</button>
                <button class="touchBtn" id="rightBtn">&rarr;</button>
            </div>
            <button class="touchBtn" id="actionBtn">A</button>
        </div>
    </div>

    <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const W = 640, H = 480;

    // Game state
    let gameState = "title";
    let playerScore = 0;
    let raccoonScore = 0;
    let servingTeam = "player";
    let rallyCount = 0;
    let time = 0;
    let raccoonServeTimer = 0;

    // Court dimensions
    const COURT = {
        nearY: 458,
        farY: 248,
        leftX: 93,
        rightX: 547,
        kitchenNear: 368,
        kitchenFar: 293,
        netY: 330,
        centerX: 320
    };

    // Players
    let dad = {
        x: 213, y: 420, targetX: 213, targetY: 420,
        width: 43, height: 72,
        swingFrame: 0, name: "Dad"
    };

    let kid = {
        x: 427, y: 420, targetX: 427, targetY: 420,
        width: 35, height: 60,
        swingFrame: 0, name: "Kid"
    };

    // Raccoons
    let raccoon1 = {
        x: 240, y: 270, targetX: 240, targetY: 270,
        width: 37, height: 51,
        swingFrame: 0, name: "Rocky"
    };

    let raccoon2 = {
        x: 400, y: 270, targetX: 400, targetY: 270,
        width: 37, height: 51,
        swingFrame: 0, name: "Ricky"
    };

    // Ball
    let ball = {
        x: 320, y: 375, z: 0,
        vx: 0, vy: 0,
        radius: 11,
        inPlay: false,
        lastHitBy: null,
        speed: 2.0
    };

    // Visual feedback
    let hitFlash = 0;
    let shakeAmount = 0;
    let shakeX = 0, shakeY = 0;
    let sparkles = [];

    // Input state
    const keys = {};
    const justPressed = {};
    let touchLeft = false, touchRight = false, touchAction = false;

    // Input handling
    document.addEventListener('keydown', (e) => {
        if (!keys[e.code]) justPressed[e.code] = true;
        keys[e.code] = true;
        e.preventDefault();
    });
    document.addEventListener('keyup', (e) => {
        keys[e.code] = false;
    });

    // Touch and mouse controls
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const actionBtn = document.getElementById('actionBtn');

    // Left button
    leftBtn.addEventListener('touchstart', (e) => { touchLeft = true; e.preventDefault(); });
    leftBtn.addEventListener('touchend', () => { touchLeft = false; });
    leftBtn.addEventListener('mousedown', (e) => { touchLeft = true; e.preventDefault(); });
    leftBtn.addEventListener('mouseup', () => { touchLeft = false; });
    leftBtn.addEventListener('mouseleave', () => { touchLeft = false; });

    // Right button
    rightBtn.addEventListener('touchstart', (e) => { touchRight = true; e.preventDefault(); });
    rightBtn.addEventListener('touchend', () => { touchRight = false; });
    rightBtn.addEventListener('mousedown', (e) => { touchRight = true; e.preventDefault(); });
    rightBtn.addEventListener('mouseup', () => { touchRight = false; });
    rightBtn.addEventListener('mouseleave', () => { touchRight = false; });

    // Action button
    actionBtn.addEventListener('touchstart', (e) => {
        touchAction = true;
        justPressed['touchA'] = true;
        e.preventDefault();
    });
    actionBtn.addEventListener('touchend', () => { touchAction = false; });
    actionBtn.addEventListener('mousedown', (e) => {
        touchAction = true;
        justPressed['touchA'] = true;
        e.preventDefault();
    });
    actionBtn.addEventListener('mouseup', () => { touchAction = false; });
    actionBtn.addEventListener('mouseleave', () => { touchAction = false; });

    // Canvas touch/click for title/gameover
    canvas.addEventListener('touchstart', (e) => {
        if (gameState === 'title' || gameState === 'gameover') {
            justPressed['touchA'] = true;
        }
        e.preventDefault();
    });
    canvas.addEventListener('click', () => {
        if (gameState === 'title' || gameState === 'gameover') {
            justPressed['touchA'] = true;
        }
    });

    function isDown(key) {
        if (key === 'left') return keys['ArrowLeft'] || keys['KeyA'] || touchLeft;
        if (key === 'right') return keys['ArrowRight'] || keys['KeyD'] || touchRight;
        if (key === 'a') return keys['Space'] || keys['Enter'] || keys['KeyZ'] || touchAction;
        if (key === 'b') return keys['Escape'] || keys['KeyX'];
        return false;
    }

    function wasJustPressed(key) {
        if (key === 'a') return justPressed['Space'] || justPressed['Enter'] || justPressed['KeyZ'] || justPressed['touchA'];
        if (key === 'b') return justPressed['Escape'] || justPressed['KeyX'];
        return false;
    }

    // Drawing helpers
    function setColor(r, g, b, a = 1) {
        ctx.fillStyle = `rgba(${Math.floor(r*255)},${Math.floor(g*255)},${Math.floor(b*255)},${a})`;
        ctx.strokeStyle = ctx.fillStyle;
    }

    function drawEllipse(x, y, rx, ry) {
        ctx.beginPath();
        ctx.ellipse(x, y, rx, ry, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    function drawCircle(x, y, r) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
    }

    function drawRect(x, y, w, h) {
        ctx.fillRect(x, y, w, h);
    }

    function drawLine(x1, y1, x2, y2) {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }

    function drawPolygon(points) {
        ctx.beginPath();
        ctx.moveTo(points[0], points[1]);
        for (let i = 2; i < points.length; i += 2) {
            ctx.lineTo(points[i], points[i + 1]);
        }
        ctx.closePath();
        ctx.fill();
    }

    function drawArc(x, y, r, start, end) {
        ctx.beginPath();
        ctx.arc(x, y, r, start, end);
        ctx.fill();
    }

    function drawArcLine(x, y, r, start, end) {
        ctx.beginPath();
        ctx.arc(x, y, r, start, end);
        ctx.stroke();
    }

    // Drawing functions
    function drawClouds() {
        setColor(0.96, 0.96, 0.94);
        drawEllipse(100, 40, 80, 20);
        drawEllipse(160, 35, 60, 15);
        drawEllipse(500, 45, 90, 22);
        drawEllipse(550, 38, 50, 14);

        setColor(0.83, 0.77, 0.66, 0.6);
        drawEllipse(130, 55, 100, 25);
        drawEllipse(400, 60, 120, 28);
    }

    function drawCypressTrees() {
        const trees = [
            {x: 40, size: 0.7, lean: -0.15},
            {x: 113, size: 0.9, lean: 0.1},
            {x: 527, size: 0.85, lean: 0.12},
            {x: 600, size: 0.65, lean: 0.18}
        ];

        for (const tree of trees) {
            const baseY = 143;
            const height = 45 * tree.size;
            const width = 55 * tree.size;

            // Trunk
            setColor(0.23, 0.16, 0.1);
            drawPolygon([
                tree.x - 2, baseY,
                tree.x + tree.lean * 12, baseY - height * 0.6,
                tree.x + tree.lean * 12 + 3, baseY - height * 0.6,
                tree.x + 2, baseY
            ]);

            // Foliage
            setColor(0.18, 0.29, 0.23);
            const foliageX = tree.x + tree.lean * 15;
            const foliageY = baseY - height * 0.7;
            drawEllipse(foliageX, foliageY, width/2 + tree.lean * 8, 15);
        }
    }

    function drawRecCenter() {
        const bldgX = 440;
        const bldgY = 75;

        // Side face
        setColor(0.29, 0.23, 0.16);
        drawPolygon([
            bldgX + 53, bldgY,
            bldgX + 87, bldgY - 18,
            bldgX + 87, bldgY + 75,
            bldgX + 53, bldgY + 98
        ]);

        // Front face
        setColor(0.36, 0.29, 0.23);
        drawRect(bldgX, bldgY, 53, 98);

        // Planks
        setColor(0.29, 0.23, 0.16, 0.4);
        ctx.lineWidth = 1;
        for (let i = 0; i <= 53; i += 8) {
            drawLine(bldgX + i, bldgY, bldgX + i, bldgY + 98);
        }

        // Window with red arrow
        const winX = bldgX + 8;
        const winY = bldgY + 15;
        const winW = 37;
        const winH = 60;

        setColor(0.96, 0.94, 0.91);
        drawRect(winX, winY, winW, winH);

        // Red arrow
        setColor(0.77, 0.12, 0.23);
        ctx.save();
        ctx.translate(winX + winW/2, winY + winH/2);
        ctx.rotate(-Math.PI/4);
        drawRect(-18, -3.5, 30, 7);
        drawPolygon([10, -10, 18, 0, 10, 10]);
        ctx.restore();

        setColor(0.23, 0.16, 0.1);
        ctx.lineWidth = 2;
        ctx.strokeRect(winX, winY, winW, winH);

        // Roof
        setColor(0.23, 0.16, 0.1);
        drawPolygon([
            bldgX - 5, bldgY - 3,
            bldgX + 59, bldgY - 3,
            bldgX + 91, bldgY - 21,
            bldgX + 91, bldgY - 15,
            bldgX + 59, bldgY + 3,
            bldgX - 5, bldgY + 3
        ]);

        // Pool area
        const poolX = 233;
        const poolY = 138;
        const poolW = 60;
        const poolH = 30;

        // Concrete deck
        setColor(0.78, 0.75, 0.72);
        drawRect(poolX - 11, poolY - 9, poolW + 40, poolH + 21);

        // Deck shadow
        setColor(0.42, 0.38, 0.34);
        drawRect(poolX - 11, poolY - 9, poolW + 40, 4);

        // Pool coping
        setColor(0.91, 0.88, 0.85);
        drawRect(poolX - 2, poolY - 2, poolW + 4, 2);
        drawRect(poolX - 2, poolY + poolH, poolW + 4, 2);
        drawRect(poolX - 2, poolY, 2, poolH);
        drawRect(poolX + poolW, poolY, 2, poolH);

        // Pool water
        setColor(0.23, 0.44, 0.56);
        drawRect(poolX, poolY, poolW, poolH);

        // Water shimmer
        setColor(1, 1, 1, 0.15);
        const poolTime = time * 0.002;
        for (let i = 0; i <= 4; i++) {
            const rx = poolX + 5 + Math.sin(poolTime + i * 1.3) * 8 + i * 10;
            const ry = poolY + 5 + Math.cos(poolTime * 0.7 + i) * 4 + (i % 2) * 8;
            drawEllipse(rx, ry, 8 + Math.sin(poolTime + i) * 3, 2);
        }

        // Lane line
        setColor(1, 1, 1, 0.2);
        ctx.lineWidth = 1;
        drawLine(poolX + poolW/2, poolY + 3, poolX + poolW/2, poolY + poolH - 3);

        // Wooden planter
        setColor(0.35, 0.29, 0.23);
        drawRect(poolX - 30, poolY + 5, 18, 22);

        // Lounge chairs
        setColor(0.54, 0.48, 0.42);
        drawRect(poolX + poolW + 8, poolY + 8, 8, 14);
        drawRect(poolX + poolW + 18, poolY + 8, 8, 14);
    }

    function drawStairs() {
        const stairsStartX = 373;
        const stairsStartY = 210;
        const stairsEndX = 353;
        const stairsEndY = 150;

        for (let i = 0; i <= 9; i++) {
            const t = i / 9;
            const y = stairsStartY - t * (stairsStartY - stairsEndY);
            const x = stairsStartX - t * (stairsStartX - stairsEndX);
            const w = 40 - t * 13;

            // Shadow
            setColor(0, 0, 0, 0.4);
            drawRect(x, y + 5, w, 4);

            // Plank
            setColor(0.42, 0.35, 0.29);
            drawRect(x, y, w, 6);

            // Highlight
            setColor(0.54, 0.48, 0.42);
            drawRect(x + 1, y, w - 2, 2);
        }

        // Railing
        setColor(0.35, 0.29, 0.23);
        ctx.lineWidth = 3;
        drawLine(stairsStartX + 37, stairsStartY, stairsEndX + 27, stairsEndY);
    }

    function drawBerms() {
        // Far berm shadow
        setColor(0.35, 0.48, 0.36);
        drawPolygon([80, 240, 560, 240, 553, 248, 87, 248]);

        // Far berm
        setColor(0.48, 0.61, 0.43);
        drawPolygon([0, 150, 640, 150, 560, 240, 80, 240, 0, 195]);

        // Far berm highlight
        setColor(0.54, 0.67, 0.49);
        drawPolygon([107, 162, 533, 159, 527, 173, 113, 174]);

        // Left berm
        setColor(0.48, 0.61, 0.43);
        drawPolygon([0, 195, 80, 240, 80, 462, 0, 480]);

        // Right berm
        setColor(0.48, 0.61, 0.43);
        drawPolygon([640, 150, 560, 240, 560, 462, 640, 480]);

        // Near berm
        setColor(0.48, 0.61, 0.43);
        drawPolygon([80, 462, 560, 462, 640, 480, 0, 480]);

        // Grass blades
        setColor(0.35, 0.48, 0.36);
        ctx.lineWidth = 1;
        const grassSeeds = [
            {x: 27, y: 263}, {x: 40, y: 308}, {x: 33, y: 353},
            {x: 580, y: 263}, {x: 593, y: 308}, {x: 607, y: 353},
            {x: 133, y: 210}, {x: 240, y: 218}, {x: 347, y: 213},
            {x: 160, y: 471}, {x: 267, y: 474}, {x: 373, y: 471}
        ];
        for (const seed of grassSeeds) {
            drawLine(seed.x, seed.y, seed.x + 1, seed.y - 6);
        }
    }

    function drawBackground() {
        // Sky gradient
        for (let y = 0; y <= 180; y += 4) {
            const t = y / 180;
            setColor(0.65 - t*0.1, 0.81 - t*0.1, 0.92 - t*0.05);
            drawRect(0, y, W, 4);
        }

        drawClouds();
        drawCypressTrees();
        drawRecCenter();
        drawBerms();
        drawStairs();
    }

    function drawCourt() {
        const perspOffset = 8;

        // Court surface
        setColor(0.35, 0.48, 0.36);
        drawPolygon([
            COURT.leftX, COURT.nearY,
            COURT.rightX, COURT.nearY,
            COURT.rightX - perspOffset, COURT.farY,
            COURT.leftX + perspOffset, COURT.farY
        ]);

        // Court texture
        setColor(0.29, 0.42, 0.30);
        for (let i = 0; i <= 7; i++) {
            const y = COURT.farY + (COURT.nearY - COURT.farY) * (i / 8);
            const xOffset = perspOffset * (1 - i / 8);
            drawRect(COURT.leftX + xOffset + 5, y, 3, 1);
            drawRect(COURT.rightX - xOffset - 8, y + 5, 3, 1);
        }

        // Lines
        setColor(0.96, 0.96, 0.94);
        ctx.lineWidth = 2;

        // Baselines
        drawLine(COURT.leftX, COURT.nearY, COURT.rightX, COURT.nearY);
        drawLine(COURT.leftX + perspOffset, COURT.farY, COURT.rightX - perspOffset, COURT.farY);

        // Sidelines
        drawLine(COURT.leftX, COURT.nearY, COURT.leftX + perspOffset, COURT.farY);
        drawLine(COURT.rightX, COURT.nearY, COURT.rightX - perspOffset, COURT.farY);

        // Center line
        drawLine(COURT.centerX, COURT.nearY, COURT.centerX, COURT.farY);

        // Kitchen lines (dashed)
        const kitchenNearOffset = perspOffset * ((COURT.nearY - COURT.kitchenNear) / (COURT.nearY - COURT.farY));
        const kitchenFarOffset = perspOffset * ((COURT.nearY - COURT.kitchenFar) / (COURT.nearY - COURT.farY));

        for (let i = COURT.leftX + kitchenNearOffset; i < COURT.rightX - kitchenNearOffset; i += 8) {
            drawLine(i, COURT.kitchenNear, i + 4, COURT.kitchenNear);
        }
        for (let i = COURT.leftX + kitchenFarOffset; i < COURT.rightX - kitchenFarOffset; i += 8) {
            drawLine(i, COURT.kitchenFar, i + 4, COURT.kitchenFar);
        }

        // Net
        const netLeftX = COURT.leftX + perspOffset * 0.5 + 5;
        const netRightX = COURT.rightX - perspOffset * 0.5 - 5;

        setColor(0, 0, 0, 0.3);
        drawRect(netLeftX, COURT.netY + 2, netRightX - netLeftX, 2);

        setColor(0.1, 0.1, 0.1);
        drawRect(netLeftX, COURT.netY - 1, netRightX - netLeftX, 3);

        setColor(1, 1, 1);
        drawRect(netLeftX, COURT.netY - 2, netRightX - netLeftX, 1);

        // Net posts
        setColor(0.33, 0.33, 0.33);
        drawRect(netLeftX - 2, COURT.netY - 10, 4, 16);
        drawRect(netRightX - 2, COURT.netY - 10, 4, 16);
    }

    function drawPerson(p, isKid) {
        const swinging = p.swingFrame > 0;
        const scale = isKid ? 0.75 : 1;
        const baseX = p.x;
        const baseY = p.y;

        // Shadow
        setColor(0, 0, 0, 0.35);
        drawEllipse(baseX, baseY + 2, 12 * scale, 5 * scale);

        // Legs
        setColor(0.66, 0.52, 0.42);
        drawRect(baseX - 6 * scale, baseY - 16 * scale, 4 * scale, 12 * scale);
        drawRect(baseX + 2 * scale, baseY - 16 * scale, 4 * scale, 12 * scale);

        // Shorts
        if (isKid) setColor(0.29, 0.33, 0.40);
        else setColor(0.42, 0.44, 0.50);
        drawRect(baseX - 8 * scale, baseY - 24 * scale, 16 * scale, 10 * scale);

        // Torso
        if (isKid) setColor(0.96, 0.96, 0.94);
        else setColor(0.29, 0.40, 0.25);
        drawRect(baseX - 10 * scale, baseY - 38 * scale, 20 * scale, 18 * scale);

        // Hood/collar
        if (isKid) setColor(0.90, 0.89, 0.87);
        else setColor(0.24, 0.34, 0.21);
        ctx.beginPath();
        ctx.arc(baseX, baseY - 38 * scale, 6 * scale, Math.PI, 0);
        ctx.fill();

        // Arms
        if (isKid) setColor(0.96, 0.96, 0.94);
        else setColor(0.29, 0.40, 0.25);
        if (swinging) {
            ctx.save();
            ctx.translate(baseX + 8 * scale, baseY - 32 * scale);
            ctx.rotate(-0.8);
            drawRect(0, 0, 14 * scale, 5 * scale);
            ctx.restore();
            drawRect(baseX - 12 * scale, baseY - 34 * scale, 5 * scale, 10 * scale);
        } else {
            drawRect(baseX + 7 * scale, baseY - 34 * scale, 5 * scale, 10 * scale);
            drawRect(baseX - 12 * scale, baseY - 34 * scale, 5 * scale, 10 * scale);
        }

        // Head
        setColor(0.91, 0.83, 0.77);
        drawCircle(baseX, baseY - 44 * scale, 7 * scale);

        // Hair
        if (isKid) setColor(0.55, 0.41, 0.08);
        else setColor(0.35, 0.29, 0.23);
        ctx.beginPath();
        ctx.arc(baseX, baseY - 47 * scale, 6 * scale, Math.PI, 0);
        ctx.fill();

        // Dad's cap
        if (!isKid) {
            setColor(0.96, 0.96, 0.94);
            drawEllipse(baseX, baseY - 50 * scale, 8 * scale, 3 * scale);
            drawRect(baseX - 2 * scale, baseY - 48 * scale, 10 * scale, 3 * scale);
        }

        // Eyes
        setColor(0.2, 0.2, 0.2);
        drawRect(baseX - 3 * scale, baseY - 44 * scale, 2 * scale, 2 * scale);
        drawRect(baseX + 1 * scale, baseY - 44 * scale, 2 * scale, 2 * scale);

        // Paddle
        ctx.save();
        if (swinging) {
            ctx.translate(baseX + 18 * scale, baseY - 36 * scale);
            ctx.rotate(-0.6);
        } else {
            ctx.translate(baseX + 14 * scale, baseY - 28 * scale);
            ctx.rotate(0.2);
        }
        setColor(0.77, 0.12, 0.23);
        drawEllipse(8 * scale, 0, 7 * scale, 5 * scale);
        setColor(0.29, 0.29, 0.29);
        drawRect(-2 * scale, -2 * scale, 6 * scale, 4 * scale);
        ctx.restore();
    }

    function drawRaccoon(r) {
        const swinging = r.swingFrame > 0;
        const baseX = r.x;
        const baseY = r.y;
        const scale = 0.9;

        // Shadow
        setColor(0, 0, 0, 0.35);
        drawEllipse(baseX, baseY + 2, 10 * scale, 4 * scale);

        // Tail (striped)
        ctx.save();
        ctx.translate(baseX - 10 * scale, baseY - 12 * scale);
        ctx.rotate(-0.4);
        for (let i = 0; i <= 5; i++) {
            if (i % 2 === 0) setColor(0.60, 0.60, 0.60);
            else setColor(0.23, 0.23, 0.23);
            drawEllipse(0, -i * 4 * scale, 4 * scale, 3 * scale);
        }
        ctx.restore();

        // Hind legs
        setColor(0.35, 0.35, 0.35);
        drawRect(baseX - 7 * scale, baseY - 8 * scale, 5 * scale, 8 * scale);
        drawRect(baseX + 2 * scale, baseY - 8 * scale, 5 * scale, 8 * scale);

        // Body
        setColor(0.48, 0.48, 0.48);
        drawEllipse(baseX, baseY - 18 * scale, 12 * scale, 10 * scale);

        // Belly
        setColor(0.60, 0.60, 0.60);
        drawEllipse(baseX, baseY - 16 * scale, 8 * scale, 6 * scale);

        // Front paws
        setColor(0.35, 0.35, 0.35);
        if (swinging) {
            ctx.save();
            ctx.translate(baseX + 8 * scale, baseY - 22 * scale);
            ctx.rotate(-0.7);
            drawRect(0, 0, 10 * scale, 4 * scale);
            ctx.restore();
        } else {
            drawRect(baseX + 8 * scale, baseY - 22 * scale, 4 * scale, 8 * scale);
        }
        drawRect(baseX - 12 * scale, baseY - 22 * scale, 4 * scale, 8 * scale);

        // Little paw
        setColor(0.29, 0.29, 0.29);
        drawCircle(baseX - 10 * scale, baseY - 14 * scale, 3 * scale);

        // Head
        setColor(0.54, 0.54, 0.54);
        drawCircle(baseX, baseY - 32 * scale, 9 * scale);

        // Snout
        setColor(0.60, 0.60, 0.60);
        drawEllipse(baseX, baseY - 28 * scale, 5 * scale, 4 * scale);

        // Nose
        setColor(0.16, 0.16, 0.16);
        drawCircle(baseX, baseY - 26 * scale, 2 * scale);

        // Mask
        setColor(0.16, 0.16, 0.16);
        drawEllipse(baseX - 5 * scale, baseY - 33 * scale, 4 * scale, 3 * scale);
        drawEllipse(baseX + 5 * scale, baseY - 33 * scale, 4 * scale, 3 * scale);

        // Eyes
        setColor(1, 1, 0.53);
        drawCircle(baseX - 4 * scale, baseY - 33 * scale, 2 * scale);
        drawCircle(baseX + 4 * scale, baseY - 33 * scale, 2 * scale);

        // Pupils
        setColor(0.1, 0.1, 0.1);
        drawCircle(baseX - 4 * scale, baseY - 33 * scale, 1 * scale);
        drawCircle(baseX + 4 * scale, baseY - 33 * scale, 1 * scale);

        // Ears
        setColor(0.42, 0.42, 0.42);
        drawCircle(baseX - 7 * scale, baseY - 40 * scale, 4 * scale);
        drawCircle(baseX + 7 * scale, baseY - 40 * scale, 4 * scale);

        // Ear tips
        setColor(0.81, 0.81, 0.81);
        ctx.beginPath();
        ctx.arc(baseX - 7 * scale, baseY - 41 * scale, 2 * scale, Math.PI, 0);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(baseX + 7 * scale, baseY - 41 * scale, 2 * scale, Math.PI, 0);
        ctx.fill();

        // Paddle (blue for raccoons)
        ctx.save();
        if (swinging) {
            ctx.translate(baseX + 16 * scale, baseY - 26 * scale);
            ctx.rotate(-0.5);
        } else {
            ctx.translate(baseX + 12 * scale, baseY - 18 * scale);
            ctx.rotate(0.4);
        }
        setColor(0.18, 0.36, 0.66);
        drawEllipse(6 * scale, 0, 6 * scale, 4 * scale);
        setColor(0.29, 0.29, 0.29);
        drawRect(-2 * scale, -2 * scale, 5 * scale, 4 * scale);
        ctx.restore();
    }

    function drawBall() {
        if (gameState !== "serving" && gameState !== "playing") return;

        // Hit flash
        if (hitFlash > 0) {
            setColor(1, 1, 1, hitFlash / 10);
            drawCircle(ball.x, ball.y - ball.z * 0.3, 30 + (8 - hitFlash) * 3);
            hitFlash--;
        }

        // Shadow
        setColor(0, 0, 0, 0.3);
        drawEllipse(ball.x, ball.y + 4, ball.radius * 1.2, ball.radius * 0.5);

        const ballScreenY = ball.y - ball.z * 0.3;

        // Outer glow
        setColor(0.83, 0.83, 0);
        drawCircle(ball.x, ballScreenY, ball.radius + 2);

        // Ball
        setColor(0.94, 0.88, 0);
        drawCircle(ball.x, ballScreenY, ball.radius);

        // Highlight
        setColor(1, 1, 1);
        drawCircle(ball.x - 2, ballScreenY - 2, ball.radius * 0.4);
    }

    function drawUI() {
        // Player score panel
        setColor(0.1, 0.1, 0.1, 0.85);
        drawRect(7, 7, 120, 48);
        setColor(0.18, 0.36, 0.66);
        drawRect(7, 7, 4, 48);

        setColor(1, 1, 1);
        ctx.font = "12px sans-serif";
        ctx.fillText("DAD & KID", 16, 24);
        ctx.font = "bold 18px sans-serif";
        ctx.fillText(playerScore.toString().padStart(2, '0'), 16, 46);

        // Raccoon score panel
        setColor(0.1, 0.1, 0.1, 0.85);
        drawRect(513, 7, 120, 48);
        setColor(0.77, 0.12, 0.23);
        drawRect(629, 7, 4, 48);

        setColor(1, 1, 1);
        ctx.font = "12px sans-serif";
        ctx.textAlign = "right";
        ctx.fillText("RACCOONS", 625, 24);
        ctx.font = "bold 18px sans-serif";
        ctx.fillText(raccoonScore.toString().padStart(2, '0'), 625, 46);
        ctx.textAlign = "left";

        // Serving indicator
        if (gameState === "serving") {
            const server = servingTeam === "player" ? "YOUR SERVE" : "THEIR SERVE";
            const boxWidth = 200;

            setColor(0.1, 0.1, 0.1, 0.9);
            drawRect(320 - boxWidth/2, 435, boxWidth, 39);

            if (servingTeam === "player") setColor(0.18, 0.36, 0.66);
            else setColor(0.77, 0.12, 0.23);
            drawRect(320 - boxWidth/2, 435, boxWidth, 4);

            setColor(1, 1, 1);
            ctx.font = "bold 14px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText(server, 320, 456);
            ctx.font = "11px sans-serif";
            setColor(0.67, 0.67, 0.67);
            ctx.fillText("PRESS A TO SERVE", 320, 470);
            ctx.textAlign = "left";
        }

        // Rally count
        if (gameState === "playing" && rallyCount > 0) {
            let rallyColor;
            if (rallyCount >= 10) rallyColor = [0.77, 0.12, 0.23];
            else if (rallyCount >= 5) rallyColor = [0.83, 0.65, 0.28];
            else rallyColor = [1, 1, 1];

            setColor(0.1, 0.1, 0.1, 0.7);
            drawRect(267, 5, 106, 27);

            setColor(rallyColor[0], rallyColor[1], rallyColor[2]);
            ctx.font = "bold 14px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("RALLY " + rallyCount, 320, 24);
            ctx.textAlign = "left";
        }

        // Control hints
        if (gameState === "playing") {
            setColor(1, 1, 1, 0.5);
            ctx.font = "11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("ARROWS: MOVE   ESC: MENU", 320, 474);
            ctx.textAlign = "left";
        }
    }

    // Game logic
    function resetPositions() {
        const playerY = COURT.kitchenNear + 45;
        const raccoonY = COURT.kitchenFar - 15;

        kid.x = 320;
        kid.y = playerY;
        kid.targetX = kid.x;
        kid.targetY = kid.y;

        dad.x = 213;
        dad.y = playerY;
        dad.targetX = dad.x;
        dad.targetY = dad.y;

        raccoon1.x = COURT.leftX + 107;
        raccoon1.y = raccoonY;
        raccoon1.targetX = raccoon1.x;
        raccoon1.targetY = raccoon1.y;

        raccoon2.x = COURT.rightX - 107;
        raccoon2.y = raccoonY;
        raccoon2.targetX = raccoon2.x;
        raccoon2.targetY = raccoon2.y;

        if (servingTeam === "player") {
            ball.x = kid.x;
            ball.y = kid.y - 38;
        } else {
            ball.x = raccoon1.x;
            ball.y = raccoon1.y + 38;
        }

        ball.z = 23;
        ball.vx = 0;
        ball.vy = 0;
        ball.inPlay = false;
        ball.speed = 2.0;
        ball.lastHitBy = null;
        rallyCount = 0;
    }

    function serve() {
        ball.inPlay = true;
        ball.speed = 2.0;
        ball.z = 30;

        if (servingTeam === "player") {
            ball.x = kid.x;
            ball.y = kid.y - 23;
            let serveAngle = 0;
            if (kid.x < COURT.centerX - 50) {
                serveAngle = 0.4 + Math.random() * 0.3;
            } else if (kid.x > COURT.centerX + 50) {
                serveAngle = -0.4 - Math.random() * 0.3;
            } else {
                serveAngle = (Math.random() > 0.5 ? 1 : -1) * (0.3 + Math.random() * 0.4);
            }
            ball.vx = serveAngle * ball.speed;
            ball.vy = -ball.speed;
            ball.lastHitBy = "player";
        } else {
            ball.x = raccoon1.x;
            ball.y = raccoon1.y + 23;
            const serveAngle = (Math.random() - 0.5) * 0.8;
            ball.vx = serveAngle * ball.speed;
            ball.vy = ball.speed;
            ball.lastHitBy = "raccoon";
        }

        gameState = "playing";
    }

    function saveCompletion() {
        try {
            let completed = JSON.parse(localStorage.getItem('seaRanchQuestCompleted') || '[]');
            if (!completed.includes(7)) {
                completed.push(7);
                localStorage.setItem('seaRanchQuestCompleted', JSON.stringify(completed));
            }
        } catch (e) {}
    }

    function spawnSparkles(x, y) {
        for (let i = 0; i < 8; i++) {
            sparkles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                life: 20
            });
        }
    }

    function shake(amount) {
        shakeAmount = amount;
    }

    function endPoint() {
        ball.inPlay = false;

        const playerWon = ball.y < COURT.netY;

        if (playerWon) {
            playerScore++;
            servingTeam = "player";
            shake(6);
        } else {
            raccoonScore++;
            servingTeam = "raccoon";
            shake(6);
        }

        if (playerScore >= 5 || raccoonScore >= 5) {
            gameState = "gameover";
            if (playerScore >= 5) {
                saveCompletion();
            }
        } else {
            gameState = "serving";
            resetPositions();
        }
    }

    function updateBall() {
        if (!ball.inPlay) return;

        ball.x += ball.vx;
        ball.y += ball.vy;
        ball.z = 15 + Math.sin(time * 0.08) * 5;

        // Wall bounces
        if (ball.x < COURT.leftX + 13) {
            ball.x = COURT.leftX + 13;
            ball.vx = Math.abs(ball.vx) * 0.9;
        }
        if (ball.x > COURT.rightX - 13) {
            ball.x = COURT.rightX - 13;
            ball.vx = -Math.abs(ball.vx) * 0.9;
        }

        // Player intercept zone
        if (ball.lastHitBy === "raccoon" && ball.vy > 0) {
            const interceptY = COURT.kitchenNear + 45;

            if (ball.y >= interceptY && ball.y < interceptY + 15) {
                const kidCanHit = Math.abs(ball.x - kid.x) < 67;
                const dadCanHit = Math.abs(ball.x - dad.x) < 53;

                if (kidCanHit || dadCanHit) {
                    const hitter = kidCanHit ? kid : dad;
                    hitter.swingFrame = 8;
                    ball.lastHitBy = "player";
                    rallyCount++;
                    hitFlash = 8;
                    shake(3);
                    spawnSparkles(ball.x, ball.y);

                    const hitOffset = (ball.x - hitter.x) / 40;
                    const variance = (Math.random() - 0.5) * 0.4;
                    ball.speed = Math.min(ball.speed + 0.11, 3.5);
                    ball.vx = (hitOffset + variance) * ball.speed * 1.0;
                    ball.vy = -ball.speed;
                }
            }

            if (ball.y > COURT.nearY + 30) {
                endPoint();
            }
        }

        // Raccoon intercept zone
        if (ball.lastHitBy === "player" && ball.vy < 0) {
            const interceptY = COURT.kitchenFar - 15;

            if (ball.y <= interceptY && ball.y > interceptY - 15) {
                const r1Dist = Math.abs(ball.x - raccoon1.x);
                const r2Dist = Math.abs(ball.x - raccoon2.x);

                const reachPenalty = Math.max(0, (ball.speed - 1.4) * 15);
                const raccoonReach = 55 - reachPenalty;

                const r1CanHit = r1Dist < raccoonReach;
                const r2CanHit = r2Dist < raccoonReach;

                if (r1CanHit || r2CanHit) {
                    const hitter = r1CanHit ? raccoon1 : raccoon2;
                    hitter.swingFrame = 6;
                    ball.lastHitBy = "raccoon";
                    rallyCount++;

                    const hitOffset = (ball.x - hitter.x) / 47;
                    const variance = (Math.random() - 0.5) * 0.4;
                    ball.speed = Math.min(ball.speed + 0.11, 3.5);
                    ball.vx = (hitOffset + variance) * ball.speed * 0.9;
                    ball.vy = ball.speed;
                } else {
                    const closer = r1Dist < r2Dist ? raccoon1 : raccoon2;
                    closer.swingFrame = 10;
                    hitFlash = 10;
                }
            }

            if (ball.y < COURT.farY - 30) {
                endPoint();
            }
        }
    }

    function updatePlayers() {
        const speed = 8;

        if (isDown('left')) kid.targetX -= speed;
        if (isDown('right')) kid.targetX += speed;

        kid.targetX = Math.max(COURT.leftX + 27, Math.min(COURT.rightX - 27, kid.targetX));
        kid.targetY = COURT.kitchenNear + 45;

        kid.x += (kid.targetX - kid.x) * 0.45;
        kid.y += (kid.targetY - kid.y) * 0.45;

        // Dad AI
        if (ball.inPlay && ball.lastHitBy === "raccoon" && ball.vy > 0) {
            if (kid.x > COURT.centerX) {
                if (ball.x < COURT.centerX) {
                    dad.targetX = ball.x;
                } else {
                    dad.targetX = COURT.leftX + 80;
                }
            } else {
                if (ball.x > COURT.centerX) {
                    dad.targetX = ball.x;
                } else {
                    dad.targetX = COURT.rightX - 80;
                }
            }
        } else {
            dad.targetX = kid.x > COURT.centerX ? (COURT.leftX + 107) : (COURT.rightX - 107);
        }

        dad.targetX = Math.max(COURT.leftX + 27, Math.min(COURT.rightX - 27, dad.targetX));
        dad.targetY = COURT.kitchenNear + 45;

        dad.x += (dad.targetX - dad.x) * 0.25;
        dad.y += (dad.targetY - dad.y) * 0.25;

        // Raccoons AI
        const raccoonY = COURT.kitchenFar - 15;
        raccoon1.targetY = raccoonY;
        raccoon2.targetY = raccoonY;

        if (ball.inPlay && ball.lastHitBy === "player" && ball.vy < 0) {
            const timeToIntercept = (raccoonY - ball.y) / Math.abs(ball.vy);
            let predictedX = ball.x + ball.vx * timeToIntercept;

            const error = (Math.random() - 0.5) * 60;
            predictedX += error;

            const r1DistToPredict = Math.abs(raccoon1.x - predictedX);
            const r2DistToPredict = Math.abs(raccoon2.x - predictedX);

            if (r1DistToPredict < r2DistToPredict) {
                raccoon1.targetX = predictedX;
                if (predictedX < COURT.centerX) {
                    raccoon2.targetX = COURT.centerX + 100;
                } else {
                    raccoon2.targetX = COURT.rightX - 100;
                }
            } else {
                raccoon2.targetX = predictedX;
                if (predictedX > COURT.centerX) {
                    raccoon1.targetX = COURT.centerX - 100;
                } else {
                    raccoon1.targetX = COURT.leftX + 100;
                }
            }
        } else {
            raccoon1.targetX = COURT.centerX - 100;
            raccoon2.targetX = COURT.centerX + 100;
        }

        raccoon1.targetX = Math.max(COURT.leftX + 50, Math.min(COURT.centerX - 10, raccoon1.targetX));
        raccoon2.targetX = Math.max(COURT.centerX + 10, Math.min(COURT.rightX - 50, raccoon2.targetX));

        raccoon1.x += (raccoon1.targetX - raccoon1.x) * 0.10;
        raccoon1.y += (raccoon1.targetY - raccoon1.y) * 0.10;
        raccoon2.x += (raccoon2.targetX - raccoon2.x) * 0.10;
        raccoon2.y += (raccoon2.targetY - raccoon2.y) * 0.10;

        // Swing animations
        if (dad.swingFrame > 0) dad.swingFrame--;
        if (kid.swingFrame > 0) kid.swingFrame--;
        if (raccoon1.swingFrame > 0) raccoon1.swingFrame--;
        if (raccoon2.swingFrame > 0) raccoon2.swingFrame--;
    }

    function drawMenuBackground() {
        setColor(0.96, 0.94, 0.91);
        drawRect(0, 0, W, H);
    }

    function drawTitleCard() {
        drawMenuBackground();

        // Blue curves
        setColor(0.18, 0.36, 0.66);
        ctx.lineWidth = 27;
        drawArcLine(-67, 555, 267, -Math.PI * 0.5, 0);
        drawArcLine(-67, 555, 314, -Math.PI * 0.5, 0);

        // Arrow supergraphic
        setColor(0.77, 0.12, 0.23);
        ctx.save();
        ctx.translate(480, 200);
        ctx.rotate(-Math.PI/4);
        drawRect(-60, -15, 120, 30);
        drawPolygon([50, -40, 90, 0, 50, 40]);
        ctx.restore();

        // Title
        setColor(0.1, 0.1, 0.1);
        ctx.font = "bold 48px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Paddle Ball", W/2, 200);

        // Subtitle
        ctx.font = "18px sans-serif";
        setColor(0.55, 0.45, 0.35);
        ctx.fillText("Dad & Kid vs Raccoons", W/2, 240);

        // Press A
        if (Math.floor(time / 30) % 2 === 0) {
            ctx.font = "16px sans-serif";
            setColor(0.1, 0.1, 0.1);
            ctx.fillText("PRESS A TO START", W/2, 400);
        }
        ctx.textAlign = "left";
    }

    function drawGameOver() {
        drawMenuBackground();

        // Blue curves
        setColor(0.18, 0.36, 0.66);
        ctx.lineWidth = 27;
        drawArcLine(-67, 555, 267, -Math.PI * 0.5, 0);
        drawArcLine(-67, 555, 314, -Math.PI * 0.5, 0);

        setColor(0.1, 0.1, 0.1);
        ctx.font = "bold 36px sans-serif";
        ctx.textAlign = "center";
        if (playerScore >= 5) {
            ctx.fillText("GAME, SET, MATCH!", W/2, 200);
        } else {
            ctx.fillText("RACCOONS WIN", W/2, 200);
        }

        ctx.font = "18px sans-serif";
        setColor(0.55, 0.45, 0.35);
        ctx.fillText("Final Score: " + playerScore + " - " + raccoonScore, W/2, 250);

        if (Math.floor(time / 30) % 2 === 0) {
            ctx.font = "16px sans-serif";
            setColor(0.1, 0.1, 0.1);
            ctx.fillText("PRESS A", W/2, 400);
        }
        ctx.textAlign = "left";
    }

    function drawGrain(intensity) {
        const imageData = ctx.getImageData(0, 0, W, H);
        const data = imageData.data;
        const grainAmount = intensity * 50;

        for (let i = 0; i < data.length; i += 16) {
            const noise = (Math.random() - 0.5) * grainAmount;
            data[i] = Math.min(255, Math.max(0, data[i] + noise));
            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise));
            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise));
        }

        ctx.putImageData(imageData, 0, 0);
    }

    function updateSparkles() {
        for (let i = sparkles.length - 1; i >= 0; i--) {
            const s = sparkles[i];
            s.x += s.vx;
            s.y += s.vy;
            s.life--;
            if (s.life <= 0) {
                sparkles.splice(i, 1);
            }
        }
    }

    function drawSparkles() {
        for (const s of sparkles) {
            const alpha = s.life / 20;
            setColor(1, 1, 0.5, alpha);
            drawCircle(s.x, s.y, 3);
        }
    }

    function applyShake() {
        if (shakeAmount > 0) {
            shakeX = (Math.random() - 0.5) * shakeAmount;
            shakeY = (Math.random() - 0.5) * shakeAmount;
            shakeAmount *= 0.8;
            if (shakeAmount < 0.5) shakeAmount = 0;
        } else {
            shakeX = 0;
            shakeY = 0;
        }
    }

    function update() {
        time++;

        if (gameState === "title") {
            if (wasJustPressed('a')) {
                gameState = "serving";
                playerScore = 0;
                raccoonScore = 0;
                servingTeam = "player";
                resetPositions();
            }
        } else if (gameState === "serving") {
            if (wasJustPressed('b')) {
                window.location.href = 'index.html';
                return;
            }
            if (servingTeam === "player") {
                if (wasJustPressed('a')) {
                    serve();
                }
            } else {
                raccoonServeTimer++;
                if (raccoonServeTimer > 50) {
                    serve();
                    raccoonServeTimer = 0;
                }
            }
        } else if (gameState === "playing") {
            updatePlayers();
            updateBall();
            if (wasJustPressed('b')) {
                window.location.href = 'index.html';
                return;
            }
        } else if (gameState === "gameover") {
            if (wasJustPressed('a') || wasJustPressed('b')) {
                window.location.href = 'index.html';
                return;
            }
        }

        updateSparkles();

        // Clear just pressed
        for (const key in justPressed) {
            justPressed[key] = false;
        }
    }

    function draw() {
        ctx.clearRect(0, 0, W, H);

        if (gameState === "title") {
            drawTitleCard();
            drawGrain(0.06);
            return;
        }

        if (gameState === "gameover") {
            drawGameOver();
            drawGrain(0.06);
            return;
        }

        applyShake();
        ctx.save();
        ctx.translate(shakeX, shakeY);

        drawBackground();
        drawCourt();

        // Draw characters sorted by Y
        const chars = [
            {type: "raccoon", obj: raccoon1},
            {type: "raccoon", obj: raccoon2},
            {type: "dad", obj: dad},
            {type: "kid", obj: kid}
        ];
        chars.sort((a, b) => a.obj.y - b.obj.y);

        for (const c of chars) {
            if (c.type === "raccoon") {
                drawRaccoon(c.obj);
            } else if (c.type === "kid") {
                drawPerson(c.obj, true);
            } else {
                drawPerson(c.obj, false);
            }
        }

        drawBall();
        drawSparkles();

        ctx.restore();

        drawUI();
        drawGrain(0.06);
    }

    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    // Start the game
    gameLoop();
    </script>
</body>
</html>
