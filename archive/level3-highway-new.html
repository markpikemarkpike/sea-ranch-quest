<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sea Ranch Quest - Highway 1</title>
    <script src="sea-ranch-style.js"></script>
    <style>
        :root {
            --black: #1a1a1a;
            --white: #f5f5f0;
            --red: #C41E3A;
            --blue: #2E5DA8;
            --wood: #8b7355;
            --sand: #d4c4a8;
            --fog: #e8e4dc;
        }

        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }
        #game-container {
            width: 640px;
            height: 480px;
            position: relative;
            overflow: hidden;
            background: #1a1a1a;
        }
        canvas {
            display: block;
            image-rendering: pixelated;
        }

        /* HTML/CSS Title Card - Barbara Stauffacher Solomon supergraphic style */
        .title-card {
            position: absolute;
            inset: 0;
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .title-card .wood-bg {
            position: absolute;
            inset: 0;
            background:
                repeating-linear-gradient(
                    90deg,
                    transparent 0px,
                    transparent 3px,
                    rgba(139, 115, 85, 0.08) 3px,
                    rgba(139, 115, 85, 0.08) 4px
                ),
                radial-gradient(ellipse at 20% 30%, rgba(139, 115, 85, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 70% 60%, rgba(139, 115, 85, 0.1) 0%, transparent 40%),
                radial-gradient(ellipse at 40% 80%, rgba(139, 115, 85, 0.12) 0%, transparent 45%),
                linear-gradient(180deg, var(--fog) 0%, var(--sand) 100%);
        }

        .title-card .supergraphic {
            position: absolute;
            top: -80px;
            right: -120px;
            width: 550px;
            height: 550px;
            pointer-events: none;
        }

        .title-card .supergraphic::before,
        .title-card .supergraphic::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            border: 36px solid var(--blue);
        }

        .title-card .supergraphic::before {
            width: 420px;
            height: 420px;
            top: 0;
            right: 0;
            border-color: transparent transparent var(--blue) var(--blue);
            transform: rotate(-45deg);
        }

        .title-card .supergraphic::after {
            width: 320px;
            height: 320px;
            top: 50px;
            right: 50px;
            border-color: transparent transparent var(--blue) var(--blue);
            transform: rotate(-45deg);
            opacity: 0.7;
        }

        .title-card .arrow-accent {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 80px;
            height: 100px;
            pointer-events: none;
        }

        .title-card .arrow-accent::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 40px solid transparent;
            border-right: 40px solid transparent;
            border-bottom: 50px solid var(--red);
            top: 0;
        }

        .title-card .arrow-accent::after {
            content: '';
            position: absolute;
            width: 26px;
            height: 50px;
            background: var(--red);
            top: 45px;
            left: 27px;
        }

        .title-card .title-content {
            position: relative;
            z-index: 10;
            text-align: center;
        }

        .title-card .level-title {
            font-size: 56px;
            font-weight: 700;
            color: var(--black);
            letter-spacing: -2px;
            line-height: 1;
            margin-bottom: 12px;
        }

        .title-card .level-subtitle {
            font-size: 18px;
            font-weight: 400;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: var(--wood);
        }

        .title-card .continue-hint {
            position: absolute;
            bottom: 36px;
            right: 36px;
            font-size: 12px;
            color: var(--wood);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .title-card .title-grain {
            position: absolute;
            inset: 0;
            opacity: 0.4;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%' height='100%' filter='url(%23noise)'/%3E%3C/svg%3E");
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- HTML/CSS Title Card - Barbara Stauffacher Solomon supergraphic style -->
        <div class="title-card" id="title-card">
            <div class="wood-bg"></div>
            <div class="supergraphic"></div>
            <div class="arrow-accent"></div>
            <div class="title-content">
                <div class="level-title">Highway 1</div>
                <div class="level-subtitle">Jenner to Sea Ranch</div>
            </div>
            <div class="continue-hint">A to start - B to menu</div>
            <div class="title-grain"></div>
        </div>

        <canvas id="game" width="640" height="480"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const W = 640;
        const H = 480;

        // =====================================================================
        // COLORS - Golden hour on Sonoma Coast (exact from Lua)
        // =====================================================================
        const COLORS = {
            skyTop: [0.31, 0.50, 0.63],
            skyMid: [0.50, 0.63, 0.69],
            skyBottom: [0.75, 0.63, 0.50],

            oceanDeep: [0.10, 0.31, 0.38],
            oceanMid: [0.16, 0.35, 0.41],
            oceanShimmer: [0.75, 0.56, 0.38],

            cliff: [0.35, 0.29, 0.25],
            cliffLight: [0.48, 0.42, 0.35],

            grass: [0.35, 0.44, 0.31],
            grassLight: [0.48, 0.56, 0.40],
            grassDark: [0.29, 0.35, 0.25],

            asphalt: [0.23, 0.23, 0.22],
            lineYellow: [0.75, 0.63, 0.31],
            lineWhite: [0.81, 0.80, 0.75],

            carBody: [0.45, 0.18, 0.22],
            carLight: [0.54, 0.25, 0.28],
            carChrome: [0.75, 0.72, 0.66],
            carWindow: [0.25, 0.31, 0.38],

            rock: [0.42, 0.38, 0.35],
            deer: [0.54, 0.44, 0.38],
            sun: [1.0, 0.88, 0.63]
        };

        // Helper to convert [r,g,b] 0-1 to CSS
        function toRGB(c) {
            return `rgb(${Math.floor(c[0]*255)}, ${Math.floor(c[1]*255)}, ${Math.floor(c[2]*255)})`;
        }

        function toRGBA(c, a) {
            return `rgba(${Math.floor(c[0]*255)}, ${Math.floor(c[1]*255)}, ${Math.floor(c[2]*255)}, ${a})`;
        }

        // =====================================================================
        // GAME CONSTANTS (exact from Lua)
        // =====================================================================
        const HORIZON_Y = 165;
        const GOAL_DISTANCE = 9600;
        const MAX_DAMAGE = 3;
        const CRUISE_SPEED = 160;
        const MAX_SPEED = 280;

        // =====================================================================
        // GAME STATE
        // =====================================================================
        let gameState = 'title';
        let time = 0;
        let gameTime = 0;
        let distance = 0;
        let damage = 0;
        let hazardsDodged = 0;

        // Player
        let playerX = 0;          // -1 to 1
        let playerVelX = 0;
        let playerSpeed = 0;
        let carBounce = 0;
        let carTilt = 0;
        let wheelSpin = 0;

        // Crash state
        let crashed = false;
        let crashTimer = 0;
        let invincibleTimer = 0;

        // Road
        let roadCurve = 0;
        let targetCurve = 0;
        let curveTimer = 0;

        // Scenery
        let seaStacks = [];
        let cypressTrees = [];
        let grasses = [];
        let fencePosts = [];

        // Hazards
        let hazards = [];

        // Waves (persistent)
        let waves = [];

        // =====================================================================
        // INPUT
        // =====================================================================
        const keys = { left: false, right: false, up: false, down: false, a: false, b: false };
        let justPressed = { a: false, b: false };

        document.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = true;
            if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = true;

            const isActionKey = e.key === ' ' || e.key === 'Enter';
            const isBackKey = e.key === 'Escape' || e.key === 'x' || e.key === 'X' || e.key === 'b' || e.key === 'B';

            if (isActionKey) {
                if (!keys.a) justPressed.a = true;
                keys.a = true;
            }
            if (isBackKey) {
                if (!keys.b) justPressed.b = true;
                keys.b = true;
            }

            e.preventDefault();
        });

        document.addEventListener('keyup', e => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = false;
            if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = false;

            const isActionKey = e.key === ' ' || e.key === 'Enter';
            const isBackKey = e.key === 'Escape' || e.key === 'x' || e.key === 'X' || e.key === 'b' || e.key === 'B';

            if (isActionKey) keys.a = false;
            if (isBackKey) keys.b = false;
        });

        // =====================================================================
        // PERSPECTIVE HELPERS (exact from Lua)
        // =====================================================================
        function depthToY(d) {
            return HORIZON_Y + d * (H - HORIZON_Y);
        }

        function depthToScale(d) {
            return 0.1 + d * 0.9;
        }

        function getRoadX(d) {
            const curveOffset = roadCurve * (1 - d) * (1 - d) * 120;
            return W * 0.5 + curveOffset;
        }

        function getRoadWidth(d) {
            return 20 + d * 180;
        }

        // =====================================================================
        // SPAWNING FUNCTIONS (exact from Lua)
        // =====================================================================
        function spawnSeaStack(depth) {
            seaStacks.push({
                depth: depth,
                x: 0.1 + Math.random() * 0.3,
                height: 30 + Math.random() * 50,
                width: 15 + Math.random() * 25,
                hasTop: Math.random() > 0.4
            });
        }

        function spawnCypress(depth) {
            cypressTrees.push({
                depth: depth,
                offset: 50 + Math.random() * 60,
                height: 35 + Math.random() * 25,
                lean: -0.2 + Math.random() * 0.15
            });
        }

        function spawnGrass(depth) {
            grasses.push({
                depth: depth,
                side: Math.random() > 0.4 ? 'right' : 'left',
                offset: 3 + Math.random() * 12,
                blades: 4 + Math.floor(Math.random() * 4),
                height: 6 + Math.random() * 6,
                sway: Math.random() * Math.PI * 2
            });
        }

        function spawnFencePost(depth) {
            fencePosts.push({
                depth: depth,
                offset: 8 + Math.random() * 10,
                height: 18 + Math.random() * 6,
                lean: (Math.random() - 0.5) * 0.15
            });
        }

        function spawnHazard(htype, laneX) {
            const h = {
                depth: 0.0,
                type: htype,
                laneX: laneX !== undefined ? laneX : (Math.random() - 0.5) * 0.8,
                active: true,
                animPhase: Math.random() * Math.PI * 2
            };

            if (htype === 'rock') {
                h.size = 0.8 + Math.random() * 0.4;
                h.rockType = Math.floor(Math.random() * 3);
            } else if (htype === 'deer') {
                h.runDirection = Math.random() > 0.5 ? 1 : -1;
                h.runSpeed = 0.3 + Math.random() * 0.2;
                h.startX = h.runDirection > 0 ? -0.8 : 0.8;
                h.laneX = h.startX;
                h.isBuck = Math.random() > 0.5;
                h.antlerSize = h.isBuck ? (0.6 + Math.random() * 0.4) : 0;
            } else if (htype === 'debris') {
                h.pieces = 2 + Math.floor(Math.random() * 3);
                h.spread = 0.15 + Math.random() * 0.1;
            } else if (htype === 'log') {
                h.length = 0.8 + Math.random() * 0.4;
                h.rotation = (Math.random() - 0.5) * 0.6;
            }

            hazards.push(h);
        }

        // =====================================================================
        // INIT GAME (exact from Lua)
        // =====================================================================
        function initGame() {
            gameState = 'playing';
            time = 0;
            gameTime = 0;
            distance = 0;
            damage = 0;
            hazardsDodged = 0;
            playerX = 0;
            playerVelX = 0;
            playerSpeed = CRUISE_SPEED;
            crashed = false;
            crashTimer = 0;
            invincibleTimer = 0;
            roadCurve = 0;
            targetCurve = 0;
            curveTimer = 0;

            // Reset scenery
            seaStacks = [];
            cypressTrees = [];
            grasses = [];
            fencePosts = [];
            hazards = [];

            // Initialize waves
            waves = [];
            for (let i = 0; i < 8; i++) {
                waves.push({
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.02 + Math.random() * 0.01,
                    amplitude: 2 + Math.random() * 2,
                    y: 0.1 + i * 0.1
                });
            }

            // Spawn initial scenery
            for (let i = 0; i < 4; i++) spawnSeaStack(i * 0.25);
            for (let i = 0; i < 4; i++) spawnCypress(i * 0.25);
            for (let i = 0; i < 12; i++) spawnGrass(i * 0.08);
            for (let i = 0; i < 5; i++) spawnFencePost(i * 0.2);

            SeaRanchStyle.resetJuice();
        }

        // =====================================================================
        // TRIGGER HIT
        // =====================================================================
        function triggerHit() {
            crashed = true;
            crashTimer = 0.8;
            invincibleTimer = 2.0;
            damage = damage + 1;
            playerSpeed = playerSpeed * 0.3;

            SeaRanchStyle.shake(20);
            SeaRanchStyle.playSound('hit');
        }

        // =====================================================================
        // UPDATE (exact logic from Lua)
        // =====================================================================
        function update(dt) {
            if (gameState === 'title') {
                if (justPressed.a) {
                    document.getElementById('title-card').style.display = 'none';
                    initGame();
                }
                if (justPressed.b) {
                    window.location.href = 'index.html';
                }
                justPressed.a = false;
                justPressed.b = false;
                return;
            }

            if (gameState === 'win' || gameState === 'lose') {
                if (justPressed.a) {
                    document.getElementById('title-card').style.display = 'none';
                    initGame();
                }
                if (justPressed.b) {
                    window.location.href = 'index.html';
                }
                justPressed.a = false;
                justPressed.b = false;
                return;
            }

            time++;
            gameTime++;

            // Win condition
            if (distance >= GOAL_DISTANCE) {
                gameState = 'win';
                SeaRanchStyle.saveCompletion(3);
                SeaRanchStyle.playSound('success');
                return;
            }

            // Lose condition
            if (damage >= MAX_DAMAGE) {
                gameState = 'lose';
                SeaRanchStyle.playSound('hit');
                return;
            }

            // Invincibility frames
            if (invincibleTimer > 0) {
                invincibleTimer -= dt;
            }

            // Crash recovery
            if (crashed) {
                crashTimer -= dt;
                playerSpeed *= 0.96;
                if (crashTimer <= 0) {
                    crashed = false;
                    playerSpeed = CRUISE_SPEED;
                }
            }

            // Road curves
            curveTimer -= dt;
            if (curveTimer <= 0) {
                targetCurve = (Math.random() - 0.5) * 1.2;
                curveTimer = 2 + Math.random() * 2;
            }
            roadCurve += (targetCurve - roadCurve) * dt * 1.5;

            // Speed control
            if (!crashed) {
                if (keys.up) {
                    playerSpeed += 200 * dt;
                } else if (keys.down) {
                    playerSpeed -= 300 * dt;
                } else {
                    playerSpeed += (CRUISE_SPEED - playerSpeed) * dt * 2;
                }
                playerSpeed = Math.max(40, Math.min(MAX_SPEED, playerSpeed));
            }

            // Steering
            const steerPower = 8.0;
            if (keys.left) playerVelX -= steerPower * dt;
            if (keys.right) playerVelX += steerPower * dt;

            // Curve pulls you
            const curveForce = roadCurve * 0.3;
            playerVelX += curveForce * dt;

            // Friction
            const steering = keys.left || keys.right;
            const friction = steering ? 1.5 : 4.0;
            playerVelX *= (1 - friction * dt);
            playerVelX = Math.max(-1.8, Math.min(1.8, playerVelX));
            playerX += playerVelX * dt;

            // Car tilt
            carTilt += (playerVelX * 0.1 - carTilt) * dt * 10;

            // Car bounce
            carBounce = Math.sin(time * 0.25) * 1.5;

            // Wheel spin
            wheelSpin += playerSpeed * dt * 0.08;

            // Lane boundaries
            if (playerX < -0.65) {
                playerX = -0.65;
                playerVelX = Math.max(0, playerVelX * -0.5);
                SeaRanchStyle.shake(6);
            }
            if (playerX > 0.65) {
                playerX = 0.65;
                playerVelX = Math.min(0, playerVelX * -0.5);
                SeaRanchStyle.shake(6);
            }

            // Distance tracking
            distance += playerSpeed * dt;
            const scrollSpeed = playerSpeed / MAX_SPEED * dt;

            // Hazard spawning
            let nearestHazard = 1;
            for (const h of hazards) {
                if (h.depth < nearestHazard) nearestHazard = h.depth;
            }

            if (hazards.length === 0 || (hazards.length < 2 && nearestHazard > 0.4)) {
                const spawnChance = 0.012 + (distance / GOAL_DISTANCE) * 0.008;
                if (Math.random() < spawnChance) {
                    const types = ['rock', 'rock', 'debris', 'deer', 'log', 'log'];
                    spawnHazard(types[Math.floor(Math.random() * types.length)]);
                }
            }

            // Update hazards
            for (let i = hazards.length - 1; i >= 0; i--) {
                const h = hazards[i];
                h.depth += scrollSpeed * 0.9;

                // Deer runs across road
                if (h.type === 'deer' && h.depth > 0.3) {
                    h.laneX += h.runDirection * h.runSpeed * dt;
                }

                // Collision detection
                if (h.active && invincibleTimer <= 0 && h.depth > 0.82 && h.depth < 0.98) {
                    let hitWidth = 0.25;
                    if (h.type === 'debris') hitWidth = h.spread;
                    if (h.type === 'deer') hitWidth = 0.2;

                    if (Math.abs(playerX - h.laneX) < hitWidth) {
                        triggerHit();
                        h.active = false;
                    }
                }

                // Successfully dodged
                if (h.active && h.depth > 1.0) {
                    hazardsDodged++;
                    h.active = false;
                }

                // Remove if off screen
                if (h.depth > 1.2) {
                    hazards.splice(i, 1);
                }
            }

            // Update scenery
            for (let i = seaStacks.length - 1; i >= 0; i--) {
                seaStacks[i].depth += scrollSpeed * 0.7;
                if (seaStacks[i].depth > 1.1) seaStacks.splice(i, 1);
            }
            while (seaStacks.length < 6) spawnSeaStack(Math.random() * 0.1);

            for (let i = cypressTrees.length - 1; i >= 0; i--) {
                cypressTrees[i].depth += scrollSpeed * 0.8;
                if (cypressTrees[i].depth > 1.1) cypressTrees.splice(i, 1);
            }
            while (cypressTrees.length < 4) spawnCypress(Math.random() * 0.1);

            for (let i = grasses.length - 1; i >= 0; i--) {
                grasses[i].depth += scrollSpeed * 0.8;
                if (grasses[i].depth > 1.1) grasses.splice(i, 1);
            }
            while (grasses.length < 25) spawnGrass(Math.random() * 0.05);

            for (let i = fencePosts.length - 1; i >= 0; i--) {
                fencePosts[i].depth += scrollSpeed * 0.8;
                if (fencePosts[i].depth > 1.1) fencePosts.splice(i, 1);
            }
            while (fencePosts.length < 5) spawnFencePost(Math.random() * 0.1);

            // B button to return to menu
            if (justPressed.b) {
                window.location.href = 'index.html';
            }

            // Clear justPressed at end of playing state processing
            justPressed.a = false;
            justPressed.b = false;
        }

        // =====================================================================
        // DRAW SKY (exact from Lua)
        // =====================================================================
        function drawSky() {
            const sunsetProgress = gameTime / (90 * 60);

            // Sky gradient
            for (let y = 0; y <= HORIZON_Y + 20; y++) {
                const t = y / (HORIZON_Y + 20);
                const r = COLORS.skyTop[0] * (1-t) + COLORS.skyBottom[0] * t;
                const g = COLORS.skyTop[1] * (1-t) + COLORS.skyBottom[1] * t;
                const b = COLORS.skyTop[2] * (1-t) + COLORS.skyBottom[2] * t;
                ctx.strokeStyle = `rgb(${Math.floor(r*255)}, ${Math.floor(g*255)}, ${Math.floor(b*255)})`;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(W, y);
                ctx.stroke();
            }

            // Sun
            const sunX = 100 - sunsetProgress * 30;
            const sunY = HORIZON_Y - 45 + sunsetProgress * 25;
            const sunRadius = 32;

            // Sun glow
            for (let i = 4; i >= 0; i--) {
                const glowR = sunRadius + i * 25;
                const alpha = 0.15 - i * 0.025;
                ctx.fillStyle = `rgba(255, ${Math.floor((0.78 - i * 0.08) * 255)}, ${Math.floor((0.39 - i * 0.08) * 255)}, ${alpha})`;
                ctx.beginPath();
                ctx.arc(sunX, sunY, glowR, 0, Math.PI * 2);
                ctx.fill();
            }

            // Sun body
            ctx.fillStyle = toRGB(COLORS.sun);
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
            ctx.fill();

            // Light rays
            ctx.strokeStyle = 'rgba(255, 224, 160, 0.08)';
            ctx.lineWidth = 3;
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 + time * 0.001;
                const rayLen = 70 + Math.sin(time * 0.02 + i) * 20;
                ctx.beginPath();
                ctx.moveTo(sunX + Math.cos(angle) * sunRadius, sunY + Math.sin(angle) * sunRadius);
                ctx.lineTo(sunX + Math.cos(angle) * rayLen, sunY + Math.sin(angle) * rayLen);
                ctx.stroke();
            }

            // Clouds
            ctx.fillStyle = 'rgba(191, 191, 191, 0.3)';
            for (let i = 0; i < 5; i++) {
                const cx = ((i * 180 + time * 0.05) % (W + 100)) - 50;
                const cy = 40 + i * 20;
                ctx.beginPath();
                ctx.ellipse(cx, cy, 60 + i * 10, 8 + i * 2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cx + 40, cy + 5, 40, 6, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // =====================================================================
        // DRAW OCEAN (exact from Lua)
        // =====================================================================
        function drawOcean() {
            // Ocean gradient
            for (let y = HORIZON_Y; y < H; y++) {
                const t = (y - HORIZON_Y) / (H - HORIZON_Y);
                const r = COLORS.oceanMid[0] * (1-t) + COLORS.oceanDeep[0] * t;
                const g = COLORS.oceanMid[1] * (1-t) + COLORS.oceanDeep[1] * t;
                const b = COLORS.oceanMid[2] * (1-t) + COLORS.oceanDeep[2] * t;

                const d = t;
                const roadLeftEdge = getRoadX(Math.min(d, 1)) - getRoadWidth(Math.min(d, 1)) - 5;
                if (roadLeftEdge > 0) {
                    ctx.strokeStyle = `rgb(${Math.floor(r*255)}, ${Math.floor(g*255)}, ${Math.floor(b*255)})`;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(roadLeftEdge, y);
                    ctx.stroke();
                }
            }

            // Sunset reflection
            ctx.fillStyle = 'rgba(255, 199, 99, 0.15)';
            ctx.beginPath();
            ctx.moveTo(30, HORIZON_Y);
            ctx.lineTo(170, HORIZON_Y);
            ctx.lineTo(125, H);
            ctx.lineTo(75, H);
            ctx.closePath();
            ctx.fill();

            // Waves
            for (const wave of waves) {
                const waveY = HORIZON_Y + wave.y * (H - HORIZON_Y);
                const wavePhase = time * wave.speed + wave.phase;
                const d = wave.y;
                const waveMaxX = Math.max(0, getRoadX(Math.min(d, 1)) - getRoadWidth(Math.min(d, 1)) - 10);

                if (waveMaxX > 0) {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.15 - wave.y * 0.1})`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();

                    let first = true;
                    for (let x = 0; x < waveMaxX; x += 15) {
                        const wy = waveY + Math.sin(wavePhase + x * 0.03) * wave.amplitude;
                        if (first) {
                            ctx.moveTo(x, wy);
                            first = false;
                        } else {
                            ctx.lineTo(x, wy);
                        }
                    }
                    ctx.stroke();
                }
            }

            // Sea stacks
            seaStacks.sort((a, b) => a.depth - b.depth);
            for (const stack of seaStacks) {
                if (stack.depth >= 0.02 && stack.depth <= 0.7) {
                    const y = depthToY(stack.depth);
                    const scale = depthToScale(stack.depth);
                    const d = stack.depth;
                    const oceanMaxX = Math.max(0, getRoadX(Math.min(d, 1)) - getRoadWidth(Math.min(d, 1)) - 15);

                    if (oceanMaxX >= 30) {
                        const x = stack.x * oceanMaxX;
                        const w = stack.width * scale;
                        const h = stack.height * scale;

                        // Shadow
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                        ctx.beginPath();
                        ctx.ellipse(x + 5, y + 3, w * 0.8, h * 0.15, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Rock body
                        ctx.fillStyle = toRGB(COLORS.cliff);
                        ctx.beginPath();
                        ctx.moveTo(x - w/2, y);
                        ctx.lineTo(x - w/2 + w * 0.2, y - h * 0.7);
                        ctx.lineTo(x, y - h);
                        ctx.lineTo(x + w/2 - w * 0.2, y - h * 0.6);
                        ctx.lineTo(x + w/2, y);
                        ctx.closePath();
                        ctx.fill();

                        // Highlight
                        ctx.fillStyle = toRGB(COLORS.cliffLight);
                        ctx.beginPath();
                        ctx.moveTo(x - w/4, y - h * 0.3);
                        ctx.lineTo(x, y - h * 0.9);
                        ctx.lineTo(x + w/6, y - h * 0.5);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }
        }

        // =====================================================================
        // DRAW CLIFFS (exact from Lua)
        // =====================================================================
        function drawCliffs() {
            // Distant headlands
            ctx.fillStyle = 'rgb(74, 89, 89)';
            ctx.beginPath();
            ctx.moveTo(0, HORIZON_Y);
            ctx.lineTo(0, HORIZON_Y - 30);
            ctx.lineTo(50, HORIZON_Y - 50);
            ctx.lineTo(100, HORIZON_Y - 20);
            ctx.lineTo(140, HORIZON_Y - 35);
            ctx.lineTo(180, HORIZON_Y);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = 'rgb(89, 107, 107)';
            ctx.beginPath();
            ctx.moveTo(140, HORIZON_Y);
            ctx.lineTo(160, HORIZON_Y - 25);
            ctx.lineTo(200, HORIZON_Y - 40);
            ctx.lineTo(250, HORIZON_Y);
            ctx.closePath();
            ctx.fill();
        }

        // =====================================================================
        // DRAW LAND (exact from Lua)
        // =====================================================================
        function drawLand() {
            // Coastal meadow on right side
            for (let y = HORIZON_Y; y < H; y++) {
                const t = (y - HORIZON_Y) / (H - HORIZON_Y);
                const d = t;
                const roadRightEdge = getRoadX(Math.min(d, 1)) + getRoadWidth(Math.min(d, 1)) + 3;

                const r = COLORS.grassLight[0] * (1-t) + COLORS.grassDark[0] * t;
                const g = COLORS.grassLight[1] * (1-t) + COLORS.grassDark[1] * t;
                const b = COLORS.grassLight[2] * (1-t) + COLORS.grassDark[2] * t;

                if (roadRightEdge < W) {
                    ctx.strokeStyle = `rgb(${Math.floor(r*255)}, ${Math.floor(g*255)}, ${Math.floor(b*255)})`;
                    ctx.beginPath();
                    ctx.moveTo(roadRightEdge, y);
                    ctx.lineTo(W, y);
                    ctx.stroke();
                }
            }
        }

        // =====================================================================
        // DRAW ROAD (exact from Lua)
        // =====================================================================
        function drawRoad() {
            // Road segments
            for (let d = 0; d <= 1.05; d += 0.02) {
                const y1 = depthToY(d);
                const y2 = depthToY(d + 0.02);
                const x1 = getRoadX(d);
                const x2 = getRoadX(d + 0.02);
                const w1 = getRoadWidth(d);
                const w2 = getRoadWidth(d + 0.02);

                const shade = Math.min(d, 1) * 0.15;
                const r = COLORS.asphalt[0] + shade * 0.08;
                const g = COLORS.asphalt[1] + shade * 0.08;
                const b = COLORS.asphalt[2] + shade * 0.06;
                ctx.fillStyle = `rgb(${Math.floor(r*255)}, ${Math.floor(g*255)}, ${Math.floor(b*255)})`;
                ctx.beginPath();
                ctx.moveTo(x1 - w1, y1);
                ctx.lineTo(x1 + w1, y1);
                ctx.lineTo(x2 + w2, y2);
                ctx.lineTo(x2 - w2, y2);
                ctx.closePath();
                ctx.fill();
            }

            // Edge lines
            ctx.strokeStyle = toRGB(COLORS.lineWhite);
            ctx.lineWidth = 2;

            // Left edge
            ctx.beginPath();
            let first = true;
            for (let d = 0; d <= 1.05; d += 0.02) {
                const y = depthToY(d);
                const x = getRoadX(Math.min(d, 1)) - getRoadWidth(Math.min(d, 1));
                if (first) { ctx.moveTo(x, y); first = false; }
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Right edge
            ctx.beginPath();
            first = true;
            for (let d = 0; d <= 1.05; d += 0.02) {
                const y = depthToY(d);
                const x = getRoadX(Math.min(d, 1)) + getRoadWidth(Math.min(d, 1));
                if (first) { ctx.moveTo(x, y); first = false; }
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Center dashed line
            ctx.strokeStyle = toRGB(COLORS.lineYellow);
            ctx.lineWidth = 2.5;

            const dashOffset = (distance * 0.4) % 20;
            for (let d = 0; d <= 1.05; d += 0.02) {
                const segmentD = d * 50;
                if (((segmentD - dashOffset) % 20) < 10) {
                    const y1 = depthToY(d);
                    const y2 = depthToY(d + 0.02);
                    const x1 = getRoadX(Math.min(d, 1));
                    const x2 = getRoadX(Math.min(d + 0.02, 1));
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            }
        }

        // =====================================================================
        // DRAW CYPRESS TREES (exact from Lua)
        // =====================================================================
        function drawCypressTrees() {
            cypressTrees.sort((a, b) => a.depth - b.depth);

            for (const tree of cypressTrees) {
                if (tree.depth >= 0.08 && tree.depth <= 1) {
                    const y = depthToY(tree.depth);
                    const scale = depthToScale(tree.depth);
                    const roadX = getRoadX(tree.depth);
                    const roadW = getRoadWidth(tree.depth);
                    const x = roadX + roadW + tree.offset * scale;

                    if (x <= W - 15) {
                        const h = tree.height * scale;
                        const tw = h * 0.3;

                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(tree.lean);

                        // Trunk
                        ctx.fillStyle = 'rgb(59, 43, 33)';
                        ctx.fillRect(-tw * 0.15, -h * 0.4, tw * 0.3, h * 0.4);

                        // Canopy
                        ctx.fillStyle = 'rgb(43, 74, 59)';
                        ctx.beginPath();
                        ctx.moveTo(-tw * 0.3, -h * 0.3);
                        ctx.lineTo(-tw * 0.2, -h);
                        ctx.lineTo(tw * 0.8, -h * 0.6);
                        ctx.lineTo(tw * 0.3, -h * 0.3);
                        ctx.closePath();
                        ctx.fill();

                        ctx.restore();
                    }
                }
            }
        }

        // =====================================================================
        // DRAW FENCE POSTS (exact from Lua)
        // =====================================================================
        function drawFencePosts() {
            fencePosts.sort((a, b) => a.depth - b.depth);

            for (const post of fencePosts) {
                if (post.depth >= 0.1 && post.depth <= 1) {
                    const y = depthToY(post.depth);
                    const scale = depthToScale(post.depth);
                    const roadX = getRoadX(post.depth);
                    const roadW = getRoadWidth(post.depth);
                    const x = roadX + roadW + post.offset * scale;

                    if (x <= W - 10) {
                        const h = post.height * scale;

                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(post.lean);

                        ctx.fillStyle = 'rgb(107, 89, 74)';
                        ctx.fillRect(-2 * scale, -h, 4 * scale, h);

                        ctx.restore();
                    }
                }
            }
        }

        // =====================================================================
        // DRAW GRASS (exact from Lua)
        // =====================================================================
        function drawGrass() {
            for (const g of grasses) {
                if (g.depth >= 0.1 && g.depth <= 1) {
                    const y = depthToY(g.depth);
                    const scale = depthToScale(g.depth);
                    const roadX = getRoadX(g.depth);
                    const roadW = getRoadWidth(g.depth);

                    let x;
                    if (g.side === 'right') {
                        x = roadX + roadW + g.offset * scale;
                        if (x > W - 10) continue;
                    } else {
                        const leftEdge = roadX - roadW;
                        if (leftEdge < 20) continue;
                        x = leftEdge - g.offset * scale;
                    }

                    const sway = Math.sin(time * 0.05 + g.sway) * 3 * scale;

                    ctx.strokeStyle = toRGB(COLORS.grass);
                    ctx.lineWidth = 1;

                    for (let b = 0; b < g.blades; b++) {
                        const bladeX = x + (b - g.blades/2) * 2 * scale;
                        const bladeH = g.height * scale * (0.7 + Math.random() * 0.3);
                        const bladeSway = sway + Math.sin(b) * 2;

                        ctx.beginPath();
                        ctx.moveTo(bladeX, y);
                        ctx.lineTo(bladeX + bladeSway, y - bladeH);
                        ctx.stroke();
                    }
                }
            }
        }

        // =====================================================================
        // DRAW HAZARDS (exact from Lua)
        // =====================================================================
        function drawHazards() {
            hazards.sort((a, b) => a.depth - b.depth);

            for (const h of hazards) {
                if (h.depth >= 0.02 && h.depth <= 1.1) {
                    const y = depthToY(h.depth);
                    const scale = depthToScale(h.depth);
                    const roadX = getRoadX(h.depth);
                    const roadW = getRoadWidth(h.depth);
                    const x = roadX + h.laneX * roadW;

                    if (h.type === 'rock') {
                        const size = 40 * scale * h.size;

                        // Shadow
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                        ctx.beginPath();
                        ctx.ellipse(x + 4 * scale, y + 3 * scale, size * 1.1, size * 0.25, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Rock body
                        ctx.fillStyle = toRGB(COLORS.rock);
                        ctx.beginPath();
                        ctx.ellipse(x, y - size * 0.35, size * 0.6, size * 0.5, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Highlight
                        ctx.fillStyle = 'rgb(140, 128, 115)';
                        ctx.beginPath();
                        ctx.ellipse(x - size * 0.15, y - size * 0.45, size * 0.25, size * 0.2, 0, 0, Math.PI * 2);
                        ctx.fill();

                    } else if (h.type === 'deer') {
                        const deerScale = scale * 1.6;
                        const runCycle = Math.sin(time * 0.5 + h.animPhase);
                        const backLegOffset = runCycle * 8;
                        const frontLegOffset = -runCycle * 8;

                        ctx.save();
                        ctx.translate(x, y);
                        ctx.scale(h.runDirection, 1);

                        // Shadow
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.beginPath();
                        ctx.ellipse(0, 2, 22 * deerScale, 6 * deerScale, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Back legs - darker, animated
                        ctx.fillStyle = 'rgb(89, 69, 54)';
                        // Left back leg
                        ctx.beginPath();
                        ctx.moveTo(-12 * deerScale, -12 * deerScale);
                        ctx.lineTo(-10 * deerScale - backLegOffset * 0.5, 0);
                        ctx.lineTo(-7 * deerScale - backLegOffset * 0.5, 0);
                        ctx.lineTo(-8 * deerScale, -12 * deerScale);
                        ctx.closePath();
                        ctx.fill();
                        // Right back leg
                        ctx.beginPath();
                        ctx.moveTo(-8 * deerScale, -12 * deerScale);
                        ctx.lineTo(-6 * deerScale + backLegOffset * 0.5, 0);
                        ctx.lineTo(-3 * deerScale + backLegOffset * 0.5, 0);
                        ctx.lineTo(-4 * deerScale, -12 * deerScale);
                        ctx.closePath();
                        ctx.fill();

                        // Front legs - animated opposite
                        ctx.beginPath();
                        ctx.moveTo(10 * deerScale, -14 * deerScale);
                        ctx.lineTo(8 * deerScale - frontLegOffset * 0.5, 0);
                        ctx.lineTo(5 * deerScale - frontLegOffset * 0.5, 0);
                        ctx.lineTo(6 * deerScale, -14 * deerScale);
                        ctx.closePath();
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(14 * deerScale, -14 * deerScale);
                        ctx.lineTo(12 * deerScale + frontLegOffset * 0.5, 0);
                        ctx.lineTo(9 * deerScale + frontLegOffset * 0.5, 0);
                        ctx.lineTo(10 * deerScale, -14 * deerScale);
                        ctx.closePath();
                        ctx.fill();

                        // Body - horizontal oval
                        ctx.fillStyle = 'rgb(138, 107, 84)';
                        ctx.beginPath();
                        ctx.ellipse(0, -22 * deerScale, 20 * deerScale, 12 * deerScale, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Lighter underside
                        ctx.fillStyle = 'rgb(184, 161, 143)';
                        ctx.beginPath();
                        ctx.ellipse(0, -17 * deerScale, 14 * deerScale, 6 * deerScale, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // White rump patch
                        ctx.fillStyle = 'rgb(245, 240, 232)';
                        ctx.beginPath();
                        ctx.ellipse(-16 * deerScale, -22 * deerScale, 6 * deerScale, 8 * deerScale, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Tail - raised white flag
                        ctx.beginPath();
                        ctx.moveTo(-20 * deerScale, -24 * deerScale);
                        ctx.lineTo(-24 * deerScale, -35 * deerScale);
                        ctx.lineTo(-18 * deerScale, -26 * deerScale);
                        ctx.closePath();
                        ctx.fill();

                        // Neck - angled forward
                        ctx.fillStyle = 'rgb(138, 107, 84)';
                        ctx.beginPath();
                        ctx.moveTo(14 * deerScale, -28 * deerScale);
                        ctx.lineTo(24 * deerScale, -48 * deerScale);
                        ctx.lineTo(18 * deerScale, -48 * deerScale);
                        ctx.lineTo(10 * deerScale, -28 * deerScale);
                        ctx.closePath();
                        ctx.fill();

                        // Head - elongated oval
                        ctx.fillStyle = 'rgb(122, 89, 71)';
                        ctx.beginPath();
                        ctx.ellipse(24 * deerScale, -52 * deerScale, 6 * deerScale, 8 * deerScale, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Snout
                        ctx.fillStyle = 'rgb(107, 74, 56)';
                        ctx.beginPath();
                        ctx.ellipse(30 * deerScale, -50 * deerScale, 4 * deerScale, 3 * deerScale, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Nose
                        ctx.fillStyle = 'rgb(41, 31, 31)';
                        ctx.beginPath();
                        ctx.ellipse(33 * deerScale, -49 * deerScale, 2 * deerScale, 1.5 * deerScale, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Eye
                        ctx.fillStyle = 'rgb(26, 26, 26)';
                        ctx.beginPath();
                        ctx.arc(26 * deerScale, -54 * deerScale, 1.5 * deerScale, 0, Math.PI * 2);
                        ctx.fill();

                        // Ears
                        ctx.fillStyle = 'rgb(138, 107, 84)';
                        ctx.beginPath();
                        ctx.ellipse(20 * deerScale, -62 * deerScale, 3 * deerScale, 6 * deerScale, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.ellipse(28 * deerScale, -60 * deerScale, 3 * deerScale, 5 * deerScale, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Antlers for bucks
                        if (h.isBuck && h.antlerSize && h.antlerSize > 0) {
                            ctx.strokeStyle = 'rgb(89, 74, 59)';
                            ctx.lineWidth = 2.5 * deerScale;
                            ctx.lineCap = 'round';
                            // Left antler
                            ctx.beginPath();
                            ctx.moveTo(22 * deerScale, -60 * deerScale);
                            ctx.lineTo(10 * deerScale, -78 * h.antlerSize * deerScale);
                            ctx.stroke();
                            // Right antler
                            ctx.beginPath();
                            ctx.moveTo(26 * deerScale, -60 * deerScale);
                            ctx.lineTo(38 * deerScale, -78 * h.antlerSize * deerScale);
                            ctx.stroke();
                            // Tines
                            ctx.beginPath();
                            ctx.moveTo(14 * deerScale, -70 * h.antlerSize * deerScale);
                            ctx.lineTo(8 * deerScale, -80 * h.antlerSize * deerScale);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(34 * deerScale, -70 * h.antlerSize * deerScale);
                            ctx.lineTo(42 * deerScale, -80 * h.antlerSize * deerScale);
                            ctx.stroke();
                        }

                        ctx.restore();

                    } else if (h.type === 'debris') {
                        for (let p = 0; p < h.pieces; p++) {
                            const px = x + (p - h.pieces/2) * h.spread * roadW * 0.6;
                            const psize = (14 + Math.random() * 12) * scale;

                            // Shadow
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                            ctx.beginPath();
                            ctx.ellipse(px, y + 2, psize * 1.1, psize * 0.35, 0, 0, Math.PI * 2);
                            ctx.fill();

                            // Debris piece
                            ctx.fillStyle = 'rgb(89, 71, 56)';
                            ctx.beginPath();
                            ctx.ellipse(px, y - psize * 0.35, psize * 0.7, psize * 0.4, 0, 0, Math.PI * 2);
                            ctx.fill();
                        }

                    } else if (h.type === 'log') {
                        const logLen = 80 * scale * h.length;
                        const logRad = 12 * scale;

                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(h.rotation);

                        // Shadow
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
                        ctx.beginPath();
                        ctx.ellipse(4 * scale, 4 * scale, logLen * 0.55, logRad * 0.5, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Log body
                        ctx.fillStyle = 'rgb(89, 71, 51)';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, logLen * 0.5, logRad, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Top highlight
                        ctx.fillStyle = 'rgb(115, 97, 71)';
                        ctx.beginPath();
                        ctx.ellipse(0, -logRad * 0.3, logLen * 0.45, logRad * 0.4, 0, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.restore();
                    }
                }
            }
        }

        // =====================================================================
        // DRAW PLAYER CAR (exact from Lua)
        // =====================================================================
        function drawPlayerCar() {
            const x = W/2 + playerX * 160;
            const y = H - 65 + carBounce;

            // Flash during invincibility
            if (invincibleTimer > 0 && Math.floor(time / 6) % 2 === 1) {
                return;
            }

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(carTilt);

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 42, 50, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tires
            ctx.fillStyle = 'rgb(26, 26, 26)';
            ctx.fillRect(-45, 10, 10, 22);
            ctx.fillRect(35, 10, 10, 22);

            // Car body (Volvo 240 wagon shape)
            ctx.fillStyle = toRGB(COLORS.carBody);
            ctx.beginPath();
            ctx.moveTo(-45, 28);
            ctx.lineTo(-42, -8);
            ctx.lineTo(-38, -35);
            ctx.lineTo(38, -35);
            ctx.lineTo(42, -8);
            ctx.lineTo(45, 28);
            ctx.closePath();
            ctx.fill();

            // Body highlight
            ctx.fillStyle = toRGB(COLORS.carLight);
            ctx.beginPath();
            ctx.moveTo(-45, 28);
            ctx.lineTo(-42, -8);
            ctx.lineTo(-38, -35);
            ctx.lineTo(-20, -35);
            ctx.lineTo(-20, 28);
            ctx.closePath();
            ctx.fill();

            // Rear window
            ctx.fillStyle = toRGB(COLORS.carWindow);
            ctx.fillRect(-28, -32, 56, 20);

            // Window reflection
            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.beginPath();
            ctx.moveTo(-26, -30);
            ctx.lineTo(-26, -15);
            ctx.lineTo(-5, -30);
            ctx.closePath();
            ctx.fill();

            // Taillights
            ctx.fillStyle = 'rgb(255, 51, 51)';
            ctx.fillRect(-42, -8, 6, 28);
            ctx.fillRect(36, -8, 6, 28);

            // Brake light glow
            if (keys.down) {
                ctx.fillStyle = 'rgba(255, 51, 51, 0.5)';
                ctx.beginPath();
                ctx.ellipse(-39, 6, 12, 20, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(39, 6, 12, 20, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Chrome bumper
            ctx.fillStyle = toRGB(COLORS.carChrome);
            ctx.fillRect(-42, 22, 84, 5);

            // License plate
            ctx.fillStyle = 'rgb(247, 247, 247)';
            ctx.fillRect(-18, 3, 36, 14);
            ctx.fillStyle = 'rgb(196, 31, 59)';
            ctx.fillRect(-18, 3, 36, 2);

            ctx.restore();
        }

        // =====================================================================
        // DRAW UI (exact from Lua)
        // =====================================================================
        function drawUI() {
            // Distance progress
            const progress = Math.min(1, distance / GOAL_DISTANCE);

            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(20, 12, 160, 24);

            ctx.fillStyle = 'rgb(245, 240, 224)';
            ctx.font = "bold 11px 'Helvetica Neue', Helvetica, Arial, sans-serif";
            ctx.textAlign = 'left';
            ctx.fillText('SEA RANCH', 28, 28);

            // Progress bar
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(100, 18, 70, 10);
            ctx.fillStyle = 'rgb(128, 209, 128)';
            ctx.fillRect(100, 18, 70 * progress, 10);

            // Car condition
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(W - 85, 10, 70, 28);

            ctx.fillStyle = 'rgb(245, 240, 224)';
            ctx.font = "bold 9px 'Helvetica Neue', Helvetica, Arial, sans-serif";
            ctx.textAlign = 'center';
            ctx.fillText('CAR', W - 50, 22);

            // Damage indicators
            const remaining = MAX_DAMAGE - damage;
            for (let i = 0; i < MAX_DAMAGE; i++) {
                const arcX = W - 68 + i * 18;
                const arcY = 30;

                if (i < remaining) {
                    ctx.fillStyle = 'rgb(46, 92, 168)';
                    ctx.beginPath();
                    ctx.arc(arcX, arcY, 6, Math.PI, 0);
                    ctx.fill();
                } else {
                    ctx.strokeStyle = 'rgb(196, 30, 58)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(arcX - 4, arcY - 4);
                    ctx.lineTo(arcX + 4, arcY + 4);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(arcX + 4, arcY - 4);
                    ctx.lineTo(arcX - 4, arcY + 4);
                    ctx.stroke();
                }
            }

            // Control hints
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.font = "bold 10px 'Helvetica Neue', Helvetica, Arial, sans-serif";
            ctx.textAlign = 'center';
            ctx.fillText('D-PAD: STEER   B: MENU', W/2, 470);
        }

        // =====================================================================
        // DRAW WIN SCREEN
        // =====================================================================
        function drawWinScreen() {
            SeaRanchStyle.drawWinScreen(ctx, 'Welcome to Sea Ranch!', hazardsDodged + ' close calls');
        }

        // =====================================================================
        // DRAW LOSE SCREEN
        // =====================================================================
        function drawLoseScreen() {
            SeaRanchStyle.drawLoseScreen(ctx, 'CAR TROUBLE', 'Too much damage');
        }

        // =====================================================================
        // MAIN RENDER
        // =====================================================================
        function render() {
            ctx.save();
            SeaRanchStyle.applyShake(ctx);

            drawSky();
            drawCliffs();
            drawOcean();
            drawLand();
            drawRoad();
            drawFencePosts();
            drawGrass();
            drawCypressTrees();
            drawHazards();
            drawPlayerCar();

            ctx.restore();

            if (gameState === 'win') {
                drawWinScreen();
            } else if (gameState === 'lose') {
                drawLoseScreen();
            } else {
                drawUI();
            }

            SeaRanchStyle.updateJuice(ctx);
        }

        // =====================================================================
        // GAME LOOP
        // =====================================================================
        let lastTime = performance.now();

        function gameLoop(now) {
            const dt = Math.min(0.05, (now - lastTime) / 1000);
            lastTime = now;

            if (gameState === 'title') {
                // Title card handled by HTML
                update(dt);
            } else {
                update(dt);
                render();
            }

            // Film grain for consistent aesthetic
            if (gameState !== 'title') {
                SeaRanchStyle.applyWeatheredEffect(ctx, { grainOpacity: 0.06, vignetteIntensity: 0.12 });
            }

            requestAnimationFrame(gameLoop);
        }

        SeaRanchStyle.setupTouchControls();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
