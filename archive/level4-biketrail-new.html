<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sea Ranch Quest - Naturalist Trail</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            touch-action: none;
        }
        #gameContainer {
            position: relative;
            width: 640px;
            height: 480px;
        }
        #gameCanvas {
            display: block;
            background: #2a2a2a;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #controls {
            display: block;
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            padding: 10px;
        }
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 640px;
            margin: 0 auto;
        }
        .dpad {
            position: relative;
            width: 120px;
            height: 120px;
        }
        .dpad-btn {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 8px;
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
        }
        .dpad-up { top: 0; left: 40px; }
        .dpad-down { bottom: 0; left: 40px; }
        .dpad-left { top: 40px; left: 0; }
        .dpad-right { top: 40px; right: 0; }
        .action-btns {
            display: flex;
            gap: 15px;
        }
        .action-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.5);
            color: white;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
        }
        .btn-a { background: rgba(46,139,87,0.6); }
        .btn-b { background: rgba(178,34,34,0.6); }
        @media (max-width: 768px) {
            #gameContainer { width: 100vw; height: 75vw; max-height: 480px; }
            #gameCanvas { width: 100%; height: 100%; }
            #controls { display: block; }
        }

        /* Sea Ranch Design System - Title Card */
        :root {
            --red: #C41E3A;
            --blue: #2E5DA8;
            --black: #1a1a1a;
            --cream: #f5f5f0;
            --fog: #e8e4dc;
            --wood: #8b7355;
            --wood-light: #a89070;
            --sand: #d4c4a8;
        }

        .title-card {
            position: absolute;
            inset: 0;
            z-index: 200;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            overflow: hidden;
        }

        .title-card .wood-bg {
            position: absolute;
            inset: 0;
            background:
                repeating-linear-gradient(90deg, transparent 0px, transparent 3px, rgba(139, 115, 85, 0.08) 3px, rgba(139, 115, 85, 0.08) 4px),
                radial-gradient(ellipse at 20% 30%, rgba(139, 115, 85, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 70% 60%, rgba(139, 115, 85, 0.1) 0%, transparent 40%),
                radial-gradient(ellipse at 40% 80%, rgba(139, 115, 85, 0.12) 0%, transparent 45%),
                linear-gradient(180deg, var(--fog) 0%, var(--sand) 100%);
        }

        .title-card .supergraphic {
            position: absolute;
            top: -80px;
            right: -120px;
            width: 550px;
            height: 550px;
            pointer-events: none;
        }

        .title-card .supergraphic::before,
        .title-card .supergraphic::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            border: 36px solid var(--blue);
        }

        .title-card .supergraphic::before {
            width: 420px;
            height: 420px;
            top: 0;
            right: 0;
            border-color: transparent transparent var(--blue) var(--blue);
            transform: rotate(-45deg);
        }

        .title-card .supergraphic::after {
            width: 320px;
            height: 320px;
            top: 50px;
            right: 50px;
            border-color: transparent transparent var(--blue) var(--blue);
            transform: rotate(-45deg);
            opacity: 0.7;
        }

        .title-card .arrow-accent {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 80px;
            height: 100px;
            pointer-events: none;
        }

        .title-card .arrow-accent::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 40px solid transparent;
            border-right: 40px solid transparent;
            border-bottom: 50px solid var(--red);
            top: 0;
        }

        .title-card .arrow-accent::after {
            content: '';
            position: absolute;
            width: 26px;
            height: 50px;
            background: var(--red);
            top: 45px;
            left: 27px;
        }

        .title-card .title-content {
            position: relative;
            z-index: 10;
            text-align: center;
            padding-top: 160px;
        }

        .title-card .level-title {
            font-size: 56px;
            font-weight: 700;
            color: var(--black);
            letter-spacing: -1px;
            line-height: 1;
        }

        .title-card .level-subtitle {
            font-size: 18px;
            font-weight: 400;
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-top: 12px;
            color: var(--wood);
        }

        .title-card .continue-hint {
            position: absolute;
            bottom: 36px;
            right: 36px;
            font-size: 11px;
            color: var(--wood-light);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .title-card .title-grain {
            position: absolute;
            inset: 0;
            opacity: 0.4;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- HTML/CSS Title Card matching levels 1-3 -->
        <div class="title-card" id="title-card">
            <div class="wood-bg"></div>
            <div class="supergraphic"></div>
            <div class="arrow-accent"></div>
            <div class="title-content">
                <div class="level-title">Naturalist Trail</div>
                <div class="level-subtitle">A 10-Mile Photo Journey</div>
            </div>
            <div class="continue-hint">A to start Â· B to menu</div>
            <div class="title-grain"></div>
        </div>

        <canvas id="gameCanvas" width="640" height="480"></canvas>
    </div>
    <div id="controls">
        <div class="control-row">
            <div class="dpad">
                <button class="dpad-btn dpad-up" data-key="up">&#9650;</button>
                <button class="dpad-btn dpad-down" data-key="down">&#9660;</button>
                <button class="dpad-btn dpad-left" data-key="left">&#9664;</button>
                <button class="dpad-btn dpad-right" data-key="right">&#9654;</button>
            </div>
            <div class="action-btns">
                <button class="action-btn btn-b" data-key="b">B</button>
                <button class="action-btn btn-a" data-key="a">A</button>
            </div>
        </div>
    </div>

    <script>
    // Sea Ranch Quest - Level 4: Naturalist Trail
    // Wildlife observation along the Bluff Trail - 10 stops, 10 species
    // Faithful HTML/JavaScript conversion from Love2D

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const W = 640, H = 480;

    // Constants
    const BINOCULAR_RADIUS = 85;
    const PHOTO_TIME_LIMIT = 15;
    const BIKE_DURATION = 3.5;
    const DEPARTURE_DURATION = 3.5;

    // Colors - Sea Ranch pixel art palette
    const COLORS = {
        skyLight: 'rgb(135,206,235)',
        skyMid: 'rgb(92,163,199)',
        oceanDeep: 'rgb(26,74,89)',
        oceanMid: 'rgb(41,107,122)',
        oceanLight: 'rgb(74,153,171)',
        grass: 'rgb(122,171,89)',
        grassLight: 'rgb(153,199,102)',
        grassDark: 'rgb(89,138,74)',
        wood: 'rgb(138,112,89)',
        woodDark: 'rgb(107,79,64)',
        sand: 'rgb(217,199,168)',
        cream: 'rgb(245,245,240)',
        superBlue: 'rgb(46,92,168)',
        superRed: 'rgb(196,31,59)'
    };

    // 10 Stops with wildlife and locations
    const STOPS = [
        {name: "Sea Ranch Lodge", wildlife: "Black Phoebe", latin: "Sayornis nigricans",
         fact: "Bobs its tail constantly while perched - unique among flycatchers!", habitat: "meadow", shortName: "LODGE"},
        {name: "Airstrip", wildlife: "Red-tailed Hawk", latin: "Buteo jamaicensis",
         fact: "Can spot a mouse from 100 feet in the air!", habitat: "grassland", shortName: "AIRSTRP"},
        {name: "Ohlson Rec Center", wildlife: "Western Fence Lizard", latin: "Sceloporus occidentalis",
         fact: "Blue belly markings help regulate body temperature!", habitat: "coastal", shortName: "OHLSON"},
        {name: "Sea Ranch Chapel", wildlife: "Anna's Hummingbird", latin: "Calypte anna",
         fact: "Can fly backwards and hover in place like a helicopter!", habitat: "forest-edge", shortName: "CHAPEL"},
        {name: "One Eyed Jack's", wildlife: "Acorn Woodpecker", latin: "Melanerpes formicivorus",
         fact: "Stores thousands of acorns in 'granary trees'!", habitat: "cypress-forest", shortName: "JACKS"},
        {name: "Walk On Beach", wildlife: "Black Oystercatcher", latin: "Haematopus bachmani",
         fact: "Uses its bright red bill to pry open mussels!", habitat: "bluff", shortName: "BEACH"},
        {name: "Del Mar Rec Center", wildlife: "Monarch Butterfly", latin: "Danaus plexippus",
         fact: "Migrates up to 3,000 miles each year!", habitat: "meadow", shortName: "DELMAR"},
        {name: "Salal Trail Waterfall", wildlife: "Rough-skinned Newt", latin: "Taricha granulosa",
         fact: "Has enough toxin to deter most predators!", habitat: "redwood-forest", shortName: "SALAL"},
        {name: "Gualala Point Park", wildlife: "Great Blue Heron", latin: "Ardea herodias",
         fact: "Can stand motionless for hours waiting for fish!", habitat: "estuary", shortName: "GUALALA"},
        {name: "Driftwood Beach", wildlife: "Harbor Seal", latin: "Phoca vitulina",
         fact: "Can hold its breath for up to 30 minutes!", habitat: "beach", shortName: "DRFTWOD"}
    ];

    // Wildlife behavior settings per species
    const WILDLIFE_BEHAVIORS = [
        {shyness: 0.6, fidget: 0.06},  // Black Phoebe
        {shyness: 0.35, fidget: 0.02}, // Hawk (soaring)
        {shyness: 0.9, fidget: 0.12},  // Lizard (skittish)
        {shyness: 0.95, fidget: 0.15}, // Hummingbird (very quick)
        {shyness: 0.6, fidget: 0.05},  // Woodpecker
        {shyness: 0.75, fidget: 0.04}, // Oystercatcher
        {shyness: 0.8, fidget: 0.10},  // Butterfly (fluttery)
        {shyness: 0.55, fidget: 0.03}, // Newt (slow)
        {shyness: 0.65, fidget: 0.02}, // Heron (patient)
        {shyness: 0.4, fidget: 0.01}   // Seal (lazy)
    ];

    // Wildlife starting positions
    const WILDLIFE_POSITIONS = [
        {x: 120, y: 280},  // Phoebe on fence
        {x: 400, y: 100},  // Hawk soaring
        {x: 500, y: 350},  // Lizard on rocks
        {x: 320, y: 200},  // Hummingbird near flowers
        {x: 180, y: 220},  // Woodpecker on tree
        {x: 300, y: 180},  // Oystercatcher on rocks
        {x: 220, y: 260},  // Butterfly near trees
        {x: 320, y: 320},  // Newt near stream
        {x: 420, y: 300},  // Heron in shallows
        {x: 380, y: 380}   // Seal on beach
    ];

    // Game state
    let gameState = "title";
    let currentStop = 0;
    let time = 0;
    let scores = [];

    // Departure scene state
    let departureTimer = 0;

    // Photo mode state
    let photoTimer = 0;
    let photoTaken = false;
    let photoScore = 0;

    // Binocular state
    let binocularsRaised = false;
    let binocularProgress = 0;
    let focusX = W/2, focusY = H/2;

    // Wildlife state
    let wildlife = {
        x: 0, y: 0,
        vx: 0, vy: 0,
        homeX: 0, homeY: 0,
        targetX: 0, targetY: 0,
        behavior: "wander",
        animFrame: 0,
        restTimer: 0,
        fleeTimer: 0,
        energy: 1.0
    };

    // Biking cutscene
    let bikeProgress = 0;
    let bikeRoadOffset = 0;

    // Shake effect
    let shakeAmount = 0;
    let shakeX = 0, shakeY = 0;

    // Input handling
    const keys = {};
    const keysJustPressed = {};

    // Image assets (will be loaded)
    let lodgeImage = null;
    let cyclistImage = null;
    let postImage = null;
    let sceneImages = [];
    let imagesLoaded = 0;
    let totalImages = 13;

    // Load images
    function loadImage(src) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                imagesLoaded++;
                resolve(img);
            };
            img.onerror = () => {
                imagesLoaded++;
                resolve(null);
            };
            img.src = src;
        });
    }

    async function loadAssets() {
        // For now, use external image paths - these would be base64 embedded in production
        lodgeImage = await loadImage('assets/level04/lodge.jpg');
        cyclistImage = await loadImage('assets/level04/cyclist.png');
        postImage = await loadImage('assets/level04/post-sprite.png');

        for (let i = 1; i <= 10; i++) {
            sceneImages[i-1] = await loadImage(`assets/level04/scene-${i}-chunky.png`);
        }
    }

    // Input handlers
    document.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        if (!keys[key]) {
            keysJustPressed[key] = true;
        }
        keys[key] = true;

        // Map arrow keys to directions
        if (e.key === 'ArrowUp') { keys['up'] = true; if (!keys['arrowup']) keysJustPressed['up'] = true; }
        if (e.key === 'ArrowDown') { keys['down'] = true; if (!keys['arrowdown']) keysJustPressed['down'] = true; }
        if (e.key === 'ArrowLeft') { keys['left'] = true; if (!keys['arrowleft']) keysJustPressed['left'] = true; }
        if (e.key === 'ArrowRight') { keys['right'] = true; if (!keys['arrowright']) keysJustPressed['right'] = true; }
        if (e.key === ' ' || key === 'z' || key === 'enter') { keys['a'] = true; keysJustPressed['a'] = true; }
        if (key === 'x' || key === 'escape') { keys['b'] = true; keysJustPressed['b'] = true; }
    });

    document.addEventListener('keyup', (e) => {
        const key = e.key.toLowerCase();
        keys[key] = false;
        if (e.key === 'ArrowUp') keys['up'] = false;
        if (e.key === 'ArrowDown') keys['down'] = false;
        if (e.key === 'ArrowLeft') keys['left'] = false;
        if (e.key === 'ArrowRight') keys['right'] = false;
        if (e.key === ' ' || key === 'z' || key === 'enter') keys['a'] = false;
        if (key === 'x' || key === 'escape') keys['b'] = false;
    });

    // Mobile touch controls AND mouse clicks
    document.querySelectorAll('.dpad-btn, .action-btn').forEach(btn => {
        const key = btn.dataset.key;

        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys[key] = true;
            keysJustPressed[key] = true;
        });

        btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys[key] = false;
        });

        btn.addEventListener('mousedown', (e) => {
            e.preventDefault();
            keys[key] = true;
            keysJustPressed[key] = true;
        });

        btn.addEventListener('mouseup', (e) => {
            e.preventDefault();
            keys[key] = false;
        });

        btn.addEventListener('mouseleave', (e) => {
            keys[key] = false;
        });
    });

    function justPressed(key) {
        return keysJustPressed[key] || false;
    }

    function isDown(key) {
        return keys[key] || false;
    }

    // Initialize photo mode
    function initPhotoMode() {
        photoTimer = PHOTO_TIME_LIMIT;
        photoTaken = false;
        photoScore = 0;
        binocularsRaised = false;
        binocularProgress = 0;
        focusX = W/2;
        focusY = H/2;

        const pos = WILDLIFE_POSITIONS[currentStop];
        wildlife.x = pos.x;
        wildlife.y = pos.y;
        wildlife.homeX = pos.x;
        wildlife.homeY = pos.y;
        wildlife.targetX = pos.x;
        wildlife.targetY = pos.y;
        wildlife.vx = 0;
        wildlife.vy = 0;
        wildlife.behavior = "wander";
        wildlife.animFrame = 0;
        wildlife.restTimer = 0;
        wildlife.fleeTimer = 0;
        wildlife.energy = 1.0;
    }

    function updateWildlife(dt) {
        const behavior = WILDLIFE_BEHAVIORS[currentStop];
        wildlife.animFrame += dt * 6;

        // Random fidgeting
        if (Math.random() < behavior.fidget) {
            wildlife.vx += (Math.random() - 0.5) * 4;
            wildlife.vy += (Math.random() - 0.5) * 3;
        }

        // Rest timer
        if (wildlife.restTimer > 0) {
            wildlife.restTimer -= dt;
            wildlife.x += Math.sin(time * 0.5) * 0.3;
            wildlife.y += Math.cos(time * 0.4) * 0.2;
            return;
        }

        // Flee timer
        if (wildlife.fleeTimer > 0) {
            wildlife.fleeTimer -= dt;
        }

        // Camera reaction (binoculars)
        const dx = focusX - wildlife.x;
        const dy = focusY - wildlife.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const cameraOnUs = dist < 80;

        if (binocularsRaised && binocularProgress > 0.5 && cameraOnUs && wildlife.fleeTimer <= 0) {
            if (Math.random() < behavior.shyness * 0.15 * dt * 60) {
                wildlife.behavior = "flee";
                wildlife.fleeTimer = 0.75 + Math.random() * 1.25;

                const fleeAngle = Math.atan2(wildlife.y - focusY, wildlife.x - focusX);
                const fleeDist = 30 + Math.random() * 40;
                wildlife.targetX = wildlife.x + Math.cos(fleeAngle) * fleeDist;
                wildlife.targetY = wildlife.y + Math.sin(fleeAngle) * fleeDist;
                wildlife.targetX = Math.max(60, Math.min(580, wildlife.targetX));
                wildlife.targetY = Math.max(80, Math.min(380, wildlife.targetY));
            }
        }

        // Behavior execution
        if (wildlife.behavior === "flee") {
            wildlife.vx += (wildlife.targetX - wildlife.x) * 0.15;
            wildlife.vy += (wildlife.targetY - wildlife.y) * 0.15;
            wildlife.x += wildlife.vx * dt * 60;
            wildlife.y += wildlife.vy * dt * 60;
            wildlife.vx *= 0.85;
            wildlife.vy *= 0.85;

            const distToTarget = Math.sqrt(Math.pow(wildlife.targetX - wildlife.x, 2) + Math.pow(wildlife.targetY - wildlife.y, 2));
            if (distToTarget < 10 || wildlife.fleeTimer <= 0) {
                wildlife.behavior = "rest";
                wildlife.restTimer = 0.5 + Math.random();
                wildlife.energy *= 0.7;
                wildlife.vx = 0;
                wildlife.vy = 0;
            }
        } else if (wildlife.behavior === "rest") {
            if (wildlife.restTimer <= 0) {
                wildlife.behavior = "wander";
            }
        } else { // wander
            if (Math.random() < 0.02) {
                wildlife.targetX = wildlife.homeX + (Math.random() - 0.5) * 60;
                wildlife.targetY = wildlife.homeY + (Math.random() - 0.5) * 40;
            }
            wildlife.vx += (wildlife.targetX - wildlife.x) * 0.02;
            wildlife.vy += (wildlife.targetY - wildlife.y) * 0.02;
            wildlife.x += wildlife.vx * dt * 60;
            wildlife.y += wildlife.vy * dt * 60;
            wildlife.vx *= 0.95;
            wildlife.vy *= 0.95;
        }

        wildlife.energy = Math.min(1.0, wildlife.energy + dt * 0.1);
    }

    function takePhoto() {
        if (photoTaken) return;
        photoTaken = true;
        photoTimer = 0;

        const dist = Math.sqrt(Math.pow(wildlife.x - focusX, 2) + Math.pow(wildlife.y - focusY, 2));

        if (dist < BINOCULAR_RADIUS * 0.35) {
            photoScore = 3; // Excellent
        } else if (dist < BINOCULAR_RADIUS * 0.6) {
            photoScore = 2; // Good
        } else if (dist < BINOCULAR_RADIUS) {
            photoScore = 1; // Glimpse
        } else {
            photoScore = 0; // Missed
            shake(8);
        }

        scores[currentStop] = photoScore;
    }

    function shake(amount) {
        shakeAmount = amount;
    }

    function saveCompletion(level) {
        try {
            let completed = JSON.parse(localStorage.getItem('seaRanchQuestCompleted') || '[]');
            if (!completed.includes(level)) {
                completed.push(level);
                localStorage.setItem('seaRanchQuestCompleted', JSON.stringify(completed));
            }
        } catch(e) {}
    }

    // Update function
    function update(dt) {
        // Update shake
        if (shakeAmount > 0) {
            shakeX = (Math.random() - 0.5) * shakeAmount;
            shakeY = (Math.random() - 0.5) * shakeAmount;
            shakeAmount *= 0.9;
            if (shakeAmount < 0.5) shakeAmount = 0;
        } else {
            shakeX = 0;
            shakeY = 0;
        }

        if (gameState === "title") {
            if (justPressed('a')) {
                document.getElementById('title-card').style.display = 'none';
                gameState = "departure";
                departureTimer = 0;
                initPhotoMode();
            }
            if (justPressed('b')) {
                window.location.href = 'level0-menu.html';
            }
            return;
        }

        time += dt;

        if (gameState === "complete") {
            if (justPressed('a')) {
                gameState = "title";
                currentStop = 0;
                scores = [];
                time = 0;
            }
            if (justPressed('b')) {
                window.location.href = 'index.html';
            }
            return;
        }

        if (gameState === "results") {
            if (justPressed('a')) {
                currentStop++;
                if (currentStop >= STOPS.length) {
                    gameState = "complete";
                    saveCompletion(4);
                } else {
                    gameState = "biking";
                    bikeProgress = 0;
                }
            }
            if (justPressed('b')) {
                window.location.href = 'index.html';
            }
            return;
        }

        if (gameState === "departure") {
            departureTimer += dt;
            if (departureTimer >= DEPARTURE_DURATION) {
                gameState = "photo";
                initPhotoMode();
            }
            if (justPressed('b')) {
                window.location.href = 'index.html';
            }
            return;
        }

        if (gameState === "biking") {
            bikeProgress += dt;
            bikeRoadOffset = (bikeRoadOffset + dt * 100) % 80;
            if (bikeProgress >= BIKE_DURATION) {
                gameState = "photo";
                initPhotoMode();
            }
            if (justPressed('b')) {
                window.location.href = 'index.html';
            }
            return;
        }

        if (gameState === "photo") {
            // Binocular lift animation
            if (binocularsRaised) {
                binocularProgress = Math.min(1, binocularProgress + dt * 8);
            } else {
                binocularProgress = Math.max(0, binocularProgress - dt * 8);
            }

            // Focus movement (D-pad when binoculars raised)
            if (binocularsRaised && binocularProgress > 0.3) {
                const speed = 200 * dt;
                if (isDown('left')) focusX -= speed;
                if (isDown('right')) focusX += speed;
                if (isDown('up')) focusY -= speed;
                if (isDown('down')) focusY += speed;
                focusX = Math.max(100, Math.min(540, focusX));
                focusY = Math.max(100, Math.min(380, focusY));
            }

            // A button: raise binoculars or take photo
            if (justPressed('a')) {
                if (!binocularsRaised) {
                    binocularsRaised = true;
                } else if (!photoTaken && binocularProgress > 0.3) {
                    takePhoto();
                }
            }

            // B button: return to menu
            if (justPressed('b')) {
                window.location.href = 'index.html';
            }

            // Update wildlife
            updateWildlife(dt);

            // Timer
            if (!photoTaken) {
                photoTimer -= dt;
                if (photoTimer <= 0) {
                    photoTaken = true;
                    photoScore = 0;
                    scores[currentStop] = 0;
                    shake(10);
                }
            } else {
                if (photoTimer < -0.5) {
                    gameState = "results";
                } else {
                    photoTimer -= dt;
                }
            }
        }
    }

    // Drawing functions
    function drawHabitatBackground() {
        const sceneImg = sceneImages[currentStop];

        if (sceneImg) {
            const imgW = sceneImg.width, imgH = sceneImg.height;
            const imgAspect = imgW / imgH;
            const canvasAspect = W / H;

            let drawW, drawH, drawX, drawY;
            if (imgAspect > canvasAspect) {
                drawH = H;
                drawW = H * imgAspect;
                drawX = (W - drawW) / 2;
                drawY = 0;
            } else {
                drawW = W;
                drawH = W / imgAspect;
                drawX = 0;
                drawY = (H - drawH) / 2;
            }
            ctx.drawImage(sceneImg, drawX, drawY, drawW, drawH);
        } else {
            // Fallback procedural background
            const stop = STOPS[currentStop];
            const habitat = stop.habitat;

            // Sky
            ctx.fillStyle = COLORS.skyLight;
            ctx.fillRect(0, 0, W, 180);

            if (habitat === "meadow" || habitat === "grassland") {
                ctx.fillStyle = COLORS.grass;
                ctx.fillRect(0, 180, W, H - 180);
            } else if (habitat === "coastal" || habitat === "bluff") {
                ctx.fillStyle = COLORS.oceanMid;
                ctx.fillRect(0, 180, W, 80);
                ctx.fillStyle = COLORS.grassDark;
                ctx.fillRect(0, 260, W, H - 260);
            } else if (habitat === "cypress-forest" || habitat === "redwood-forest") {
                ctx.fillStyle = 'rgb(38,64,51)';
                ctx.fillRect(0, 100, W, H - 100);
            } else if (habitat === "estuary") {
                ctx.fillStyle = COLORS.oceanLight;
                ctx.fillRect(0, 200, W, 100);
                ctx.fillStyle = COLORS.grassDark;
                ctx.fillRect(0, 300, W, H - 300);
            } else if (habitat === "beach") {
                ctx.fillStyle = COLORS.oceanMid;
                ctx.fillRect(0, 150, W, 100);
                ctx.fillStyle = COLORS.sand;
                ctx.fillRect(0, 250, W, H - 250);
            } else {
                ctx.fillStyle = COLORS.grass;
                ctx.fillRect(0, 180, W, H - 180);
            }
        }
    }

    function drawWildlife() {
        const wx = wildlife.x, wy = wildlife.y;
        ctx.save();
        ctx.translate(wx, wy);

        if (currentStop === 0) { // Black Phoebe
            const tailBob = Math.sin(time * 4) * 3;

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(2, 18, 15, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tail (bobbing!)
            ctx.save();
            ctx.translate(10, 2);
            ctx.rotate(tailBob * 0.08);
            ctx.fillStyle = 'rgb(26,26,26)';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(18, -2);
            ctx.lineTo(20, 2);
            ctx.lineTo(18, 4);
            ctx.lineTo(0, 3);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            // Body
            ctx.fillStyle = 'rgb(26,26,26)';
            ctx.beginPath();
            ctx.ellipse(0, 0, 12, 9, 0, 0, Math.PI * 2);
            ctx.fill();

            // White belly
            ctx.fillStyle = 'rgb(232,232,232)';
            ctx.beginPath();
            ctx.ellipse(0, 4, 7, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wing
            ctx.fillStyle = 'rgb(41,41,41)';
            ctx.beginPath();
            ctx.ellipse(2, -2, 9, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = 'rgb(26,26,26)';
            ctx.beginPath();
            ctx.arc(-8, -6, 7, 0, Math.PI * 2);
            ctx.fill();

            // Small crest
            ctx.beginPath();
            ctx.moveTo(-10, -12);
            ctx.lineTo(-7, -13);
            ctx.lineTo(-6, -10);
            ctx.closePath();
            ctx.fill();

            // Beak
            ctx.fillStyle = 'rgb(41,41,41)';
            ctx.beginPath();
            ctx.moveTo(-14, -6);
            ctx.lineTo(-20, -5);
            ctx.lineTo(-14, -4);
            ctx.closePath();
            ctx.fill();

            // Eye
            ctx.fillStyle = 'rgb(26,26,26)';
            ctx.beginPath();
            ctx.arc(-10, -7, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-10.5, -7.5, 0.8, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.strokeStyle = 'rgb(41,41,41)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(-2, 8);
            ctx.lineTo(-3, 16);
            ctx.moveTo(3, 8);
            ctx.lineTo(4, 16);
            ctx.stroke();

        } else if (currentStop === 1) { // Red-tailed Hawk
            const soar = Math.sin(time * 0.5);
            const wingAngle = soar * 0.15;

            ctx.rotate(soar * 0.05);

            // Left wing
            ctx.save();
            ctx.rotate(-wingAngle);
            ctx.fillStyle = 'rgb(89,64,48)';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-30, -8);
            ctx.lineTo(-50, 5);
            ctx.lineTo(-30, 8);
            ctx.lineTo(0, 5);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            // Right wing
            ctx.save();
            ctx.rotate(wingAngle);
            ctx.fillStyle = 'rgb(89,64,48)';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(30, -8);
            ctx.lineTo(50, 5);
            ctx.lineTo(30, 8);
            ctx.lineTo(0, 5);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            // Body
            ctx.fillStyle = 'rgb(107,79,64)';
            ctx.beginPath();
            ctx.ellipse(0, 3, 8, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = 'rgb(122,97,79)';
            ctx.beginPath();
            ctx.arc(-12, 2, 6, 0, Math.PI * 2);
            ctx.fill();

            // Beak
            ctx.fillStyle = 'rgb(59,48,48)';
            ctx.beginPath();
            ctx.moveTo(-17, 1);
            ctx.lineTo(-22, 3);
            ctx.lineTo(-17, 4);
            ctx.closePath();
            ctx.fill();

            // Red tail
            ctx.fillStyle = 'rgb(166,74,48)';
            ctx.beginPath();
            ctx.moveTo(8, 0);
            ctx.lineTo(25, -3);
            ctx.lineTo(28, 3);
            ctx.lineTo(25, 8);
            ctx.lineTo(8, 5);
            ctx.closePath();
            ctx.fill();

            // Eye
            ctx.fillStyle = 'rgb(255,204,0)';
            ctx.beginPath();
            ctx.arc(-13, 1, 1.5, 0, Math.PI * 2);
            ctx.fill();

        } else if (currentStop === 2) { // Western Fence Lizard
            const pushUp = Math.sin(time * 2) * 3;
            const breathing = Math.sin(time * 1.5) * 0.5;

            ctx.translate(0, pushUp);

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(2, 8 - pushUp, 20, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tail
            ctx.fillStyle = 'rgb(89,79,64)';
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.lineTo(35, -2);
            ctx.lineTo(50, 5);
            ctx.lineTo(35, 8);
            ctx.lineTo(15, 3);
            ctx.closePath();
            ctx.fill();

            // Back legs
            ctx.fillStyle = 'rgb(89,79,64)';
            ctx.beginPath();
            ctx.moveTo(10, 2);
            ctx.lineTo(18, 10);
            ctx.lineTo(25, 12);
            ctx.lineTo(18, 8);
            ctx.lineTo(10, 4);
            ctx.closePath();
            ctx.fill();

            // Body
            ctx.fillStyle = 'rgb(107,97,79)';
            ctx.beginPath();
            ctx.ellipse(0, 0, 18, 8 + breathing, 0, 0, Math.PI * 2);
            ctx.fill();

            // Blue belly patches
            if (pushUp > 1) {
                ctx.fillStyle = 'rgb(74,122,171)';
                ctx.beginPath();
                ctx.ellipse(-5, 5, 6, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(5, 5, 6, 3, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Front legs
            ctx.fillStyle = 'rgb(89,79,64)';
            ctx.beginPath();
            ctx.moveTo(-12, 0);
            ctx.lineTo(-20, 6 - pushUp * 0.5);
            ctx.lineTo(-25, 4 - pushUp * 0.5);
            ctx.lineTo(-20, 4 - pushUp * 0.5);
            ctx.lineTo(-12, 2);
            ctx.closePath();
            ctx.fill();

            // Head
            ctx.fillStyle = 'rgb(107,97,79)';
            ctx.beginPath();
            ctx.ellipse(-18, -1, 8, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eye
            ctx.fillStyle = 'rgb(26,26,26)';
            ctx.beginPath();
            ctx.arc(-22, -2, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgb(255,214,0)';
            ctx.beginPath();
            ctx.arc(-22.5, -2.5, 0.8, 0, Math.PI * 2);
            ctx.fill();

        } else if (currentStop === 3) { // Anna's Hummingbird
            const hover = Math.sin(time * 6) * 3;

            ctx.translate(0, hover);

            // Wing blur
            ctx.fillStyle = 'rgba(99,120,99,0.4)';
            ctx.beginPath();
            ctx.ellipse(-8, 0, 15, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(8, 0, 15, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tail
            ctx.fillStyle = 'rgb(59,74,59)';
            ctx.beginPath();
            ctx.moveTo(0, 8);
            ctx.lineTo(-5, 22);
            ctx.lineTo(0, 20);
            ctx.lineTo(5, 22);
            ctx.lineTo(0, 8);
            ctx.closePath();
            ctx.fill();

            // Body
            ctx.fillStyle = 'rgb(74,89,74)';
            ctx.beginPath();
            ctx.ellipse(0, 5, 6, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Lighter belly
            ctx.fillStyle = 'rgb(122,138,122)';
            ctx.beginPath();
            ctx.ellipse(0, 8, 4, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = 'rgb(59,74,59)';
            ctx.beginPath();
            ctx.arc(0, -6, 6, 0, Math.PI * 2);
            ctx.fill();

            // Gorget - iridescent magenta
            const shimmer = Math.sin(time * 1.5) * 0.3 + 0.7;
            ctx.fillStyle = `rgb(${Math.floor(219*shimmer)},${Math.floor(51*shimmer)},${Math.floor(99*shimmer)})`;
            ctx.beginPath();
            ctx.ellipse(0, -3, 5, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Crown
            ctx.fillStyle = `rgb(${Math.floor(199*shimmer)},${Math.floor(41*shimmer)},${Math.floor(89*shimmer)})`;
            ctx.beginPath();
            ctx.ellipse(0, -9, 4, 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Beak
            ctx.strokeStyle = 'rgb(26,26,26)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(0, -6);
            ctx.lineTo(-18, -8);
            ctx.stroke();

            // Eye
            ctx.fillStyle = 'rgb(26,26,26)';
            ctx.beginPath();
            ctx.arc(3, -7, 1.5, 0, Math.PI * 2);
            ctx.fill();

        } else if (currentStop === 4) { // Acorn Woodpecker
            const headBob = Math.sin(time * 2.5) * 2;

            // Tail
            ctx.fillStyle = 'rgb(26,26,26)';
            ctx.beginPath();
            ctx.moveTo(5, 10);
            ctx.lineTo(0, 28);
            ctx.lineTo(10, 28);
            ctx.lineTo(10, 10);
            ctx.closePath();
            ctx.fill();

            // Body
            ctx.beginPath();
            ctx.ellipse(5, 5, 10, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // White rump patch
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.ellipse(5, 12, 6, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wing
            ctx.fillStyle = 'rgb(41,41,41)';
            ctx.beginPath();
            ctx.ellipse(8, 5, 8, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.ellipse(12, 8, 3, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.save();
            ctx.translate(0, headBob);

            ctx.fillStyle = 'rgb(26,26,26)';
            ctx.beginPath();
            ctx.arc(0, -12, 10, 0, Math.PI * 2);
            ctx.fill();

            // Red cap
            ctx.fillStyle = 'rgb(204,33,33)';
            ctx.beginPath();
            ctx.ellipse(0, -18, 6, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // White face
            ctx.fillStyle = COLORS.cream;
            ctx.beginPath();
            ctx.ellipse(-3, -10, 5, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Yellow forehead
            ctx.fillStyle = 'rgb(232,224,161)';
            ctx.beginPath();
            ctx.ellipse(0, -15, 4, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eye
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-5, -11, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgb(26,26,26)';
            ctx.beginPath();
            ctx.arc(-5, -11, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Beak
            ctx.fillStyle = 'rgb(59,59,59)';
            ctx.beginPath();
            ctx.moveTo(-8, -10);
            ctx.lineTo(-20, -8);
            ctx.lineTo(-8, -7);
            ctx.closePath();
            ctx.fill();

            ctx.restore();

        } else if (currentStop === 5) { // Black Oystercatcher
            const bob = Math.sin(time * 1.2) * 1;

            ctx.translate(0, bob);

            // Legs
            ctx.strokeStyle = 'rgb(232,161,128)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-5, 12);
            ctx.lineTo(-5, 22);
            ctx.moveTo(5, 12);
            ctx.lineTo(5, 22);
            ctx.stroke();

            // Body
            ctx.fillStyle = 'rgb(26,26,26)';
            ctx.beginPath();
            ctx.ellipse(0, 5, 15, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wing
            ctx.fillStyle = 'rgb(41,41,41)';
            ctx.beginPath();
            ctx.ellipse(5, 5, 12, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = 'rgb(26,26,26)';
            ctx.beginPath();
            ctx.arc(-12, -3, 8, 0, Math.PI * 2);
            ctx.fill();

            // Eye ring
            ctx.strokeStyle = 'rgb(204,48,48)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(-14, -4, 3, 0, Math.PI * 2);
            ctx.stroke();

            // Eye
            ctx.fillStyle = 'rgb(255,214,0)';
            ctx.beginPath();
            ctx.arc(-14, -4, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgb(26,26,26)';
            ctx.beginPath();
            ctx.arc(-14, -4, 1, 0, Math.PI * 2);
            ctx.fill();

            // BEAK - orange chisel
            ctx.fillStyle = 'rgb(255,97,48)';
            ctx.beginPath();
            ctx.moveTo(-18, -3);
            ctx.lineTo(-45, -1);
            ctx.lineTo(-45, 1);
            ctx.lineTo(-18, 0);
            ctx.closePath();
            ctx.fill();

            // Beak highlight
            ctx.fillStyle = 'rgb(255,128,79)';
            ctx.beginPath();
            ctx.moveTo(-18, -3);
            ctx.lineTo(-40, -2);
            ctx.lineTo(-18, -1);
            ctx.closePath();
            ctx.fill();

        } else if (currentStop === 6) { // Monarch Butterfly
            const flutter = Math.sin(time * 4) * 0.4;
            const drift = Math.sin(time * 0.6) * 10;

            ctx.translate(drift, 0);

            const wingScale = Math.cos(flutter);

            // Left wing
            ctx.save();
            ctx.scale(1, wingScale);
            ctx.fillStyle = 'rgb(232,112,33)';
            ctx.beginPath();
            ctx.ellipse(-12, 0, 15, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = 'rgb(26,26,26)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(-12, 0, 15, 12, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-5, 0);
            ctx.lineTo(-20, -5);
            ctx.moveTo(-5, 0);
            ctx.lineTo(-22, 3);
            ctx.moveTo(-5, 0);
            ctx.lineTo(-15, 8);
            ctx.stroke();

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-20, -8, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(-22, -3, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(-18, 8, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Right wing
            ctx.save();
            ctx.scale(1, wingScale);
            ctx.fillStyle = 'rgb(232,112,33)';
            ctx.beginPath();
            ctx.ellipse(12, 0, 15, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'rgb(26,26,26)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(5, 0);
            ctx.lineTo(20, -5);
            ctx.moveTo(5, 0);
            ctx.lineTo(22, 3);
            ctx.moveTo(5, 0);
            ctx.lineTo(15, 8);
            ctx.stroke();
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(20, -8, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(22, -3, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(18, 8, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Body
            ctx.fillStyle = 'rgb(26,26,26)';
            ctx.beginPath();
            ctx.ellipse(0, 0, 3, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.beginPath();
            ctx.arc(0, -12, 3, 0, Math.PI * 2);
            ctx.fill();

            // Antennae
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-1, -14);
            ctx.lineTo(-5, -20);
            ctx.moveTo(1, -14);
            ctx.lineTo(5, -20);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(-5, -21, 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(5, -21, 1, 0, Math.PI * 2);
            ctx.fill();

        } else if (currentStop === 7) { // Rough-skinned Newt
            const walk = Math.sin(time * 1.2) * 2;

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.beginPath();
            ctx.ellipse(2, 10, 25, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tail
            ctx.fillStyle = 'rgb(89,64,48)';
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.lineTo(35, -5);
            ctx.lineTo(45, 0);
            ctx.lineTo(35, 5);
            ctx.lineTo(15, 2);
            ctx.closePath();
            ctx.fill();

            // Back legs
            ctx.beginPath();
            ctx.ellipse(10 + walk, 8, 8, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(10 - walk, -6, 8, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body
            ctx.fillStyle = 'rgb(107,79,64)';
            ctx.beginPath();
            ctx.ellipse(0, 0, 18, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Warty texture
            ctx.fillStyle = 'rgb(89,64,48)';
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.arc(-10 + i * 3, -2 + (i % 2) * 4, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Orange belly
            ctx.fillStyle = 'rgb(255,128,64)';
            ctx.beginPath();
            ctx.ellipse(0, 5, 12, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Front legs
            ctx.fillStyle = 'rgb(89,64,48)';
            ctx.beginPath();
            ctx.ellipse(-12 - walk, 6, 7, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(-12 + walk, -5, 7, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = 'rgb(107,79,64)';
            ctx.beginPath();
            ctx.ellipse(-18, 0, 8, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = 'rgb(26,26,26)';
            ctx.beginPath();
            ctx.arc(-20, -4, 2.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(-20, 4, 2.5, 0, Math.PI * 2);
            ctx.fill();

        } else if (currentStop === 8) { // Great Blue Heron
            const neckMove = Math.sin(time * 0.6) * 5;

            // Long legs
            ctx.strokeStyle = 'rgb(138,138,97)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-5, 30);
            ctx.lineTo(-5, 70);
            ctx.moveTo(5, 30);
            ctx.lineTo(5, 70);
            ctx.stroke();

            // Body
            ctx.fillStyle = 'rgb(89,107,122)';
            ctx.beginPath();
            ctx.ellipse(0, 20, 20, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wing
            ctx.fillStyle = 'rgb(74,89,107)';
            ctx.beginPath();
            ctx.ellipse(8, 20, 18, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // S-curved neck
            ctx.strokeStyle = 'rgb(107,122,138)';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(-5, 10);
            for (let i = 0; i <= 10; i++) {
                const t = i / 10;
                const nx = -5 + Math.sin(t * 3.14) * (10 + neckMove * 0.3);
                const ny = 10 - t * 60;
                if (i === 0) ctx.moveTo(nx, ny);
                else ctx.lineTo(nx, ny);
            }
            ctx.stroke();

            // Neck feathers
            ctx.fillStyle = COLORS.cream;
            ctx.beginPath();
            ctx.ellipse(-8, 0, 6, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.beginPath();
            ctx.ellipse(-10 + neckMove * 0.3, -55, 8, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Black crown stripe
            ctx.fillStyle = 'rgb(26,26,26)';
            ctx.beginPath();
            ctx.ellipse(-8 + neckMove * 0.3, -60, 10, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Plume feathers
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-5 + neckMove * 0.3, -62);
            ctx.lineTo(10, -65);
            ctx.moveTo(-5 + neckMove * 0.3, -60);
            ctx.lineTo(8, -62);
            ctx.stroke();

            // Beak
            ctx.fillStyle = 'rgb(209,161,64)';
            ctx.beginPath();
            ctx.moveTo(-15 + neckMove * 0.3, -55);
            ctx.lineTo(-45 + neckMove * 0.3, -52);
            ctx.lineTo(-15 + neckMove * 0.3, -50);
            ctx.closePath();
            ctx.fill();

            // Eye
            ctx.fillStyle = 'rgb(255,214,0)';
            ctx.beginPath();
            ctx.arc(-5 + neckMove * 0.3, -55, 2, 0, Math.PI * 2);
            ctx.fill();

        } else if (currentStop === 9) { // Harbor Seal
            const breathe = Math.sin(time * 0.5) * 2;

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.beginPath();
            ctx.ellipse(5, 12, 35, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.translate(0, breathe);

            // Body
            ctx.fillStyle = 'rgb(122,122,112)';
            ctx.beginPath();
            ctx.ellipse(0, 0, 35, 15 + breathe * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Spots
            ctx.fillStyle = 'rgb(89,89,79)';
            const spots = [[-15, -5], [-8, 3], [5, -3], [12, 5], [20, -2], [-20, 2]];
            spots.forEach(spot => {
                ctx.beginPath();
                ctx.ellipse(spot[0], spot[1], 4, 3, 0, 0, Math.PI * 2);
                ctx.fill();
            });

            // Lighter belly
            ctx.fillStyle = 'rgb(153,153,143)';
            ctx.beginPath();
            ctx.ellipse(0, 8, 25, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Back flippers
            ctx.fillStyle = 'rgb(107,107,97)';
            ctx.beginPath();
            ctx.ellipse(30, 5, 12, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = 'rgb(122,122,112)';
            ctx.beginPath();
            ctx.ellipse(-35, -5, 12, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Snout
            ctx.fillStyle = 'rgb(138,138,128)';
            ctx.beginPath();
            ctx.ellipse(-45, -3, 8, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nostrils
            ctx.fillStyle = 'rgb(59,59,48)';
            ctx.beginPath();
            ctx.ellipse(-50, -4, 2, 1, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(-50, -1, 2, 1, 0, 0, Math.PI * 2);
            ctx.fill();

            // Whiskers
            ctx.strokeStyle = 'rgb(74,74,64)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                ctx.moveTo(-48, -2 + i * 2);
                ctx.lineTo(-58, -4 + i * 3);
            }
            ctx.stroke();

            // Eye
            ctx.fillStyle = 'rgb(26,26,26)';
            ctx.beginPath();
            ctx.ellipse(-38, -8, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eye shine
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-39, -9, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Front flipper
            ctx.fillStyle = 'rgb(107,107,97)';
            ctx.beginPath();
            ctx.ellipse(-25, 10, 10, 5, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }

    function drawBinoculars() {
        if (binocularProgress <= 0) return;

        const alpha = binocularProgress;
        const liftOffset = (1 - binocularProgress) * 100;

        ctx.save();
        ctx.translate(0, liftOffset);

        // Create clipping path for binocular circles
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, 0, W, H);
        ctx.arc(focusX - BINOCULAR_RADIUS * 0.6, focusY, BINOCULAR_RADIUS, 0, Math.PI * 2, true);
        ctx.arc(focusX + BINOCULAR_RADIUS * 0.6, focusY, BINOCULAR_RADIUS, 0, Math.PI * 2, true);
        ctx.clip('evenodd');

        // Dark area outside binoculars
        ctx.fillStyle = `rgba(0,0,0,${0.92 * alpha})`;
        ctx.fillRect(0, 0, W, H);
        ctx.restore();

        // Binocular rim
        ctx.strokeStyle = `rgba(51,51,51,${alpha})`;
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.arc(focusX - BINOCULAR_RADIUS * 0.6, focusY, BINOCULAR_RADIUS, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(focusX + BINOCULAR_RADIUS * 0.6, focusY, BINOCULAR_RADIUS, 0, Math.PI * 2);
        ctx.stroke();

        // Center bridge
        ctx.fillStyle = `rgba(38,38,38,${alpha})`;
        ctx.fillRect(focusX - 12, focusY - 8, 24, 16);

        ctx.restore();
    }

    function drawPhotoUI() {
        // Timer bar
        const timerFrac = Math.max(0, photoTimer / PHOTO_TIME_LIMIT);
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(20, 12, 200, 20);
        ctx.fillStyle = timerFrac > 0.3 ? COLORS.cream : 'rgb(217,51,51)';
        ctx.fillRect(22, 14, 196 * timerFrac, 16);

        // Stop indicator
        ctx.fillStyle = COLORS.cream;
        ctx.font = '14px Courier New';
        ctx.textAlign = 'right';
        ctx.fillText(`STOP ${currentStop + 1} OF 10`, W - 20, 28);

        // Instructions
        ctx.textAlign = 'center';
        if (!binocularsRaised) {
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(W/2 - 120, H - 50, 240, 35);
            ctx.fillStyle = COLORS.cream;
            ctx.fillText("A: RAISE BINOCULARS", W/2, H - 28);
        } else {
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(W/2 - 140, H - 50, 280, 35);
            ctx.fillStyle = COLORS.cream;
            ctx.fillText("D-PAD: AIM   A: LOG SIGHTING", W/2, H - 28);
        }

        // Wildlife name hint
        const stop = STOPS[currentStop];
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(20, H - 85, 220, 25);
        ctx.fillStyle = COLORS.cream;
        ctx.textAlign = 'left';
        ctx.font = '12px Courier New';
        ctx.fillText("LOOK FOR: " + stop.wildlife.toUpperCase(), 28, H - 68);
    }

    function drawDeparture() {
        // Draw lodge background
        if (lodgeImage) {
            const imgW = lodgeImage.width, imgH = lodgeImage.height;
            const imgAspect = imgW / imgH;
            const canvasAspect = W / H;

            let drawW, drawH, drawX, drawY;
            if (imgAspect > canvasAspect) {
                drawH = H;
                drawW = H * imgAspect;
                drawX = (W - drawW) / 2;
                drawY = 0;
            } else {
                drawW = W;
                drawH = W / imgAspect;
                drawX = 0;
                drawY = (H - drawH) / 2;
            }
            ctx.drawImage(lodgeImage, drawX, drawY, drawW, drawH);
        } else {
            // Fallback procedural lodge
            ctx.fillStyle = COLORS.skyLight;
            ctx.fillRect(0, 0, W, 180);
            ctx.fillStyle = COLORS.grass;
            ctx.fillRect(0, 180, W, H - 180);
            ctx.fillStyle = COLORS.wood;
            ctx.fillRect(150, 200, 340, 200);
        }

        // Vignette
        for (let i = 1; i <= 5; i++) {
            const alpha = i * 0.04;
            ctx.fillStyle = `rgba(0,0,0,${alpha})`;
            ctx.fillRect(0, 0, W, i * 20);
            ctx.fillRect(0, H - i * 20, W, i * 20);
            ctx.fillRect(0, 0, i * 30, H);
            ctx.fillRect(W - i * 30, 0, i * 30, H);
        }

        // Cyclist animation
        const startX = W * 0.3;
        const endX = W + 200;
        const cyclistX = startX + departureTimer * 100;
        const cyclistY = H - 30;
        const bobAmount = Math.sin(departureTimer * 10) * 3;

        if (cyclistImage && cyclistX < endX) {
            const cyclistW = 234;
            const cyclistH = cyclistW * (cyclistImage.height / cyclistImage.width);
            const scale = cyclistW / cyclistImage.width;
            ctx.drawImage(cyclistImage, cyclistX - cyclistW/2, cyclistY - cyclistH + bobAmount, cyclistW, cyclistH);
        } else if (cyclistX < endX) {
            // Fallback cyclist
            ctx.fillStyle = 'rgb(51,51,51)';
            ctx.beginPath();
            ctx.arc(cyclistX, cyclistY - 55 + bobAmount, 22, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillRect(cyclistX - 28, cyclistY - 30 + bobAmount, 56, 28);
            ctx.lineWidth = 4;
            ctx.strokeStyle = 'rgb(51,51,51)';
            ctx.beginPath();
            ctx.arc(cyclistX - 24, cyclistY + bobAmount, 20, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(cyclistX + 24, cyclistY + bobAmount, 20, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Text overlay
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(0, 0, W, 50);
        ctx.fillStyle = COLORS.cream;
        ctx.font = 'bold 20px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText("Departing Sea Ranch Lodge...", W/2, 32);
    }

    function drawBikingCutscene() {
        // Sky
        ctx.fillStyle = COLORS.skyLight;
        ctx.fillRect(0, 0, W, 140);
        ctx.fillStyle = COLORS.skyMid;
        ctx.fillRect(0, 140, W, 50);

        // Ocean layers
        ctx.fillStyle = COLORS.oceanDeep;
        ctx.fillRect(0, 175, W, 12);
        ctx.fillStyle = COLORS.oceanMid;
        ctx.fillRect(0, 187, W, 18);
        ctx.fillStyle = COLORS.oceanLight;
        ctx.fillRect(0, 205, W, 22);

        // Waves
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        for (let i = 1; i <= 12; i++) {
            const wx = ((i - 1) * 45 + time * 30) % (W + 45) - 22;
            const wy = 212 + Math.sin(i + time * 1.5) * 2;
            ctx.fillRect(wx, wy, 30, 4);
        }

        // Meadow
        ctx.fillStyle = COLORS.grass;
        ctx.fillRect(0, 225, W, 70);
        ctx.fillStyle = COLORS.grassLight;
        ctx.fillRect(0, 280, W, 15);

        // Road
        const roadY = 310;
        const roadHeight = 60;
        ctx.fillStyle = 'rgb(74,74,74)';
        ctx.fillRect(0, roadY, W, roadHeight);

        // Road center dashed line
        ctx.fillStyle = 'rgb(204,204,128)';
        for (let i = 1; i <= 10; i++) {
            const dashX = ((i - 1) * 80 - bikeRoadOffset) % (W + 80) - 40;
            ctx.fillRect(dashX, roadY + roadHeight / 2 - 2, 40, 4);
        }

        // Road edge stripes
        ctx.fillStyle = 'white';
        ctx.fillRect(0, roadY, W, 4);
        ctx.fillRect(0, roadY + roadHeight - 4, W, 4);

        // Ground below road
        ctx.fillStyle = COLORS.woodDark;
        ctx.fillRect(0, roadY + roadHeight, W, 50);
        ctx.fillStyle = 'rgb(74,59,48)';
        ctx.fillRect(0, roadY + roadHeight + 50, W, H - roadY - roadHeight - 50);

        // Cypress trees
        for (let i = 1; i <= 6; i++) {
            const tx = 50 + i * 90;
            const th = 65 + Math.sin(i * 2) * 20;
            ctx.fillStyle = COLORS.woodDark;
            ctx.fillRect(tx - 3, roadY - 8 - th * 0.15, 6, th * 0.15);
            ctx.fillStyle = 'rgb(38,71,56)';
            ctx.beginPath();
            ctx.moveTo(tx, roadY - 8);
            ctx.lineTo(tx - 15, roadY - 8 - th);
            ctx.lineTo(tx + 15, roadY - 8 - th);
            ctx.closePath();
            ctx.fill();
        }

        // Wayfinding post
        const postProgress = ((time * 21 + 200) % 500) / 500;
        const postX = W + 50 - postProgress * (W + 100);
        const postLabel = STOPS[currentStop].shortName || STOPS[currentStop].name.substring(0, 7);

        if (postX > -30 && postX < W + 30) {
            const postHeight = 110;
            if (postImage) {
                const scale = postHeight / postImage.height;
                const drawWidth = postImage.width * scale;
                const postDrawX = postX - drawWidth / 2;
                const postDrawY = roadY - postHeight + 15;
                ctx.drawImage(postImage, postDrawX, postDrawY, drawWidth, postHeight);

                // Draw stop name
                ctx.fillStyle = 'rgb(43,43,43)';
                ctx.font = '10px Courier New';
                ctx.textAlign = 'center';
                const letters = postLabel.split('');
                letters.forEach((letter, j) => {
                    ctx.fillText(letter, postDrawX + drawWidth / 2, postDrawY + 14 + j * 9);
                });
            } else {
                // Fallback post
                ctx.fillStyle = COLORS.cream;
                ctx.fillRect(postX - 8, roadY - postHeight + 15, 16, postHeight);
                ctx.fillStyle = 'rgb(26,26,26)';
                ctx.font = '10px Courier New';
                ctx.save();
                ctx.translate(postX - 6, roadY - postHeight + 25);
                ctx.rotate(Math.PI / 2);
                ctx.fillText(postLabel, 0, 0);
                ctx.restore();
            }
        }

        // Cyclist
        const bobY = Math.sin(time * 4) * 2;
        if (cyclistImage) {
            const cyclistScale = 0.28;
            const cyclistW = cyclistImage.width * cyclistScale;
            const cyclistH = cyclistImage.height * cyclistScale;
            const cyclistX = 140;
            const cyclistY = roadY - cyclistH + 35 + bobY;
            ctx.drawImage(cyclistImage, cyclistX, cyclistY, cyclistW, cyclistH);
        } else {
            // Fallback cyclist
            const cx = 160, cy = roadY + 20 + bobY;
            const pedalAngle = time * 6;

            // Wheels
            ctx.strokeStyle = 'rgb(38,38,38)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(cx - 25, cy + 18, 14, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(cx + 25, cy + 18, 14, 0, Math.PI * 2);
            ctx.stroke();

            // Frame
            ctx.strokeStyle = COLORS.superBlue;
            ctx.beginPath();
            ctx.moveTo(cx - 25, cy + 18);
            ctx.lineTo(cx, cy - 8);
            ctx.lineTo(cx + 25, cy + 18);
            ctx.moveTo(cx, cy - 8);
            ctx.lineTo(cx + 18, cy - 14);
            ctx.stroke();

            // Rider
            ctx.fillStyle = COLORS.superRed;
            ctx.fillRect(cx - 5, cy - 30, 10, 18);
            ctx.fillStyle = 'rgb(222,184,135)';
            ctx.beginPath();
            ctx.arc(cx, cy - 38, 7, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = COLORS.superBlue;
            ctx.fillRect(cx - 7, cy - 48, 14, 8);

            // Legs
            ctx.strokeStyle = 'rgb(77,77,77)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(cx - 3, cy - 12);
            ctx.lineTo(cx - 6 + Math.cos(pedalAngle) * 10, cy + 12);
            ctx.moveTo(cx + 3, cy - 12);
            ctx.lineTo(cx + 6 + Math.cos(pedalAngle + Math.PI) * 10, cy + 12);
            ctx.stroke();
        }

        // Progress text
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(0, 0, W, 45);
        ctx.fillStyle = COLORS.cream;
        ctx.font = 'bold 20px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(`Biking to ${STOPS[currentStop].name}...`, W/2, 30);

        // Progress bar
        const progress = bikeProgress / BIKE_DURATION;
        ctx.fillStyle = 'rgb(51,51,51)';
        ctx.fillRect(W/2 - 100, H - 40, 200, 16);
        ctx.fillStyle = COLORS.superRed;
        ctx.fillRect(W/2 - 97, H - 37, 194 * progress, 10);
    }

    function drawResultsCard() {
        const stop = STOPS[currentStop];
        const score = scores[currentStop] || 0;

        // Background
        ctx.fillStyle = COLORS.cream;
        ctx.fillRect(W/2 - 180, 60, 360, 360);

        // Header
        ctx.fillStyle = COLORS.superBlue;
        ctx.fillRect(W/2 - 180, 60, 360, 50);
        ctx.fillStyle = COLORS.cream;
        ctx.font = '12px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(`STOP ${currentStop + 1} OF 10`, W/2 - 170, 82);
        ctx.textAlign = 'right';
        ctx.fillText(stop.name.toUpperCase(), W/2 + 170, 98);

        // Habitat tag
        ctx.fillStyle = COLORS.superBlue;
        ctx.font = '11px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(stop.habitat.toUpperCase(), W/2, 135);

        // Wildlife name
        ctx.fillStyle = 'rgb(26,26,26)';
        ctx.font = 'bold 22px Courier New';
        ctx.fillText(stop.wildlife, W/2, 175);

        // Latin name
        ctx.fillStyle = COLORS.superBlue;
        ctx.font = 'italic 14px Courier New';
        ctx.fillText(stop.latin, W/2, 200);

        // Divider
        ctx.fillStyle = COLORS.superBlue;
        ctx.fillRect(W/2 - 30, 215, 60, 4);

        // Fact
        ctx.fillStyle = 'rgb(115,89,71)';
        ctx.font = '12px Courier New';
        // Word wrap the fact
        const words = stop.fact.split(' ');
        let line = '';
        let y = 240;
        words.forEach(word => {
            const testLine = line + word + ' ';
            if (ctx.measureText(testLine).width > 300) {
                ctx.fillText(line.trim(), W/2, y);
                line = word + ' ';
                y += 16;
            } else {
                line = testLine;
            }
        });
        ctx.fillText(line.trim(), W/2, y);

        // Quality rating
        const qualityNames = ["MISSED", "GLIMPSE", "GOOD", "EXCELLENT"];
        const qualityColors = ['rgb(196,31,59)', 'rgb(115,89,71)', 'rgb(46,92,168)', 'rgb(43,138,74)'];

        ctx.fillStyle = COLORS.superBlue;
        ctx.fillRect(W/2 - 160, 300, 320, 3);

        ctx.fillStyle = qualityColors[score];
        ctx.font = 'bold 24px Courier New';
        ctx.fillText(qualityNames[score], W/2, 340);

        // Rating dots
        for (let i = 0; i < 3; i++) {
            const dotX = W/2 - 25 + i * 25;
            if (i < score) {
                ctx.fillStyle = qualityColors[score];
                ctx.beginPath();
                ctx.arc(dotX, 370, 8, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.strokeStyle = 'rgb(115,89,71)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(dotX, 370, 8, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        // Continue hint
        ctx.fillStyle = COLORS.superBlue;
        ctx.font = '14px Courier New';
        ctx.fillText("A: CONTINUE", W/2, 405);
    }

    function drawCompleteCard() {
        // Background
        ctx.fillStyle = COLORS.cream;
        ctx.fillRect(W/2 - 200, 40, 400, 400);

        // Header
        ctx.fillStyle = COLORS.superBlue;
        ctx.fillRect(W/2 - 200, 40, 400, 60);
        ctx.fillStyle = COLORS.cream;
        ctx.font = 'bold 24px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText("TRAIL COMPLETE", W/2, 75);
        ctx.font = '12px Courier New';
        ctx.fillText("Bluff Trail - Sea Ranch, CA", W/2, 92);

        // Species grid
        ctx.fillStyle = 'rgb(26,26,26)';
        ctx.font = '11px Courier New';
        ctx.fillText("SPECIES OBSERVED", W/2, 125);

        let totalScore = 0;
        for (let i = 0; i < STOPS.length; i++) {
            const row = Math.floor(i / 2);
            const col = i % 2;
            const x = W/2 - 170 + col * 180;
            const y = 140 + row * 45;

            const score = scores[i] || 0;
            totalScore += score;

            // Box
            ctx.fillStyle = score > 0 ? 'rgba(43,138,74,0.2)' : 'rgba(196,31,59,0.2)';
            ctx.fillRect(x, y, 170, 40);

            // Name
            ctx.fillStyle = 'rgb(26,26,26)';
            ctx.textAlign = 'left';
            ctx.font = '11px Courier New';
            ctx.fillText(STOPS[i].wildlife, x + 5, y + 18);

            // Score dots
            for (let d = 0; d < 3; d++) {
                const dotX = x + 120 + d * 15;
                if (d < score) {
                    ctx.fillStyle = 'rgb(43,138,74)';
                    ctx.beginPath();
                    ctx.arc(dotX, y + 28, 5, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.strokeStyle = 'rgb(128,128,128)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(dotX, y + 28, 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }

        // Total
        ctx.fillStyle = 'rgb(26,26,26)';
        ctx.font = 'bold 20px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(`TOTAL: ${totalScore}/30`, W/2, 395);

        // Continue hint
        ctx.fillStyle = COLORS.superBlue;
        ctx.font = '14px Courier New';
        ctx.fillText("A: REPLAY   B: MENU", W/2, 425);
    }

    function drawTitle() {
        // Background with supergraphic styling
        ctx.fillStyle = COLORS.skyLight;
        ctx.fillRect(0, 0, W, H);

        // Blue curve (Barbara Stauffacher Solomon style)
        ctx.fillStyle = COLORS.superBlue;
        ctx.beginPath();
        ctx.moveTo(0, H);
        ctx.quadraticCurveTo(W/2, H - 200, W, H);
        ctx.lineTo(W, H);
        ctx.lineTo(0, H);
        ctx.closePath();
        ctx.fill();

        // Red arrow
        ctx.fillStyle = COLORS.superRed;
        ctx.beginPath();
        ctx.moveTo(W - 100, 50);
        ctx.lineTo(W - 20, 100);
        ctx.lineTo(W - 100, 150);
        ctx.lineTo(W - 80, 100);
        ctx.closePath();
        ctx.fill();

        // Title card
        ctx.fillStyle = COLORS.cream;
        ctx.fillRect(W/2 - 200, H/2 - 100, 400, 200);

        // Title text
        ctx.fillStyle = COLORS.superBlue;
        ctx.font = 'bold 32px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText("Naturalist Trail", W/2, H/2 - 30);

        ctx.fillStyle = 'rgb(115,89,71)';
        ctx.font = '16px Courier New';
        ctx.fillText("A 10-Mile Photo Journey", W/2, H/2 + 10);

        // Binoculars icon
        ctx.strokeStyle = COLORS.superBlue;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(W/2 - 20, H/2 + 50, 15, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(W/2 + 20, H/2 + 50, 15, 0, Math.PI * 2);
        ctx.stroke();
        ctx.fillStyle = COLORS.superBlue;
        ctx.fillRect(W/2 - 8, H/2 + 42, 16, 16);

        // Start hint
        ctx.fillStyle = COLORS.superRed;
        ctx.font = 'bold 14px Courier New';
        ctx.fillText("PRESS A TO START", W/2, H/2 + 120);
        ctx.font = '12px Courier New';
        ctx.fillStyle = 'rgb(115,89,71)';
        ctx.fillText("B: BACK TO MENU", W/2, H/2 + 145);
    }

    function drawGrain(intensity) {
        const imageData = ctx.getImageData(0, 0, W, H);
        const data = imageData.data;
        const amount = intensity * 25;

        for (let i = 0; i < data.length; i += 4) {
            const noise = (Math.random() - 0.5) * amount;
            data[i] = Math.min(255, Math.max(0, data[i] + noise));
            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise));
            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise));
        }

        ctx.putImageData(imageData, 0, 0);
    }

    function draw() {
        ctx.save();
        ctx.translate(shakeX, shakeY);

        if (gameState === "title") {
            drawTitle();
        } else if (gameState === "departure") {
            drawDeparture();
            drawGrain(0.05);
        } else if (gameState === "biking") {
            drawBikingCutscene();
        } else if (gameState === "photo") {
            drawHabitatBackground();
            drawWildlife();
            drawBinoculars();
            drawPhotoUI();
            drawGrain(0.05);
        } else if (gameState === "results") {
            drawHabitatBackground();
            drawWildlife();
            drawResultsCard();
            drawGrain(0.05);
        } else if (gameState === "complete") {
            ctx.fillStyle = COLORS.skyLight;
            ctx.fillRect(0, 0, W, H);
            drawCompleteCard();
            drawGrain(0.05);
        }

        ctx.restore();
    }

    // Game loop
    let lastTime = 0;
    function gameLoop(timestamp) {
        const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
        lastTime = timestamp;

        update(dt);
        draw();

        // Clear justPressed AFTER frame is processed
        Object.keys(keysJustPressed).forEach(k => keysJustPressed[k] = false);

        requestAnimationFrame(gameLoop);
    }

    // Canvas click handler for A button action
    canvas.addEventListener('click', () => {
        keysJustPressed['a'] = true;
        keys['a'] = true;
        setTimeout(() => { keys['a'] = false; }, 100);
    });

    // Start game
    loadAssets().then(() => {
        requestAnimationFrame(gameLoop);
    });

    // Start immediately without waiting for all assets
    requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
