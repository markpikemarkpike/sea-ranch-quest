<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Covey - Sea Ranch Quest</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Georgia, serif;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            touch-action: none;
        }
        canvas {
            display: block;
            image-rendering: pixelated;
        }
        #touchControls {
            position: absolute;
            bottom: 10px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: none;
        }
        .dpad {
            width: 120px;
            height: 120px;
            position: relative;
            pointer-events: auto;
        }
        .dpad-btn {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: white;
            user-select: none;
        }
        .dpad-up { top: 0; left: 40px; }
        .dpad-down { bottom: 0; left: 40px; }
        .dpad-left { top: 40px; left: 0; }
        .dpad-right { top: 40px; right: 0; }
        .action-buttons {
            display: flex;
            gap: 15px;
            align-items: flex-end;
            pointer-events: auto;
        }
        .action-btn {
            width: 50px;
            height: 50px;
            border-radius: 25px;
            background: rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.5);
            font-size: 18px;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }
        #backLink {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ccc;
            text-decoration: none;
            font-size: 14px;
            z-index: 100;
        }
        #backLink:hover {
            color: #fff;
        }
        /* Controls always visible */
    </style>
</head>
<body>
    <a href="index.html" id="backLink">Back to Menu</a>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="640" height="480"></canvas>
        <div id="touchControls">
            <div class="dpad">
                <div class="dpad-btn dpad-up" data-dir="up">^</div>
                <div class="dpad-btn dpad-down" data-dir="down">v</div>
                <div class="dpad-btn dpad-left" data-dir="left">&lt;</div>
                <div class="dpad-btn dpad-right" data-dir="right">&gt;</div>
            </div>
            <div class="action-buttons">
                <div class="action-btn" data-action="b">B</div>
                <div class="action-btn" data-action="a">A</div>
            </div>
        </div>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const W = 640, H = 480;

// Game state
let gameState = 'title';
let time = 0;

// Season system
const SEASONS = ['Spring', 'Summer', 'Fall', 'Winter'];
const SEASON_DURATION = 1500; // ~25 seconds at 60fps
let currentSeason = 1;
let seasonTimer = 0;
let seasonAnnounceTimer = 0;

// Season palettes
const PALETTES = {
    Spring: {sky: [0.53, 0.71, 0.82], grass: [0.47, 0.59, 0.35], ground: [0.39, 0.47, 0.31], accent: [0.91, 0.63, 0.75]},
    Summer: {sky: [0.53, 0.75, 0.86], grass: [0.71, 0.63, 0.35], ground: [0.59, 0.51, 0.31], accent: [0.94, 0.82, 0.38]},
    Fall: {sky: [0.55, 0.55, 0.61], grass: [0.67, 0.51, 0.27], ground: [0.51, 0.39, 0.25], accent: [0.82, 0.44, 0.19]},
    Winter: {sky: [0.67, 0.69, 0.73], grass: [0.55, 0.57, 0.51], ground: [0.43, 0.41, 0.37], accent: [0.66, 0.72, 0.78]}
};

// Hunger system
let hunger = 0;
const HUNGER_MAX = 100;

// Road
const ROAD_Y = 216;
const ROAD_H = 45;

// Mama quail
let mama = {
    x: 100, y: 336,
    vx: 0, vy: 0,
    speed: 0.8, maxSpeed: 5.5, friction: 0.88,
    facing: 1, bobPhase: 0
};

// Chicks
const CHICK_COUNT = 8;
let chicks = [];
let chicksAlive = CHICK_COUNT;

// Environment
let bushes = [];
let food = [];
let predators = [];
let vehicles = [];
let particles = [];
let leaves = [];

// Spawn timers
let foodSpawnTimer = 0;
let predatorSpawnTimer = 0;
let vehicleSpawnTimer = 0;

// Screen shake
let shakeAmount = 0;
let shakeX = 0, shakeY = 0;

// Builder dialogue
const DIALOGUES = [
    // Spring - site prep
    "Live lightly on the land",
    "Preserve the meadows",
    "Work with the topography",
    // Summer - framing
    "Rural, not suburban",
    "No flamboyance",
    "Cluster the buildings",
    // Fall - siding
    "Unpainted native wood",
    "Let it weather naturally",
    "Blend into the landscape",
    // Winter - finished
    "Simplicity and community",
    "Half the land in common",
    "A place to belong"
];

// Input handling
const keys = {};
const justPressed = {};
const touchDirs = {};

document.addEventListener('keydown', (e) => {
    if (!keys[e.code]) justPressed[e.code] = true;
    keys[e.code] = true;
    e.preventDefault();
});
document.addEventListener('keyup', (e) => {
    keys[e.code] = false;
});

// Touch and mouse controls
document.querySelectorAll('.dpad-btn').forEach(btn => {
    const dir = btn.dataset.dir;
    btn.addEventListener('touchstart', (e) => { touchDirs[dir] = true; e.preventDefault(); });
    btn.addEventListener('touchend', (e) => { touchDirs[dir] = false; e.preventDefault(); });
    btn.addEventListener('mousedown', (e) => { touchDirs[dir] = true; e.preventDefault(); });
    btn.addEventListener('mouseup', (e) => { touchDirs[dir] = false; e.preventDefault(); });
    btn.addEventListener('mouseleave', () => { touchDirs[dir] = false; });
});
document.querySelectorAll('.action-btn').forEach(btn => {
    const action = btn.dataset.action;
    btn.addEventListener('touchstart', (e) => {
        justPressed[action] = true;
        keys[action] = true;
        e.preventDefault();
    });
    btn.addEventListener('touchend', (e) => {
        keys[action] = false;
        e.preventDefault();
    });
    btn.addEventListener('mousedown', (e) => {
        justPressed[action] = true;
        keys[action] = true;
        e.preventDefault();
    });
    btn.addEventListener('mouseup', (e) => {
        keys[action] = false;
        e.preventDefault();
    });
    btn.addEventListener('mouseleave', () => {
        keys[action] = false;
    });
});

// Tap on canvas for title/end screens
canvas.addEventListener('click', () => {
    if (gameState === 'title') {
        justPressed['a'] = true;
    } else if (gameState === 'win' || gameState === 'lose') {
        justPressed['a'] = true;
    }
});

function isDown(dir) {
    if (touchDirs[dir]) return true;
    if (dir === 'left') return keys['ArrowLeft'] || keys['KeyA'];
    if (dir === 'right') return keys['ArrowRight'] || keys['KeyD'];
    if (dir === 'up') return keys['ArrowUp'] || keys['KeyW'];
    if (dir === 'down') return keys['ArrowDown'] || keys['KeyS'];
    return false;
}

function wasJustPressed(action) {
    if (justPressed[action]) return true;
    if (action === 'a') return justPressed['Space'] || justPressed['Enter'] || justPressed['KeyZ'];
    if (action === 'b') return justPressed['Escape'] || justPressed['KeyX'] || justPressed['Backspace'];
    return false;
}

// Helper functions
function lerp(a, b, t) {
    return a + (b - a) * t;
}

function lerpColor(c1, c2, t) {
    return [lerp(c1[0], c2[0], t), lerp(c1[1], c2[1], t), lerp(c1[2], c2[2], t)];
}

function getCurrentPalette() {
    const safeSeason = Math.max(0, Math.min(3, currentSeason - 1));
    const curr = PALETTES[SEASONS[safeSeason]];
    const nextSeason = (safeSeason + 1) % 4;
    const next = PALETTES[SEASONS[nextSeason]];
    const t = Math.min(1, seasonTimer / SEASON_DURATION);

    if (t > 0.85) {
        const fadeT = (t - 0.85) / 0.15;
        return {
            sky: lerpColor(curr.sky, next.sky, fadeT),
            grass: lerpColor(curr.grass, next.grass, fadeT),
            ground: lerpColor(curr.ground, next.ground, fadeT)
        };
    }
    return curr;
}

function rgb(r, g, b, a = 1) {
    return `rgba(${Math.floor(r*255)},${Math.floor(g*255)},${Math.floor(b*255)},${a})`;
}

function isInBush(x, y) {
    for (const b of bushes) {
        const dx = x - b.x;
        const dy = y - b.y;
        if (Math.abs(dx) < b.w/2 && Math.abs(dy) < b.h/2) return true;
    }
    return false;
}

function isAtHouse(x, y) {
    const houseX = W - 95;
    const houseY = ROAD_Y * 0.72;
    return x > houseX - 50 && x < houseX + 50 && y > houseY - 60 && y < houseY + 20;
}

function isHiding(x, y) {
    return isInBush(x, y) || isAtHouse(x, y);
}

function isOnRoad(y) {
    return y >= ROAD_Y && y <= ROAD_Y + ROAD_H;
}

function shake(amount) {
    shakeAmount = Math.max(shakeAmount, amount);
}

function spawnParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 4,
            vy: -Math.random() * 3 - 1,
            life: 30 + Math.random() * 20,
            color: color,
            size: 2 + Math.random() * 2
        });
    }
}

function initBushes() {
    bushes = [
        {x: 70, y: 288, w: 55, h: 35},
        {x: 180, y: 394, w: 60, h: 38},
        {x: 320, y: 312, w: 50, h: 32},
        {x: 450, y: 408, w: 55, h: 35},
        {x: 550, y: 326, w: 48, h: 30}
    ];
}

function initChicks() {
    chicks = [];
    for (let i = 0; i < CHICK_COUNT; i++) {
        chicks.push({
            x: mama.x - 15 - Math.random() * 20,
            y: mama.y + (Math.random() - 0.5) * 20,
            vx: 0, vy: 0,
            bobPhase: Math.random() * Math.PI * 2,
            alive: true,
            personality: 0.5 + Math.random() * 0.5,
            size: 5 + Math.random() * 2,
            wanderAngle: Math.random() * Math.PI * 2,
            scared: 0
        });
    }
    chicksAlive = CHICK_COUNT;
}

function spawnFood() {
    const season = SEASONS[currentSeason - 1];
    const count = (season === 'Spring' || season === 'Summer') ? 2 : 1;

    const houseX = W - 95;
    const houseLeft = houseX - 50, houseRight = houseX + 50;
    const houseTop = ROAD_Y * 0.72 - 60, houseBottom = ROAD_Y * 0.72 + 20;

    for (let i = 0; i < count; i++) {
        let x, y;
        let attempts = 0;

        do {
            const aboveRoadChance = season === 'Summer' ? 0.5 : 0.3;
            if (Math.random() < aboveRoadChance) {
                x = 60 + Math.random() * 580;
                y = 65 + Math.random() * (ROAD_Y - 85);
            } else {
                x = 60 + Math.random() * 520;
                y = ROAD_Y + ROAD_H + 40 + Math.random() * (H - ROAD_Y - ROAD_H - 70);
            }
            attempts++;
        } while (attempts < 10 && x > houseLeft && x < houseRight && y > houseTop && y < houseBottom);

        const foodLeaves = [];
        for (let j = 0; j < 4; j++) {
            foodLeaves.push({
                angle: Math.random() * Math.PI * 2,
                size: 0.7 + Math.random() * 0.4
            });
        }

        food.push({
            x: x, y: y,
            size: 10 + Math.random() * 4,
            amount: 1,
            leaves: foodLeaves
        });
    }
}

function loseChick(reason) {
    const alive = chicks.filter(c => c.alive);
    if (alive.length === 0) return;

    alive.sort((a, b) => a.size - b.size);
    const victim = alive[0];
    victim.alive = false;
    chicksAlive--;

    spawnParticles(victim.x, victim.y, [0.67, 0.40, 0.27], 8);
    shake(8);

    if (chicksAlive < 4) {
        gameState = 'lose';
    }
}

function setupLevel() {
    mama.x = 100;
    mama.y = 336;
    mama.vx = 0;
    mama.vy = 0;

    currentSeason = 1;
    seasonTimer = 0;
    seasonAnnounceTimer = 120;
    hunger = 0;

    predators = [];
    vehicles = [];
    food = [];
    particles = [];
    leaves = [];

    foodSpawnTimer = 60;
    predatorSpawnTimer = 200;
    vehicleSpawnTimer = 100;

    initBushes();
    initChicks();
    spawnFood();
    spawnFood();
}

function updateSeason() {
    seasonTimer++;

    if (seasonTimer >= SEASON_DURATION) {
        seasonTimer = 0;
        currentSeason++;

        if (currentSeason > 4) {
            gameState = 'win';
            saveCompletion(9);
            shake(3);
            return;
        }

        seasonAnnounceTimer = 120;
        spawnFood();
    }

    if (seasonAnnounceTimer > 0) {
        seasonAnnounceTimer--;
    }

    // Fall leaves
    if (SEASONS[currentSeason - 1] === 'Fall' && Math.random() < 0.02) {
        leaves.push({
            x: Math.random() * W,
            y: -10,
            vx: (Math.random() - 0.5) * 2,
            vy: 1 + Math.random(),
            rot: Math.random() * Math.PI * 2,
            rotSpeed: (Math.random() - 0.5) * 0.1,
            color: Math.random() > 0.5 ? [0.82, 0.44, 0.19] : [0.75, 0.55, 0.25]
        });
    }
}

function updateMama() {
    let ax = 0, ay = 0;
    if (isDown('left')) { ax -= 1; mama.facing = -1; }
    if (isDown('right')) { ax += 1; mama.facing = 1; }
    if (isDown('up')) { ay -= 1; }
    if (isDown('down')) { ay += 1; }

    if (ax !== 0 || ay !== 0) {
        const len = Math.sqrt(ax*ax + ay*ay);
        ax /= len;
        ay /= len;
    }

    mama.vx += ax * mama.speed;
    mama.vy += ay * mama.speed;
    mama.vx *= mama.friction;
    mama.vy *= mama.friction;

    const speed = Math.sqrt(mama.vx**2 + mama.vy**2);
    if (speed > mama.maxSpeed) {
        mama.vx = mama.vx / speed * mama.maxSpeed;
        mama.vy = mama.vy / speed * mama.maxSpeed;
    }

    mama.x += mama.vx;
    mama.y += mama.vy;

    mama.x = Math.max(20, Math.min(W - 20, mama.x));
    mama.y = Math.max(ROAD_Y * 0.5, Math.min(H - 20, mama.y));

    if (speed > 0.5) {
        mama.bobPhase += speed * 0.15;
    }
}

function updateChicks() {
    for (const c of chicks) {
        if (!c.alive) continue;

        c.scared = Math.max(0, c.scared - 0.02);

        let targetX = mama.x, targetY = mama.y;
        const followDist = 12 + c.personality * 8;

        if (c.scared > 0.5) {
            targetX += (Math.random() - 0.5) * 25;
            targetY += (Math.random() - 0.5) * 25;
        } else {
            c.wanderAngle += (Math.random() - 0.5) * 0.2;
            targetX += Math.cos(c.wanderAngle) * followDist * 0.2;
            targetY += Math.sin(c.wanderAngle) * followDist * 0.2;
        }

        const dx = targetX - c.x;
        const dy = targetY - c.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist > followDist) {
            const speed = c.scared > 0 ? 0.5 : 0.35;
            c.vx += (dx / dist) * speed * c.personality;
            c.vy += (dy / dist) * speed * c.personality;
        }

        c.vx *= 0.9;
        c.vy *= 0.9;
        c.x += c.vx;
        c.y += c.vy;

        c.x = Math.max(15, Math.min(W - 15, c.x));
        c.y = Math.max(ROAD_Y * 0.5, Math.min(H - 15, c.y));

        const speed = Math.sqrt(c.vx**2 + c.vy**2);
        if (speed > 0.3) {
            c.bobPhase += speed * 0.2;
        }
    }
}

function updateHunger() {
    const safeSeason = Math.max(0, Math.min(3, currentSeason - 1));
    const season = SEASONS[safeSeason];
    const hungerRate = season === 'Winter' ? 0.12 : (season === 'Fall' ? 0.08 : 0.05);
    hunger += hungerRate;

    for (let i = food.length - 1; i >= 0; i--) {
        const f = food[i];

        if (!isHiding(mama.x, mama.y)) {
            const distMama = Math.sqrt((mama.x - f.x)**2 + (mama.y - f.y)**2);
            if (distMama < 28 && f.amount > 0) {
                f.amount -= 0.03;
                hunger = Math.max(0, hunger - 2.5);
            }
        }

        for (const c of chicks) {
            if (c.alive && !isHiding(c.x, c.y)) {
                const distChick = Math.sqrt((c.x - f.x)**2 + (c.y - f.y)**2);
                if (distChick < 20 && f.amount > 0) {
                    f.amount -= 0.02;
                    hunger = Math.max(0, hunger - 1.5);
                }
            }
        }

        if (f.amount <= 0) {
            spawnParticles(f.x, f.y, [0.35, 0.54, 0.25], 5);
            food.splice(i, 1);
        }
    }

    foodSpawnTimer--;
    if (foodSpawnTimer <= 0) {
        const baseDelay = season === 'Spring' ? 250 : (season === 'Summer' ? 300 : (season === 'Fall' ? 400 : 500));
        foodSpawnTimer = baseDelay + Math.random() * 150;
        if (food.length < 4) {
            spawnFood();
        }
    }

    if (hunger >= HUNGER_MAX) {
        hunger = 40;
        loseChick('hunger');
    }
}

function updatePredators() {
    const safeSeason = Math.max(0, Math.min(3, currentSeason - 1));
    const season = SEASONS[safeSeason];
    const mamaHiding = isHiding(mama.x, mama.y);

    predatorSpawnTimer--;

    if (predatorSpawnTimer <= 0) {
        if (season === 'Spring' && predators.length < 3) {
            const side = Math.random() > 0.5 ? 1 : -1;
            predators.push({
                type: 'fox',
                x: side > 0 ? -60 : W + 60,
                y: ROAD_Y + ROAD_H + 40 + Math.random() * 100,
                vx: side * (2 + Math.random()),
                facing: side,
                phase: 'prowling',
                runPhase: 0
            });
            predatorSpawnTimer = 220 + Math.random() * 120;
        } else if (season === 'Fall' && predators.length < 3) {
            predators.push({
                type: 'hawk',
                x: Math.random() > 0.5 ? -60 : W + 60,
                y: H * 0.12,
                vx: 0,
                phase: 'circling',
                circleAngle: Math.random() * Math.PI * 2,
                swoopTimer: 120 + Math.random() * 80,
                wingPhase: 0,
                targetX: 0,
                targetY: 0
            });
            predatorSpawnTimer = 250 + Math.random() * 100;
        } else {
            predatorSpawnTimer = 80;
        }
    }

    for (let i = predators.length - 1; i >= 0; i--) {
        const p = predators[i];

        if (p.type === 'fox') {
            p.runPhase += 0.15;

            if (p.phase === 'prowling') {
                p.x += p.vx;

                const dx = Math.abs(p.x - mama.x);
                const dy = Math.abs(p.y - mama.y);
                if (!mamaHiding && dx < 150 && dy < 100 && mama.y > ROAD_Y) {
                    p.phase = 'chasing';
                }

                if (p.x < -60 || p.x > W + 60) {
                    predators.splice(i, 1);
                }
            } else if (p.phase === 'chasing') {
                const mamaAcrossRoad = mama.y < ROAD_Y;

                if (mamaAcrossRoad) {
                    p.phase = 'leaving';
                } else {
                    const dx = mama.x - p.x;
                    const dy = mama.y - p.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    const chaseSpeed = 4.2;
                    if (dist > 5) {
                        p.vx = (dx / dist) * chaseSpeed;
                        let newY = p.y + (dy / dist) * chaseSpeed * 0.8;
                        newY = Math.max(ROAD_Y + ROAD_H + 8, Math.min(H - 20, newY));
                        p.y = newY;
                    }
                    p.x += p.vx;
                    p.facing = p.vx > 0 ? 1 : -1;

                    for (const c of chicks) {
                        if (c.alive && c.y > ROAD_Y && !isHiding(c.x, c.y)) {
                            const cd = Math.sqrt((c.x - p.x)**2 + (c.y - p.y)**2);
                            if (cd < 22) {
                                c.alive = false;
                                chicksAlive--;
                                spawnParticles(c.x, c.y, [0.67, 0.40, 0.27], 12);
                                p.phase = 'leaving';
                                if (chicksAlive < 4) gameState = 'lose';
                            }
                        }
                    }

                    if (mamaHiding || dist > 250) {
                        p.phase = 'leaving';
                    }
                }
            } else if (p.phase === 'leaving') {
                p.x += p.facing * 4;
                if (p.x < -60 || p.x > W + 60) {
                    predators.splice(i, 1);
                }
            }

        } else if (p.type === 'hawk') {
            p.wingPhase += 0.12;

            if (p.phase === 'circling') {
                p.circleAngle += 0.018;
                const targetX = mama.x + Math.cos(p.circleAngle) * 70;
                const targetY = H * 0.15 + Math.sin(p.circleAngle * 0.5) * 12;
                p.x += (targetX - p.x) * 0.025;
                p.y += (targetY - p.y) * 0.025;

                p.swoopTimer--;

                if (p.swoopTimer <= 0) {
                    p.phase = 'swooping';
                    const exposedChicks = chicks.filter(c => c.alive && !isHiding(c.x, c.y));
                    if (exposedChicks.length > 0) {
                        const target = exposedChicks[Math.floor(Math.random() * exposedChicks.length)];
                        p.targetX = target.x;
                        p.targetY = target.y;
                    } else {
                        p.targetX = mama.x;
                        p.targetY = mama.y;
                    }
                }
            } else if (p.phase === 'swooping') {
                const dx = p.targetX - p.x;
                const dy = p.targetY - p.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                p.x += (dx / dist) * 8;
                p.y += (dy / dist) * 8;

                if (dist < 35) {
                    for (const c of chicks) {
                        if (c.alive) {
                            c.scared = 1;
                            c.vx += (Math.random() - 0.5) * 8;
                            c.vy += (Math.random() - 0.5) * 5;

                            if (!isHiding(c.x, c.y)) {
                                const cd = Math.sqrt((c.x - p.x)**2 + (c.y - p.y)**2);
                                if (cd < 40 && Math.random() < 0.2) {
                                    c.alive = false;
                                    chicksAlive--;
                                    spawnParticles(c.x, c.y, [0.67, 0.40, 0.27], 12);
                                    if (chicksAlive < 4) gameState = 'lose';
                                }
                            }
                        }
                    }
                    p.phase = 'climbing';
                    p.climbTimer = 40;
                }
            } else if (p.phase === 'climbing') {
                p.y -= 3;
                p.x += 2;
                p.climbTimer--;
                if (p.climbTimer <= 0) {
                    if (Math.random() < 0.6) {
                        p.phase = 'circling';
                        p.swoopTimer = 100 + Math.random() * 60;
                    } else {
                        p.phase = 'leaving';
                    }
                }
            } else if (p.phase === 'leaving') {
                p.x += 4;
                p.y -= 1.5;
                if (p.x > W + 80 || p.y < -50) {
                    predators.splice(i, 1);
                }
            }
        }
    }
}

function updateVehicles() {
    const safeSeason = Math.max(0, Math.min(3, currentSeason - 1));
    const season = SEASONS[safeSeason];

    let hawkPresent = false;
    for (const p of predators) {
        if (p.type === 'hawk') {
            hawkPresent = true;
            break;
        }
    }

    if (season !== 'Summer' && !hawkPresent) return;

    vehicleSpawnTimer--;
    if (vehicleSpawnTimer <= 0 && vehicles.length < 2) {
        const side = Math.random() > 0.5 ? 1 : -1;
        const speed = 3.5 + Math.random() * 2;
        vehicles.push({
            x: side > 0 ? -80 : W + 80,
            y: ROAD_Y + ROAD_H / 2,
            vx: side * speed,
            baseSpeed: speed,
            type: Math.random() > 0.5 ? 'car' : 'truck'
        });
        vehicleSpawnTimer = 200 + Math.random() * 150;
    }

    for (let i = vehicles.length - 1; i >= 0; i--) {
        const v = vehicles[i];
        v.x += v.vx;

        for (const c of chicks) {
            if (c.alive && isOnRoad(c.y)) {
                const dx = Math.abs(c.x - v.x);
                if (dx < 30) {
                    c.alive = false;
                    chicksAlive--;
                    spawnParticles(c.x, c.y, [0.5, 0.5, 0.5], 8);
                    if (chicksAlive < 4) gameState = 'lose';
                }
            }
        }

        if (isOnRoad(mama.y)) {
            const dx = Math.abs(mama.x - v.x);
            if (dx < 35) {
                gameState = 'lose';
            }
        }

        if (v.x < -100 || v.x > W + 100) {
            vehicles.splice(i, 1);
        }
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.15;
        p.life--;
        if (p.life <= 0) {
            particles.splice(i, 1);
        }
    }

    for (let i = leaves.length - 1; i >= 0; i--) {
        const l = leaves[i];
        l.x += l.vx + Math.sin(time * 0.05 + l.rot) * 0.5;
        l.y += l.vy;
        l.rot += l.rotSpeed;
        if (l.y > H + 10) {
            leaves.splice(i, 1);
        }
    }
}

function saveCompletion(level) {
    try {
        let completed = JSON.parse(localStorage.getItem('seaRanchQuestCompleted') || '[]');
        if (!completed.includes(level)) {
            completed.push(level);
            localStorage.setItem('seaRanchQuestCompleted', JSON.stringify(completed));
        }
    } catch (e) {}
}

// Drawing functions

function drawBackground() {
    const pal = getCurrentPalette();

    // Sky gradient
    for (let y = 0; y <= ROAD_Y; y++) {
        const t = y / ROAD_Y;
        ctx.strokeStyle = rgb(pal.sky[0] - t * 0.1, pal.sky[1] - t * 0.05, pal.sky[2]);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
    }

    // Hedgerow at horizon
    const sway = Math.sin(time * 0.02) * 2;
    ctx.fillStyle = rgb(0.22, 0.32, 0.22);
    for (let x = 0; x <= W; x += 25) {
        const h = 15 + Math.sin(x * 0.04) * 5;
        ctx.beginPath();
        ctx.ellipse(x + sway, ROAD_Y * 0.45 - h/2, 18, h, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    // Highlight layer
    ctx.fillStyle = rgb(0.17, 0.29, 0.17);
    for (let x = 10; x <= W; x += 35) {
        const h = 20 + Math.sin(x * 0.03) * 5;
        ctx.beginPath();
        ctx.ellipse(x + sway * 0.5, ROAD_Y * 0.45 - h, 12, 8, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    // Upper meadow
    ctx.fillStyle = rgb(pal.grass[0], pal.grass[1], pal.grass[2]);
    ctx.fillRect(0, ROAD_Y * 0.45, W, ROAD_Y * 0.55);

    // Road
    ctx.fillStyle = rgb(0.25, 0.25, 0.24);
    ctx.fillRect(0, ROAD_Y, W, ROAD_H);

    // Road lines
    ctx.strokeStyle = rgb(0.85, 0.80, 0.65);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, ROAD_Y);
    ctx.lineTo(W, ROAD_Y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, ROAD_Y + ROAD_H);
    ctx.lineTo(W, ROAD_Y + ROAD_H);
    ctx.stroke();

    // Dashed center line
    ctx.fillStyle = rgb(0.90, 0.85, 0.40);
    for (let x = 0; x <= W; x += 40) {
        ctx.fillRect(x, ROAD_Y + ROAD_H/2 - 1, 20, 2);
    }
}

function drawMeadow() {
    const pal = getCurrentPalette();
    const safeSeason = Math.max(0, Math.min(3, currentSeason - 1));
    const season = SEASONS[safeSeason];

    // Lower meadow base
    ctx.fillStyle = rgb(pal.grass[0], pal.grass[1], pal.grass[2]);
    ctx.fillRect(0, ROAD_Y + ROAD_H, W, H - ROAD_Y - ROAD_H);

    // Ground texture patches
    for (let i = 0; i < 40; i++) {
        const dx = (i * 47 + 23) % W;
        const dy = ROAD_Y + ROAD_H + 25 + (i * 31) % (H - ROAD_Y - ROAD_H - 45);
        ctx.fillStyle = rgb(pal.grass[0] - 0.1, pal.grass[1] - 0.08, pal.grass[2] - 0.06, 0.3);
        ctx.beginPath();
        ctx.ellipse(dx, dy, 3 + (i % 4), 1.5 + (i % 2), 0, 0, Math.PI * 2);
        ctx.fill();
    }

    // Bunch grasses
    const bunchColor = season === 'Spring' ? [0.54, 0.60, 0.44] :
                       season === 'Summer' ? [0.72, 0.66, 0.44] :
                       season === 'Fall' ? [0.66, 0.56, 0.37] : [0.56, 0.55, 0.47];

    ctx.strokeStyle = rgb(bunchColor[0], bunchColor[1], bunchColor[2]);
    ctx.lineWidth = 0.8;

    for (let i = 0; i < 45; i++) {
        const gx = 15 + (i * 14.3) % (W - 30);
        const gy = ROAD_Y + ROAD_H + 25 + (i * 11.7) % (H - ROAD_Y - ROAD_H - 40);
        const windSway = Math.sin(time * 0.015 + i * 0.6) * 3;
        const height = 8 + (i % 5) * 2.5;

        for (let j = 0; j <= 6; j++) {
            const spread = (j - 3) * 1.8;
            const lean = spread * 0.4 + windSway;
            ctx.beginPath();
            ctx.moveTo(gx, gy);
            ctx.lineTo(gx + spread * 1.5 + lean, gy - height * (0.7 + (j % 2) * 0.2));
            ctx.stroke();
        }
    }

    // Seed heads (not in spring)
    if (season !== 'Spring') {
        ctx.fillStyle = rgb(season === 'Winter' ? 0.63 : 0.78, season === 'Winter' ? 0.60 : 0.72, season === 'Winter' ? 0.53 : 0.53);
        for (let i = 0; i < 20; i++) {
            const sx = 30 + (i * 31) % (W - 60);
            const sy = ROAD_Y + ROAD_H + 20 + (i * 23) % (H - ROAD_Y - ROAD_H - 35);
            const sway = Math.sin(time * 0.015 + i) * 2;
            ctx.beginPath();
            ctx.ellipse(sx + sway, sy - 10, 1.5, 3, 0, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // Coyote brush shrubs
    for (let i = 0; i < 10; i++) {
        const bx = 45 + (i * 67) % (W - 90);
        const by = ROAD_Y + ROAD_H + 55 + (i * 41) % (H - ROAD_Y - ROAD_H - 90);
        const size = 8 + (i % 4) * 5;

        // Shadow
        ctx.fillStyle = rgb(0, 0, 0, 0.08);
        ctx.beginPath();
        ctx.ellipse(bx + 3, by + size * 0.35, size * 0.9, size * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();

        // Bush
        const bushColor = season === 'Winter' ? [0.35, 0.41, 0.34] :
                          season === 'Fall' ? [0.35, 0.42, 0.31] : [0.29, 0.35, 0.27];
        ctx.fillStyle = rgb(bushColor[0], bushColor[1], bushColor[2]);
        for (let c = 0; c <= 3; c++) {
            const cx = bx + (c - 1.5) * size * 0.25;
            const cy = by - c * size * 0.08;
            ctx.beginPath();
            ctx.ellipse(cx, cy, size * 0.5, size * 0.35, 0, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // Spring wildflowers
    if (season === 'Spring') {
        // California poppies
        ctx.fillStyle = rgb(0.91, 0.69, 0.19);
        for (let i = 0; i < 10; i++) {
            const fx = 25 + (i * 67) % (W - 50);
            const fy = ROAD_Y + ROAD_H + 30 + (i * 43) % (H - ROAD_Y - ROAD_H - 50);
            ctx.beginPath();
            ctx.arc(fx, fy, 2.5, 0, Math.PI * 2);
            ctx.fill();
        }
        // Lupines
        ctx.fillStyle = rgb(0.38, 0.31, 0.63);
        for (let i = 0; i < 6; i++) {
            const fx = 70 + (i * 97) % (W - 140);
            const fy = ROAD_Y + ROAD_H + 35 + (i * 53) % (H - ROAD_Y - ROAD_H - 60);
            ctx.beginPath();
            ctx.ellipse(fx, fy - 3, 2, 5, 0, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // Fall dried stalks
    if (season === 'Fall') {
        ctx.strokeStyle = rgb(0.63, 0.56, 0.44);
        ctx.lineWidth = 0.8;
        for (let i = 0; i < 8; i++) {
            const fx = 50 + (i * 79) % (W - 100);
            const fy = ROAD_Y + ROAD_H + 40 + (i * 47) % (H - ROAD_Y - ROAD_H - 60);
            ctx.beginPath();
            ctx.moveTo(fx, fy);
            ctx.lineTo(fx + 2, fy - 12);
            ctx.stroke();
            ctx.fillStyle = rgb(0.72, 0.66, 0.47);
            ctx.beginPath();
            ctx.arc(fx, fy, 1, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

function drawConstructionWorkers(houseX, houseY, scale) {
    ctx.save();
    ctx.translate(houseX, houseY);
    ctx.scale(scale, scale);

    // Worker 1
    const w1x = -70;
    const w1y = 5;
    const bobble1 = Math.sin(time * 0.08) * 1;

    // Hard hat
    ctx.fillStyle = rgb(0.91, 0.63, 0.13);
    ctx.beginPath();
    ctx.ellipse(w1x, w1y - 18 + bobble1, 5, 3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillRect(w1x - 6, w1y - 17 + bobble1, 12, 2);

    // Head
    ctx.fillStyle = rgb(0.83, 0.65, 0.46);
    ctx.beginPath();
    ctx.arc(w1x, w1y - 13 + bobble1, 4, 0, Math.PI * 2);
    ctx.fill();

    // Body
    ctx.fillStyle = rgb(0.29, 0.42, 0.54);
    ctx.fillRect(w1x - 4, w1y - 9 + bobble1, 8, 10);

    // Legs
    ctx.fillStyle = rgb(0.35, 0.29, 0.23);
    ctx.fillRect(w1x - 3, w1y + 1, 3, 8);
    ctx.fillRect(w1x + 1, w1y + 1, 3, 8);

    // Worker 2
    const w2x = 55;
    const w2y = 8;
    const bobble2 = Math.sin(time * 0.07 + 1) * 1;

    // Hard hat (white)
    ctx.fillStyle = rgb(0.94, 0.94, 0.94);
    ctx.beginPath();
    ctx.ellipse(w2x, w2y - 18 + bobble2, 5, 3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillRect(w2x - 6, w2y - 17 + bobble2, 12, 2);

    // Head
    ctx.fillStyle = rgb(0.77, 0.58, 0.39);
    ctx.beginPath();
    ctx.arc(w2x, w2y - 13 + bobble2, 4, 0, Math.PI * 2);
    ctx.fill();

    // Body (orange vest)
    ctx.fillStyle = rgb(0.88, 0.50, 0.19);
    ctx.fillRect(w2x - 4, w2y - 9 + bobble2, 8, 10);

    // Legs
    ctx.fillStyle = rgb(0.29, 0.29, 0.35);
    ctx.fillRect(w2x - 3, w2y + 1, 3, 8);
    ctx.fillRect(w2x + 1, w2y + 1, 3, 8);

    ctx.restore();
}

function drawBuilderDialogue() {
    const safeSeason = Math.max(0, Math.min(3, currentSeason - 1));
    const dialoguesPerSeason = 3;
    const dialogueDuration = SEASON_DURATION / dialoguesPerSeason;

    const seasonBase = safeSeason * dialoguesPerSeason;
    const dialogueInSeason = Math.min(dialoguesPerSeason - 1, Math.floor(seasonTimer / dialogueDuration));
    const dialogueIndex = seasonBase + dialogueInSeason;

    const dialogueTime = seasonTimer % dialogueDuration;
    const fadeFrames = 30;
    const showDuration = dialogueDuration - 80;

    if (dialogueTime > showDuration) return;

    let alpha = 1;
    if (dialogueTime < fadeFrames) {
        alpha = dialogueTime / fadeFrames;
    } else if (dialogueTime > showDuration - fadeFrames) {
        alpha = (showDuration - dialogueTime) / fadeFrames;
    }

    const text = DIALOGUES[dialogueIndex] || "";
    if (text === "") return;

    ctx.font = 'italic 14px Georgia';
    const textW = ctx.measureText(text).width;
    const padding = 10;

    const houseX = W - 95;
    let bubbleX = houseX - textW/2 - padding;
    const bubbleY = ROAD_Y * 0.35;
    const bubbleW = textW + padding * 2;
    const bubbleH = 26;

    bubbleX = Math.max(5, Math.min(W - bubbleW - 5, bubbleX));

    // Speech bubble background
    ctx.fillStyle = rgb(1, 1, 1, alpha * 0.95);
    ctx.beginPath();
    ctx.roundRect(bubbleX, bubbleY, bubbleW, bubbleH, 4);
    ctx.fill();

    // Speech bubble pointer
    ctx.beginPath();
    ctx.moveTo(houseX - 8, bubbleY + bubbleH);
    ctx.lineTo(houseX + 8, bubbleY + bubbleH);
    ctx.lineTo(houseX, bubbleY + bubbleH + 10);
    ctx.closePath();
    ctx.fill();

    // Bubble border
    ctx.strokeStyle = rgb(0.3, 0.25, 0.2, alpha * 0.8);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(bubbleX, bubbleY, bubbleW, bubbleH, 4);
    ctx.stroke();

    // Text
    ctx.fillStyle = rgb(0.2, 0.15, 0.1, alpha);
    ctx.fillText(text, bubbleX + padding, bubbleY + 17);
}

function drawHouse() {
    const stage = currentSeason - 1;  // 0-3
    const x = W - 95;
    const y = ROAD_Y * 0.72;
    const scale = 0.55;

    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);

    // Colors
    const redwood = [0.42, 0.31, 0.25];
    const redwoodDark = [0.29, 0.21, 0.16];
    const redwoodLight = [0.54, 0.44, 0.37];
    const metalRoof = [0.35, 0.38, 0.40];
    const metalHighlight = [0.48, 0.50, 0.52];
    const glassDay = [0.63, 0.78, 0.85];
    const glassDark = [0.19, 0.28, 0.34];

    if (stage >= 0) {
        // SPRING: Foundation and stakes
        ctx.fillStyle = rgb(0.35, 0.31, 0.27);
        ctx.fillRect(-55, 8, 12, 10);
        ctx.fillRect(-5, 8, 12, 10);
        ctx.fillRect(35, 8, 12, 10);

        // Survey stakes with orange flags
        ctx.strokeStyle = rgb(0.48, 0.38, 0.31);
        ctx.lineWidth = 1.5;
        const stakes = [-50, -20, 10, 40];
        for (const sx of stakes) {
            ctx.beginPath();
            ctx.moveTo(sx, 8);
            ctx.lineTo(sx, 22);
            ctx.stroke();
            ctx.fillStyle = rgb(0.88, 0.38, 0.13);
            ctx.fillRect(sx, 10, 6, 4);
        }
    }

    if (stage >= 1) {
        // SUMMER: Timber frame
        ctx.strokeStyle = rgb(0.42, 0.31, 0.22);
        ctx.lineWidth = 4;
        // Posts
        ctx.beginPath();
        ctx.moveTo(-50, 8); ctx.lineTo(-50, -55);
        ctx.moveTo(-25, 8); ctx.lineTo(-25, -55);
        ctx.moveTo(0, 8); ctx.lineTo(0, -35);
        ctx.moveTo(40, 8); ctx.lineTo(40, -35);
        ctx.stroke();

        // Beams
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-55, -55); ctx.lineTo(-20, -55);
        ctx.moveTo(-55, -55); ctx.lineTo(45, -25);
        ctx.moveTo(-5, -35); ctx.lineTo(45, -35);
        ctx.stroke();

        // Cross bracing
        ctx.lineWidth = 2;
        ctx.strokeStyle = rgb(0.35, 0.25, 0.19);
        ctx.beginPath();
        ctx.moveTo(-25, -20); ctx.lineTo(0, -35);
        ctx.moveTo(0, -10); ctx.lineTo(40, -25);
        ctx.stroke();
    }

    if (stage >= 2) {
        // FALL: Walls going up
        ctx.fillStyle = rgb(redwood[0], redwood[1], redwood[2]);
        ctx.beginPath();
        ctx.moveTo(-5, 8); ctx.lineTo(-5, -32); ctx.lineTo(45, -22); ctx.lineTo(45, 8);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = rgb(redwoodDark[0], redwoodDark[1], redwoodDark[2]);
        ctx.beginPath();
        ctx.moveTo(-55, 8); ctx.lineTo(-55, -52); ctx.lineTo(-20, -52); ctx.lineTo(-20, -38); ctx.lineTo(-5, -32); ctx.lineTo(-5, 8);
        ctx.closePath();
        ctx.fill();

        // Vertical siding lines
        ctx.strokeStyle = rgb(0.23, 0.15, 0.10);
        ctx.lineWidth = 0.5;
        for (let sx = -52; sx <= 42; sx += 6) {
            ctx.beginPath();
            if (sx < -20) {
                ctx.moveTo(sx, 8); ctx.lineTo(sx, -50);
            } else if (sx < -5) {
                ctx.moveTo(sx, 8); ctx.lineTo(sx, -38 + (sx + 20) * 0.4);
            } else {
                ctx.moveTo(sx, 8); ctx.lineTo(sx, -32 + (sx + 5) * 0.2);
            }
            ctx.stroke();
        }

        // Shed roof
        ctx.fillStyle = rgb(metalRoof[0], metalRoof[1], metalRoof[2]);
        ctx.beginPath();
        ctx.moveTo(-58, -52); ctx.lineTo(-17, -52); ctx.lineTo(48, -20); ctx.lineTo(48, -24); ctx.lineTo(-17, -56); ctx.lineTo(-58, -56);
        ctx.closePath();
        ctx.fill();

        // Window openings
        ctx.fillStyle = rgb(0.17, 0.15, 0.13);
        ctx.fillRect(-48, -40, 12, 18);
        ctx.fillRect(8, -18, 20, 14);
    }

    if (stage >= 3) {
        // WINTER: Finished house
        ctx.fillStyle = rgb(redwood[0], redwood[1], redwood[2]);
        ctx.beginPath();
        ctx.moveTo(-5, 8); ctx.lineTo(-5, -32); ctx.lineTo(45, -22); ctx.lineTo(45, 8);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = rgb(redwoodDark[0], redwoodDark[1], redwoodDark[2]);
        ctx.beginPath();
        ctx.moveTo(-55, 8); ctx.lineTo(-55, -52); ctx.lineTo(-20, -52); ctx.lineTo(-20, -38); ctx.lineTo(-5, -32); ctx.lineTo(-5, 8);
        ctx.closePath();
        ctx.fill();

        // Siding texture
        ctx.strokeStyle = rgb(0.23, 0.15, 0.09);
        ctx.lineWidth = 0.7;
        for (let sx = -53; sx <= 43; sx += 5) {
            ctx.beginPath();
            if (sx < -20) {
                ctx.moveTo(sx, 6); ctx.lineTo(sx, -50);
            } else if (sx < -5) {
                ctx.moveTo(sx, 6); ctx.lineTo(sx, -36 + (sx + 20) * 0.4);
            } else {
                ctx.moveTo(sx, 6); ctx.lineTo(sx, -30 + (sx + 5) * 0.2);
            }
            ctx.stroke();
        }

        // Metal roof
        ctx.fillStyle = rgb(metalRoof[0], metalRoof[1], metalRoof[2]);
        ctx.beginPath();
        ctx.moveTo(-58, -52); ctx.lineTo(-17, -52); ctx.lineTo(48, -20); ctx.lineTo(48, -25); ctx.lineTo(-17, -57); ctx.lineTo(-58, -57);
        ctx.closePath();
        ctx.fill();

        // Roof corrugation
        ctx.strokeStyle = rgb(metalHighlight[0], metalHighlight[1], metalHighlight[2]);
        ctx.lineWidth = 0.5;
        for (let ry = -55; ry <= -23; ry += 3) {
            const startX = ry < -52 ? -56 : (-17 + (ry + 52) * 2.6);
            ctx.beginPath();
            ctx.moveTo(startX, ry);
            ctx.lineTo(46, ry + 32);
            ctx.stroke();
        }

        // Tower window
        ctx.fillStyle = rgb(glassDark[0], glassDark[1], glassDark[2]);
        ctx.fillRect(-50, -45, 14, 28);
        ctx.strokeStyle = rgb(0.17, 0.13, 0.08);
        ctx.lineWidth = 1.5;
        ctx.strokeRect(-50, -45, 14, 28);
        ctx.beginPath();
        ctx.moveTo(-43, -45); ctx.lineTo(-43, -17);
        ctx.stroke();
        // Reflection
        ctx.fillStyle = rgb(0.63, 0.78, 0.86, 0.3);
        ctx.fillRect(-49, -44, 5, 12);

        // Main window
        ctx.fillStyle = rgb(glassDay[0], glassDay[1], glassDay[2]);
        ctx.fillRect(5, -18, 28, 14);
        ctx.strokeStyle = rgb(0.17, 0.13, 0.08);
        ctx.strokeRect(5, -18, 28, 14);
        ctx.beginPath();
        ctx.moveTo(19, -18); ctx.lineTo(19, -4);
        ctx.moveTo(5, -11); ctx.lineTo(33, -11);
        ctx.stroke();

        // Accent window
        ctx.fillStyle = rgb(glassDark[0], glassDark[1], glassDark[2]);
        ctx.fillRect(-32, -35, 8, 6);

        // Entry shadow
        ctx.fillStyle = rgb(0.10, 0.08, 0.06);
        ctx.fillRect(-8, -8, 10, 16);

        // Door
        ctx.fillStyle = rgb(redwoodLight[0], redwoodLight[1], redwoodLight[2]);
        ctx.fillRect(-7, -7, 8, 15);

        // Deck
        ctx.fillStyle = rgb(0.35, 0.27, 0.21);
        ctx.fillRect(-12, 6, 25, 4);

        // Chimney
        ctx.fillStyle = rgb(0.29, 0.29, 0.29);
        ctx.fillRect(-45, -62, 4, 10);
    }

    ctx.restore();

    // Construction workers (during building phases)
    if (currentSeason < 4) {
        drawConstructionWorkers(x, y, scale);
    }

    // Builder dialogue
    drawBuilderDialogue();
}

function drawBushes() {
    const season = SEASONS[currentSeason - 1];
    for (const b of bushes) {
        // Shadow
        ctx.fillStyle = rgb(0, 0, 0, 0.12);
        ctx.beginPath();
        ctx.ellipse(b.x + 3, b.y + b.h/2, b.w/2, 6, 0, 0, Math.PI * 2);
        ctx.fill();

        // Main
        ctx.fillStyle = rgb(season === 'Winter' ? 0.29 : 0.23, season === 'Winter' ? 0.35 : 0.35, season === 'Winter' ? 0.28 : 0.21);
        ctx.beginPath();
        ctx.ellipse(b.x, b.y, b.w/2, b.h/2, 0, 0, Math.PI * 2);
        ctx.fill();

        // Highlights
        ctx.fillStyle = rgb(season === 'Winter' ? 0.35 : 0.29, season === 'Winter' ? 0.42 : 0.42, season === 'Winter' ? 0.34 : 0.27);
        ctx.beginPath();
        ctx.ellipse(b.x - 6, b.y - 4, b.w/3, b.h/3, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = rgb(season === 'Winter' ? 0.42 : 0.35, season === 'Winter' ? 0.48 : 0.48, season === 'Winter' ? 0.41 : 0.34);
        ctx.beginPath();
        ctx.ellipse(b.x + 8, b.y - 2, b.w/4, b.h/4, 0, 0, Math.PI * 2);
        ctx.fill();
    }
}

function drawFood() {
    const season = SEASONS[currentSeason - 1];
    for (const f of food) {
        if (f.amount <= 0) continue;

        const scale = f.amount;

        // Stem
        ctx.strokeStyle = rgb(0.29, 0.42, 0.22);
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(f.x, f.y);
        ctx.lineTo(f.x, f.y - f.size * scale);
        ctx.stroke();

        // Leaves
        ctx.fillStyle = rgb(0.35, 0.54, 0.25);
        for (const leaf of f.leaves) {
            ctx.save();
            ctx.translate(f.x, f.y - f.size * 0.5 * scale);
            ctx.rotate(leaf.angle);
            ctx.beginPath();
            ctx.ellipse(f.size * 0.4 * scale * leaf.size, 0, 5 * scale, 3 * scale, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        // Berry/seed cluster
        ctx.fillStyle = rgb(season === 'Fall' ? 0.72 : 0.54, season === 'Fall' ? 0.47 : 0.42, season === 'Fall' ? 0.27 : 0.31);
        ctx.beginPath();
        ctx.arc(f.x, f.y - f.size * scale, 4 * scale, 0, Math.PI * 2);
        ctx.fill();
    }
}

function drawQuail(x, y, facing, bobPhase, isMama, size, scared) {
    const s = size || (isMama ? 14 : 8);
    scared = scared || 0;

    ctx.save();
    ctx.translate(x, y);
    ctx.scale(facing, 1);

    const bob = Math.sin(bobPhase) * 2;

    // Shadow
    ctx.fillStyle = rgb(0, 0, 0, 0.15);
    ctx.beginPath();
    ctx.ellipse(0, s * 0.4, s * 0.7, s * 0.15, 0, 0, Math.PI * 2);
    ctx.fill();

    // Body
    ctx.fillStyle = rgb(0.35 + scared * 0.2, 0.35, 0.42);
    ctx.beginPath();
    ctx.ellipse(0, bob, s * 0.6, s * 0.45, 0, 0, Math.PI * 2);
    ctx.fill();

    // Wing pattern
    ctx.fillStyle = rgb(0.45, 0.42, 0.50);
    ctx.beginPath();
    ctx.ellipse(-s * 0.15, bob + s * 0.1, s * 0.35, s * 0.25, 0, 0, Math.PI * 2);
    ctx.fill();

    // Breast
    ctx.fillStyle = rgb(0.55, 0.50, 0.45);
    ctx.beginPath();
    ctx.ellipse(s * 0.2, bob + s * 0.15, s * 0.25, s * 0.2, 0, 0, Math.PI * 2);
    ctx.fill();

    // Head
    ctx.fillStyle = rgb(0.16, 0.16, 0.23);
    ctx.beginPath();
    ctx.arc(s * 0.4, bob - s * 0.25, s * 0.25, 0, Math.PI * 2);
    ctx.fill();

    // Face markings
    ctx.strokeStyle = rgb(0.96, 0.96, 0.94);
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(s * 0.35, bob - s * 0.35);
    ctx.lineTo(s * 0.55, bob - s * 0.15);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(s * 0.35, bob - s * 0.15);
    ctx.lineTo(s * 0.55, bob - s * 0.35);
    ctx.stroke();

    // Eye
    ctx.fillStyle = rgb(0.10, 0.10, 0.10);
    ctx.beginPath();
    ctx.arc(s * 0.48, bob - s * 0.28, s * 0.06, 0, Math.PI * 2);
    ctx.fill();

    // Topknot plume
    ctx.fillStyle = rgb(0.10, 0.10, 0.12);
    const plumeWave = Math.sin(bobPhase * 2) * 0.1;
    ctx.beginPath();
    ctx.moveTo(s * 0.35, bob - s * 0.4);
    ctx.lineTo(s * 0.25 + plumeWave * s, bob - s * 0.85);
    ctx.lineTo(s * 0.45, bob - s * 0.45);
    ctx.closePath();
    ctx.fill();

    // Beak
    ctx.fillStyle = rgb(0.25, 0.22, 0.20);
    ctx.beginPath();
    ctx.moveTo(s * 0.55, bob - s * 0.25);
    ctx.lineTo(s * 0.75, bob - s * 0.22);
    ctx.lineTo(s * 0.55, bob - s * 0.18);
    ctx.closePath();
    ctx.fill();

    // Tail
    ctx.fillStyle = rgb(0.30, 0.28, 0.35);
    ctx.beginPath();
    ctx.moveTo(-s * 0.45, bob - s * 0.1);
    ctx.lineTo(-s * 0.75, bob - s * 0.15);
    ctx.lineTo(-s * 0.7, bob + s * 0.05);
    ctx.lineTo(-s * 0.45, bob + s * 0.1);
    ctx.closePath();
    ctx.fill();

    // Belly scales pattern
    ctx.strokeStyle = rgb(0.60, 0.55, 0.48);
    ctx.lineWidth = 0.5;
    for (let row = 0; row <= 2; row++) {
        for (let col = -1; col <= 1; col++) {
            ctx.beginPath();
            ctx.arc(s * 0.1 + col * s * 0.12, bob + s * 0.15 + row * s * 0.08, s * 0.06, 0, Math.PI);
            ctx.stroke();
        }
    }

    // Legs
    ctx.strokeStyle = rgb(0.35, 0.29, 0.23);
    ctx.lineWidth = isMama ? 1.5 : 1;
    const legMove = Math.sin(bobPhase * 2) * 1.5;
    ctx.beginPath();
    ctx.moveTo(-s * 0.1, s * 0.35);
    ctx.lineTo(-s * 0.15 + legMove, s * 0.6);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(s * 0.08, s * 0.35);
    ctx.lineTo(s * 0.1 - legMove, s * 0.6);
    ctx.stroke();

    ctx.restore();
}

function drawMamaQuail() {
    if (isHiding(mama.x, mama.y)) {
        ctx.fillStyle = rgb(0.16, 0.16, 0.23, 0.7);
        ctx.beginPath();
        ctx.arc(mama.x + mama.facing * 5, mama.y - 8, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = rgb(0.10, 0.10, 0.10);
        ctx.beginPath();
        ctx.arc(mama.x + mama.facing * 7, mama.y - 9, 1.5, 0, Math.PI * 2);
        ctx.fill();
        return;
    }

    drawQuail(mama.x, mama.y, mama.facing, mama.bobPhase, true);
}

function drawChicks() {
    for (const c of chicks) {
        if (!c.alive) continue;

        if (isHiding(c.x, c.y)) {
            ctx.fillStyle = rgb(0.35, 0.35, 0.42, 0.5);
            ctx.beginPath();
            ctx.arc(c.x, c.y - 3, 3, 0, Math.PI * 2);
            ctx.fill();
        } else {
            const facing = c.vx >= 0 ? 1 : -1;
            drawQuail(c.x, c.y, facing, c.bobPhase, false, c.size, c.scared);
        }
    }
}

function drawFox(p) {
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.scale(p.facing, 1);

    const legMove = Math.sin(p.runPhase) * 5;
    const runCrouch = Math.abs(Math.sin(p.runPhase * 0.5)) * 2;

    // Shadow
    ctx.fillStyle = rgb(0, 0, 0, 0.15);
    ctx.beginPath();
    ctx.ellipse(0, 18, 22, 5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Tail
    ctx.fillStyle = rgb(0.83, 0.34, 0.13);
    ctx.beginPath();
    ctx.moveTo(-12, 2); ctx.lineTo(-38, -5); ctx.lineTo(-32, 6); ctx.lineTo(-12, 4);
    ctx.closePath();
    ctx.fill();
    // White tip
    ctx.fillStyle = rgb(0.97, 0.94, 0.91);
    ctx.beginPath();
    ctx.ellipse(-40, -2, 5, 4, 0, 0, Math.PI * 2);
    ctx.fill();

    // Back legs
    ctx.save();
    ctx.translate(-8, 6);
    ctx.rotate(Math.sin(p.runPhase + Math.PI) * 0.4);
    ctx.fillStyle = rgb(0.66, 0.27, 0.08);
    ctx.fillRect(-2, 0, 4, 12);
    ctx.fillStyle = rgb(0.17, 0.10, 0.04);
    ctx.beginPath();
    ctx.ellipse(0, 12, 3, 2, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Front legs
    ctx.save();
    ctx.translate(10, 6);
    ctx.rotate(Math.sin(p.runPhase) * 0.4);
    ctx.fillStyle = rgb(0.66, 0.27, 0.08);
    ctx.fillRect(-2, 0, 4, 10);
    ctx.fillStyle = rgb(0.10, 0.10, 0.10);
    ctx.fillRect(-2, 7, 4, 4);
    ctx.beginPath();
    ctx.ellipse(0, 11, 3, 2, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Body
    ctx.fillStyle = rgb(0.83, 0.34, 0.13);
    ctx.beginPath();
    ctx.ellipse(0, -runCrouch, 18, 8, 0, 0, Math.PI * 2);
    ctx.fill();

    // Belly
    ctx.fillStyle = rgb(0.94, 0.85, 0.75);
    ctx.beginPath();
    ctx.ellipse(6, 4 - runCrouch, 10, 4, 0, 0, Math.PI * 2);
    ctx.fill();

    // Neck
    ctx.fillStyle = rgb(0.83, 0.34, 0.13);
    ctx.beginPath();
    ctx.ellipse(14, -3 - runCrouch, 8, 7, 0, 0, Math.PI * 2);
    ctx.fill();

    // Head
    ctx.beginPath();
    ctx.moveTo(18, -6 - runCrouch);
    ctx.lineTo(38, -4 - runCrouch);
    ctx.lineTo(18, 0 - runCrouch);
    ctx.closePath();
    ctx.fill();

    // White muzzle
    ctx.fillStyle = rgb(0.97, 0.94, 0.91);
    ctx.beginPath();
    ctx.ellipse(30, -2 - runCrouch, 6, 4, 0, 0, Math.PI * 2);
    ctx.fill();

    // Ears
    ctx.fillStyle = rgb(0.83, 0.34, 0.13);
    ctx.beginPath();
    ctx.moveTo(20, -8 - runCrouch); ctx.lineTo(17, -20 - runCrouch); ctx.lineTo(24, -10 - runCrouch);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(25, -9 - runCrouch); ctx.lineTo(24, -21 - runCrouch); ctx.lineTo(30, -11 - runCrouch);
    ctx.closePath();
    ctx.fill();
    // Inner ears
    ctx.fillStyle = rgb(0.91, 0.75, 0.63);
    ctx.beginPath();
    ctx.moveTo(20, -9 - runCrouch); ctx.lineTo(18, -17 - runCrouch); ctx.lineTo(23, -10 - runCrouch);
    ctx.closePath();
    ctx.fill();

    // Eye
    ctx.fillStyle = rgb(0.23, 0.17, 0.06);
    ctx.beginPath();
    ctx.ellipse(26, -6 - runCrouch, 3, 2.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = rgb(0.10, 0.10, 0.04);
    ctx.beginPath();
    ctx.ellipse(27, -6 - runCrouch, 1.5, 2, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = rgb(1, 1, 1);
    ctx.beginPath();
    ctx.arc(25.5, -7 - runCrouch, 1, 0, Math.PI * 2);
    ctx.fill();

    // Nose
    ctx.fillStyle = rgb(0.10, 0.10, 0.10);
    ctx.beginPath();
    ctx.ellipse(38, -3 - runCrouch, 2.5, 2, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
}

function drawHawk(p) {
    // Shadow on ground when swooping
    if (p.phase === 'swooping' || p.swoopTimer < 60) {
        const alpha = p.phase === 'swooping' ? 0.25 : ((60 - p.swoopTimer) / 60 * 0.2);
        ctx.fillStyle = rgb(0, 0, 0, alpha);
        ctx.beginPath();
        ctx.ellipse(p.targetX || mama.x, (p.targetY || mama.y) + 20, 30, 10, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.save();
    ctx.translate(p.x, p.y);

    const flap = Math.sin(p.wingPhase) * 0.35;

    // Body
    ctx.fillStyle = rgb(0.23, 0.17, 0.10);
    ctx.beginPath();
    ctx.ellipse(0, 0, 16, 6, 0, 0, Math.PI * 2);
    ctx.fill();

    // Wings
    ctx.fillStyle = rgb(0.29, 0.23, 0.17);
    // Left wing
    ctx.beginPath();
    ctx.moveTo(-4, 0);
    ctx.lineTo(-22, -16 + flap * 14);
    ctx.lineTo(-34, -2 + flap * 10);
    ctx.lineTo(-22, 5);
    ctx.closePath();
    ctx.fill();
    // Right wing
    ctx.beginPath();
    ctx.moveTo(4, 0);
    ctx.lineTo(22, -16 + flap * 14);
    ctx.lineTo(34, -2 + flap * 10);
    ctx.lineTo(22, 5);
    ctx.closePath();
    ctx.fill();

    // Head
    ctx.fillStyle = rgb(0.17, 0.10, 0.04);
    ctx.beginPath();
    ctx.arc(14, -1, 4, 0, Math.PI * 2);
    ctx.fill();

    // Beak
    ctx.fillStyle = rgb(0.35, 0.29, 0.13);
    ctx.beginPath();
    ctx.moveTo(17, -1);
    ctx.lineTo(22, 0);
    ctx.lineTo(17, 1);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
}

function drawVehicle(v) {
    ctx.save();
    ctx.translate(v.x, v.y);
    const facing = v.vx > 0 ? 1 : -1;
    ctx.scale(facing, 1);

    if (v.type === 'car') {
        // Shadow
        ctx.fillStyle = rgb(0, 0, 0, 0.2);
        ctx.beginPath();
        ctx.ellipse(0, 12, 30, 6, 0, 0, Math.PI * 2);
        ctx.fill();

        // Body
        ctx.fillStyle = rgb(0.35, 0.45, 0.55);
        ctx.fillRect(-25, -8, 50, 16);
        ctx.beginPath();
        ctx.moveTo(-15, -8); ctx.lineTo(-5, -18); ctx.lineTo(20, -18); ctx.lineTo(25, -8);
        ctx.closePath();
        ctx.fill();

        // Windows
        ctx.fillStyle = rgb(0.55, 0.70, 0.80);
        ctx.beginPath();
        ctx.moveTo(-12, -8); ctx.lineTo(-3, -16); ctx.lineTo(18, -16); ctx.lineTo(23, -8);
        ctx.closePath();
        ctx.fill();

        // Wheels
        ctx.fillStyle = rgb(0.15, 0.15, 0.15);
        ctx.beginPath();
        ctx.arc(-15, 8, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(15, 8, 6, 0, Math.PI * 2);
        ctx.fill();
    } else {
        // Truck
        ctx.fillStyle = rgb(0, 0, 0, 0.2);
        ctx.beginPath();
        ctx.ellipse(0, 14, 35, 7, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = rgb(0.60, 0.55, 0.45);
        ctx.fillRect(-30, -6, 25, 18);
        ctx.fillRect(-5, -12, 35, 24);

        ctx.fillStyle = rgb(0.45, 0.60, 0.70);
        ctx.fillRect(5, -10, 20, 10);

        ctx.fillStyle = rgb(0.15, 0.15, 0.15);
        ctx.beginPath();
        ctx.arc(-18, 12, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(18, 12, 7, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.restore();
}

function drawPredators() {
    for (const p of predators) {
        if (p.type === 'fox') {
            drawFox(p);
        } else if (p.type === 'hawk') {
            drawHawk(p);
        }
    }
}

function drawVehicles() {
    for (const v of vehicles) {
        drawVehicle(v);
    }
}

function drawParticles() {
    for (const p of particles) {
        const alpha = p.life / 50;
        ctx.fillStyle = rgb(p.color[0], p.color[1], p.color[2], alpha);
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
        ctx.fill();
    }

    // Fall leaves
    for (const l of leaves) {
        ctx.save();
        ctx.translate(l.x, l.y);
        ctx.rotate(l.rot);
        ctx.fillStyle = rgb(l.color[0], l.color[1], l.color[2]);
        ctx.beginPath();
        ctx.ellipse(0, 0, 4, 2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

function drawUI() {
    const season = SEASONS[currentSeason - 1];

    // Season indicator
    if (seasonAnnounceTimer > 0) {
        const alpha = Math.min(1, seasonAnnounceTimer / 30);
        ctx.fillStyle = rgb(0, 0, 0, alpha * 0.6);
        ctx.fillRect(W/2 - 70, 8, 140, 30);
        ctx.fillStyle = rgb(1, 1, 1, alpha);
        ctx.font = 'bold 24px Georgia';
        ctx.textAlign = 'center';
        ctx.fillText(season, W/2, 30);
        ctx.textAlign = 'left';
    }

    // Chicks alive
    ctx.fillStyle = rgb(0, 0, 0, 0.5);
    ctx.fillRect(8, 8, 70, 28);
    ctx.fillStyle = rgb(1, 1, 1);
    ctx.font = '14px Georgia';
    ctx.fillText('Chicks: ' + chicksAlive, 15, 26);

    // Hunger indicator
    if (hunger > 60) {
        const urgency = (hunger - 60) / 40;
        const alpha = 0.5 + urgency * 0.5;
        ctx.fillStyle = rgb(hunger > 80 ? 0.75 : 0.75, hunger > 80 ? 0.25 : 0.63, hunger > 80 ? 0.25 : 0.25, alpha);
        ctx.font = 'italic 14px Georgia';
        ctx.textAlign = 'center';
        ctx.fillText('hungry...', W/2, 34);
        ctx.textAlign = 'left';
    }

    // Progress bar
    const progress = ((currentSeason - 1) * SEASON_DURATION + seasonTimer) / (4 * SEASON_DURATION);
    ctx.fillStyle = rgb(0, 0, 0, 0.4);
    ctx.fillRect(W - 110, 8, 100, 12);
    ctx.fillStyle = rgb(0.5, 0.7, 0.5);
    ctx.fillRect(W - 108, 10, 96 * progress, 8);

    // Control hint
    ctx.fillStyle = rgb(1, 1, 1, 0.6);
    ctx.font = '11px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('ARROWS: MOVE   ESC: MENU', W/2, 472);
    ctx.textAlign = 'left';
}

function drawGrain(intensity) {
    const imageData = ctx.getImageData(0, 0, W, H);
    const data = imageData.data;
    const strength = intensity * 25;

    for (let i = 0; i < data.length; i += 4) {
        const noise = (Math.random() - 0.5) * strength;
        data[i] = Math.max(0, Math.min(255, data[i] + noise));
        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
    }

    ctx.putImageData(imageData, 0, 0);
}

function drawTitleScreen() {
    // Background
    ctx.fillStyle = rgb(0.53, 0.71, 0.82);
    ctx.fillRect(0, 0, W, H);

    // Meadow
    ctx.fillStyle = rgb(0.47, 0.59, 0.35);
    ctx.fillRect(0, H * 0.5, W, H * 0.5);

    // Title
    ctx.fillStyle = rgb(0.2, 0.15, 0.1);
    ctx.font = 'bold 48px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('Covey', W/2, 180);

    // Subtitle
    ctx.fillStyle = rgb(0.35, 0.30, 0.25);
    ctx.font = 'italic 18px Georgia';
    ctx.fillText('Survive a year in the life', W/2, 220);

    // Draw mama and some chicks
    drawQuail(W/2 - 40, H/2 + 50, 1, time * 0.1, true);
    for (let i = 0; i < 5; i++) {
        drawQuail(W/2 + 10 + i * 18, H/2 + 55 + Math.sin(i) * 5, 1, time * 0.1 + i, false, 6);
    }

    // Start prompt
    ctx.fillStyle = rgb(0.2, 0.15, 0.1, 0.5 + Math.sin(time * 0.1) * 0.3);
    ctx.font = '16px Georgia';
    ctx.fillText('Press SPACE or tap to start', W/2, H - 60);

    ctx.textAlign = 'left';

    drawGrain(0.03);
}

function drawWinScreen() {
    ctx.fillStyle = rgb(0, 0, 0, 0.5);
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = rgb(0.91, 0.85, 0.70);
    ctx.font = 'bold 36px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('Year Complete!', W/2, 180);

    ctx.fillStyle = rgb(0.75, 0.70, 0.60);
    ctx.font = 'italic 18px Georgia';
    ctx.fillText(chicksAlive + ' of ' + CHICK_COUNT + ' chicks survived', W/2, 230);

    ctx.fillStyle = rgb(0.6, 0.55, 0.45);
    ctx.font = '14px Georgia';
    ctx.fillText('A: CONTINUE    B: MENU', W/2, H - 50);

    ctx.textAlign = 'left';
}

function drawLoseScreen() {
    ctx.fillStyle = rgb(0, 0, 0, 0.5);
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = rgb(0.77, 0.12, 0.23);
    ctx.font = 'bold 36px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('Covey Lost', W/2, 180);

    ctx.fillStyle = rgb(0.45, 0.35, 0.28);
    ctx.font = 'italic 18px Georgia';
    ctx.fillText('Too many chicks were lost', W/2, 230);

    ctx.fillStyle = rgb(0.45, 0.35, 0.28);
    ctx.font = '14px Georgia';
    ctx.fillText('A: RETRY    B: MENU', W/2, H - 50);

    ctx.textAlign = 'left';
}

function update() {
    // Clear just pressed
    for (const key in justPressed) {
        justPressed[key] = false;
    }
}

function gameLoop() {
    // Update shake
    if (shakeAmount > 0) {
        shakeX = (Math.random() - 0.5) * shakeAmount;
        shakeY = (Math.random() - 0.5) * shakeAmount;
        shakeAmount *= 0.9;
        if (shakeAmount < 0.5) shakeAmount = 0;
    } else {
        shakeX = 0;
        shakeY = 0;
    }

    if (gameState === 'title') {
        time++;
        drawTitleScreen();

        if (wasJustPressed('a')) {
            setupLevel();
            gameState = 'playing';
        }
    } else if (gameState === 'playing') {
        time++;
        updateSeason();
        updateMama();
        updateChicks();
        updateHunger();
        updatePredators();
        updateVehicles();
        updateParticles();

        if (wasJustPressed('b')) {
            window.location.href = 'index.html';
            return;
        }

        // Draw with shake
        ctx.save();
        ctx.translate(shakeX, shakeY);

        drawBackground();
        drawMeadow();
        drawHouse();
        drawBushes();
        drawFood();
        drawVehicles();
        drawPredators();
        drawChicks();
        drawMamaQuail();
        drawParticles();

        ctx.restore();

        drawUI();
        drawGrain(0.05);

    } else if (gameState === 'win') {
        time++;

        ctx.save();
        ctx.translate(shakeX, shakeY);

        drawBackground();
        drawMeadow();
        drawHouse();
        drawBushes();
        drawFood();
        drawVehicles();
        drawPredators();
        drawChicks();
        drawMamaQuail();
        drawParticles();

        ctx.restore();

        drawWinScreen();
        drawGrain(0.05);

        if (wasJustPressed('a')) {
            setupLevel();
            gameState = 'playing';
        }
        if (wasJustPressed('b')) {
            window.location.href = 'index.html';
        }

    } else if (gameState === 'lose') {
        time++;

        ctx.save();
        ctx.translate(shakeX, shakeY);

        drawBackground();
        drawMeadow();
        drawHouse();
        drawBushes();
        drawFood();
        drawVehicles();
        drawPredators();
        drawChicks();
        drawMamaQuail();
        drawParticles();

        ctx.restore();

        drawLoseScreen();
        drawGrain(0.05);

        if (wasJustPressed('a')) {
            setupLevel();
            gameState = 'playing';
        }
        if (wasJustPressed('b')) {
            window.location.href = 'index.html';
        }
    }

    update();
    requestAnimationFrame(gameLoop);
}

// Start the game
gameLoop();
</script>
</body>
</html>
