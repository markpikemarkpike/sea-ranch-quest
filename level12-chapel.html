<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Level 12: Chapel Meditation - Sea Ranch Quest</title>
    <script src="sea-ranch-style.js"></script>
<style>
:root {
    --black: #1a1a1a;
    --white: #f5f5f0;
    --red: #C41E3A;
    --blue: #2E5DA8;
    --wood: #8b7355;
    --wood-light: #a89070;
    --wood-dark: #5c4a3a;
    --sand: #d4c4a8;
    --fog: #e8e4dc;
}

*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background: #1a1a1a;
    display: flex;
    justify-content: center;
    align-items: center;
    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
}

#game-container {
    width: 640px;
    height: 480px;
    position: relative;
    overflow: hidden;
    background: var(--fog);
}

#gameCanvas {
    display: block;
    width: 640px;
    height: 480px;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
}

/* HTML/CSS Title Card */
.title-card {
    position: absolute;
    inset: 0;
    z-index: 200;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}
.title-card .wood-bg {
    position: absolute;
    inset: 0;
    background:
        repeating-linear-gradient(90deg, transparent 0px, transparent 3px, rgba(139, 115, 85, 0.08) 3px, rgba(139, 115, 85, 0.08) 4px),
        radial-gradient(ellipse at 20% 30%, rgba(139, 115, 85, 0.15) 0%, transparent 50%),
        radial-gradient(ellipse at 70% 60%, rgba(139, 115, 85, 0.1) 0%, transparent 40%),
        radial-gradient(ellipse at 40% 80%, rgba(139, 115, 85, 0.12) 0%, transparent 45%),
        linear-gradient(180deg, var(--fog) 0%, var(--sand) 100%);
}
.title-card .supergraphic {
    position: absolute;
    top: -80px;
    right: -120px;
    width: 550px;
    height: 550px;
    pointer-events: none;
}
.title-card .supergraphic::before,
.title-card .supergraphic::after {
    content: '';
    position: absolute;
    border-radius: 50%;
    border: 36px solid var(--blue);
}
.title-card .supergraphic::before {
    width: 420px;
    height: 420px;
    top: 0;
    right: 0;
    border-color: transparent transparent var(--blue) var(--blue);
    transform: rotate(-45deg);
}
.title-card .supergraphic::after {
    width: 320px;
    height: 320px;
    top: 50px;
    right: 50px;
    border-color: transparent transparent var(--blue) var(--blue);
    transform: rotate(-45deg);
    opacity: 0.7;
}
.title-card .arrow-accent {
    position: absolute;
    bottom: 30px;
    left: 30px;
    width: 80px;
    height: 100px;
    pointer-events: none;
}
.title-card .arrow-accent::before {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    border-left: 40px solid transparent;
    border-right: 40px solid transparent;
    border-bottom: 50px solid var(--red);
    top: 0;
}
.title-card .arrow-accent::after {
    content: '';
    position: absolute;
    width: 26px;
    height: 50px;
    background: var(--red);
    top: 45px;
    left: 27px;
}
.title-card .title-content {
    position: relative;
    z-index: 10;
    text-align: center;
}
.title-card .level-title {
    font-size: 56px;
    font-weight: 700;
    color: var(--black);
    letter-spacing: -2px;
    line-height: 1;
    margin-bottom: 10px;
}
.title-card .level-subtitle {
    font-size: 18px;
    font-weight: 400;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: var(--wood);
}
.title-card .continue-hint {
    position: absolute;
    bottom: 36px;
    right: 36px;
    font-size: 12px;
    color: var(--wood);
    text-transform: uppercase;
    letter-spacing: 1px;
}
.title-card .title-grain {
    position: absolute;
    inset: 0;
    opacity: 0.4;
    pointer-events: none;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%' height='100%' filter='url(%23noise)'/%3E%3C/svg%3E");
}
</style>
</head>
<body>
<div id="game-container">
    <div class="title-card" id="title-card">
        <div class="wood-bg"></div>
        <div class="supergraphic"></div>
        <div class="arrow-accent"></div>
        <div class="title-content">
            <div class="level-title">Chapel</div>
            <div class="level-subtitle">A Peaceful Meditation</div>
        </div>
        <div class="continue-hint">A to start Â· ESC to menu</div>
        <div class="title-grain"></div>
    </div>
    <canvas id="gameCanvas" width="480" height="320"></canvas>
</div>
<script>
// ============================================================================
// LEVEL 12: CHAPEL MEDITATION
// The final level - A peaceful meditation at the Sea Ranch Chapel
// ============================================================================

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Load the chapel background image
const chapelBg = new Image();
chapelBg.src = 'level-12/scene-4-chunky.png';

// Sea Ranch Design System
const COLORS = {
    black: '#1a1a1a',
    white: '#f5f5f0',
    red: '#C41E3A',
    blue: '#2E5DA8',
    wood: '#8b7355',
    woodLight: '#a89070',
    woodDark: '#5c4a3a',
    sand: '#d4c4a8',
    fog: '#e8e4dc',
    sky: '#87CEEB',

    // Stained glass palette (from real chapel photos)
    turquoise: '#00a5a5',
    turquoiseLight: '#40c4c4',
    turquoiseDark: '#007a7a',
    yellow: '#e8c547',
    yellowLight: '#f0d870',
    pink: '#e8788c',
    pinkLight: '#f0a0b0',
    green: '#6b9b4a',
    copper: '#8b6b4a'
};

// Game states
const GameState = {
    TITLE: 'title',
    WALKING_TO_CHAPEL: 'walking_to_chapel',
    ENTERING_CHAPEL: 'entering_chapel',
    SITTING_DOWN: 'sitting_down',
    MEDITATION: 'meditation',
    LEVEL_COMPLETE: 'level_complete'
};

let state = GameState.TITLE;
let stateTimer = 0;

// Walking phase - now walking UP the path (bottom to top of screen)
let playerY = 340; // Start below screen
let playerX = 280; // Center on the path
let playerScale = 1.5; // Start larger (closer)
let playerWalkFrame = 0;

// Meditation phase
let breathPhase = 'waiting'; // 'waiting', 'inhale', 'exhale'
let breathProgress = 0; // 0-1 for current breath action
let breathCycleCount = 0;
let totalBreathCycles = 6; // 6 complete breath cycles
let inhaleHoldTime = 0;
let exhaleHoldTime = 0;
let currentGlow = 0; // Current glow during inhale (0-1)
let unlockedSections = 0; // How many stained glass sections are permanently lit
let meditationStartTime = 0;
let meditationDuration = 150000; // 2.5 minutes in ms

// Key states
let aKeyHeld = false;
let bKeyHeld = false;

// Breath timing (in frames at 60fps)
const INHALE_DURATION = 240; // 4 seconds
const EXHALE_DURATION = 300; // 5 seconds
const HOLD_THRESHOLD = 20; // Brief delay before counting

// ============================================================================
// DRAWING HELPERS
// ============================================================================

function drawText(text, x, y, size, color, align = 'left', weight = '700') {
    ctx.font = SeaRanchStyle.makeFont(size, weight);
    ctx.fillStyle = color;
    ctx.textAlign = align;
    ctx.fillText(text, x, y);
}

// ============================================================================
// 8-BIT CHARACTER (walking UP the path toward chapel)
// ============================================================================

function draw8BitCharacterBack(x, y, frame, scale = 1) {
    // Character from BEHIND walking away (up the screen)
    const s = 2 * scale;

    // Head (back of head)
    ctx.fillStyle = '#d4a574'; // Skin tone
    ctx.fillRect(x - 2*s, y, 4*s, 4*s);

    // Hair (blonde, back of head)
    ctx.fillStyle = '#d4b896';
    ctx.fillRect(x - 2*s, y, 4*s, 3*s);
    ctx.fillRect(x - 2.5*s, y + 1*s, 5*s, 2*s);

    // Body (turquoise hoodie - back view)
    ctx.fillStyle = COLORS.turquoiseLight;
    ctx.fillRect(x - 3*s, y + 4*s, 6*s, 6*s);

    // Hood bunched at neck
    ctx.fillStyle = '#35a5a5';
    ctx.fillRect(x - 2*s, y + 3.5*s, 4*s, 1.5*s);

    // Shorts (coral/red)
    ctx.fillStyle = '#e87070';
    ctx.fillRect(x - 2*s, y + 10*s, 4*s, 3*s);

    // Legs - animate walking (back view)
    ctx.fillStyle = '#d4a574';
    const legOffset = Math.sin(frame * 0.5) * 1.5;
    ctx.fillRect(x - 1.5*s + legOffset*s, y + 13*s, 1.5*s, 4*s);
    ctx.fillRect(x + 0*s - legOffset*s, y + 13*s, 1.5*s, 4*s);

    // Shoes (blue)
    ctx.fillStyle = COLORS.blue;
    ctx.fillRect(x - 1.5*s + legOffset*s, y + 17*s, 2*s, 1*s);
    ctx.fillRect(x - 0.5*s - legOffset*s, y + 17*s, 2*s, 1*s);
}

// ============================================================================
// CHAPEL EXTERIOR - Character walks UP the path
// ============================================================================

function drawChapelExterior() {
    // Draw the 8-bit chapel scene from the loaded image
    if (chapelBg.complete) {
        ctx.drawImage(chapelBg, 0, 0, 480, 320);
    } else {
        drawFallbackExterior();
    }

    // Draw character walking up the stone path toward chapel
    // The path goes from bottom-center toward the chapel
    draw8BitCharacterBack(playerX, playerY, playerWalkFrame, playerScale);
}

function drawFallbackExterior() {
    // Sky gradient
    const skyGrad = ctx.createLinearGradient(0, 0, 0, 200);
    skyGrad.addColorStop(0, '#87CEEB');
    skyGrad.addColorStop(1, '#b0d4e8');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, 480, 200);

    // Ground/grass
    ctx.fillStyle = '#6b8b4a';
    ctx.fillRect(0, 200, 480, 120);

    // Stone path (perspective - wider at bottom)
    ctx.fillStyle = '#a0a090';
    ctx.beginPath();
    ctx.moveTo(200, 320);
    ctx.lineTo(280, 320);
    ctx.lineTo(255, 250);
    ctx.lineTo(225, 250);
    ctx.closePath();
    ctx.fill();

    // Chapel shape
    ctx.fillStyle = COLORS.woodDark;
    ctx.beginPath();
    ctx.moveTo(200, 130);
    ctx.lineTo(280, 130);
    ctx.lineTo(300, 200);
    ctx.lineTo(180, 200);
    ctx.closePath();
    ctx.fill();
}

// ============================================================================
// CHAPEL INTERIOR - SITTING IN PEW (much clearer)
// ============================================================================

function drawChapelInteriorSitting(sitProgress) {
    // Interior background - warm wood tones
    const woodGrad = ctx.createLinearGradient(0, 0, 0, 320);
    woodGrad.addColorStop(0, '#6b5040');
    woodGrad.addColorStop(0.6, '#5a4535');
    woodGrad.addColorStop(1, '#4a3a2a');
    ctx.fillStyle = woodGrad;
    ctx.fillRect(0, 0, 480, 320);

    // Curved wooden ribs on walls (like real chapel)
    ctx.strokeStyle = '#4a3525';
    ctx.lineWidth = 10;
    for (let i = 0; i < 15; i++) {
        ctx.beginPath();
        ctx.moveTo(i * 40 - 60, 320);
        ctx.quadraticCurveTo(i * 35, 100, 240, 10);
        ctx.stroke();
    }

    // Lighter rib edges
    ctx.strokeStyle = '#7a6550';
    ctx.lineWidth = 2;
    for (let i = 0; i < 15; i++) {
        ctx.beginPath();
        ctx.moveTo(i * 40 - 58, 320);
        ctx.quadraticCurveTo(i * 35 + 2, 100, 242, 10);
        ctx.stroke();
    }

    // Stone floor
    ctx.fillStyle = '#6a6a60';
    ctx.fillRect(0, 240, 480, 80);

    // Stone pattern on floor
    ctx.strokeStyle = '#5a5a50';
    ctx.lineWidth = 2;
    for (let x = 0; x < 500; x += 50) {
        for (let y = 240; y < 320; y += 30) {
            const offsetX = (y % 60 === 0) ? 0 : 25;
            ctx.strokeRect(x + offsetX - 25, y, 48, 28);
        }
    }

    // Stained glass window in background (dim, not yet activated)
    drawStainedGlassWindow(140, 50, 200, 110, 0, 0);

    // === WOODEN PEW - Very clear and obvious ===
    const pewY = 180 + sitProgress * 15;

    // Pew back rest (tall, visible)
    ctx.fillStyle = '#5c4a3a';
    ctx.fillRect(80, pewY - 50, 320, 55);

    // Pew back top edge (lighter)
    ctx.fillStyle = '#8b7355';
    ctx.fillRect(80, pewY - 52, 320, 6);

    // Vertical slats on pew back
    ctx.strokeStyle = '#4a3a2a';
    ctx.lineWidth = 3;
    for (let x = 100; x < 400; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, pewY - 45);
        ctx.lineTo(x, pewY);
        ctx.stroke();
    }

    // Pew seat (horizontal, where you sit)
    ctx.fillStyle = '#7a6550';
    ctx.fillRect(75, pewY + 5, 330, 20);

    // Seat top surface (lighter, polished look)
    ctx.fillStyle = '#9a8570';
    ctx.fillRect(78, pewY + 5, 324, 8);

    // Pew legs/supports (visible on sides)
    ctx.fillStyle = '#5c4a3a';
    ctx.fillRect(80, pewY + 20, 15, 35);
    ctx.fillRect(385, pewY + 20, 15, 35);

    // === PERSON SITTING ON PEW ===
    const personY = 135 + sitProgress * 25;

    // Body first (behind head)
    // Torso in hoodie (sitting, slightly hunched forward in meditation)
    ctx.fillStyle = COLORS.turquoiseLight;

    // Main torso
    ctx.fillRect(215, personY + 25, 50, 45);

    // Shoulders (rounded)
    ctx.beginPath();
    ctx.arc(220, personY + 30, 12, Math.PI, 0, true);
    ctx.arc(260, personY + 30, 12, Math.PI, 0, true);
    ctx.fill();

    // Arms resting on lap
    ctx.fillRect(200, personY + 50, 20, 25);
    ctx.fillRect(260, personY + 50, 20, 25);

    // Head (back view)
    ctx.fillStyle = '#d4a574';
    ctx.beginPath();
    ctx.arc(240, personY + 12, 18, 0, Math.PI * 2);
    ctx.fill();

    // Hair
    ctx.fillStyle = '#c4a070';
    ctx.beginPath();
    ctx.arc(240, personY + 8, 18, Math.PI, 2 * Math.PI);
    ctx.ellipse(240, personY + 10, 19, 12, 0, Math.PI * 0.8, Math.PI * 0.2, true);
    ctx.fill();

    // Neck
    ctx.fillStyle = '#d4a574';
    ctx.fillRect(232, personY + 22, 16, 10);

    // Hoodie collar/hood
    ctx.fillStyle = '#35a5a5';
    ctx.beginPath();
    ctx.ellipse(240, personY + 28, 22, 8, 0, 0, Math.PI);
    ctx.fill();

    // Shorts visible at edge of seat
    ctx.fillStyle = '#e87070';
    ctx.fillRect(220, personY + 68, 18, 10);
    ctx.fillRect(248, personY + 68, 18, 10);

    // Legs dangling or feet on floor
    ctx.fillStyle = '#d4a574';
    ctx.fillRect(222, personY + 78, 14, 15);
    ctx.fillRect(250, personY + 78, 14, 15);

    // Shoes
    ctx.fillStyle = COLORS.blue;
    ctx.fillRect(220, personY + 93, 18, 8);
    ctx.fillRect(248, personY + 93, 18, 8);

    // Text indicator
    if (sitProgress < 0.5) {
        drawText('Taking a seat...', 240, 30, 14, COLORS.white, 'center', '400');
    } else {
        drawText('Beginning meditation...', 240, 30, 14, COLORS.white, 'center', '400');
    }
}

// ============================================================================
// MEDITATION VIEW - POV FROM BEHIND LOOKING AT STAINED GLASS
// Progressive unlocking of stained glass sections
// ============================================================================

function drawMeditationView() {
    // Dark interior - focus on the window
    const interiorGrad = ctx.createRadialGradient(240, 100, 30, 240, 160, 300);
    interiorGrad.addColorStop(0, '#3a3530');
    interiorGrad.addColorStop(1, '#1a1815');
    ctx.fillStyle = interiorGrad;
    ctx.fillRect(0, 0, 480, 320);

    // Curved wooden ribs - more prominent, darker
    ctx.strokeStyle = '#2a2520';
    ctx.lineWidth = 14;
    for (let i = 0; i < 20; i++) {
        ctx.beginPath();
        const startX = i * 30 - 60;
        ctx.moveTo(startX, 320);
        ctx.quadraticCurveTo(startX + 40, 80, 240, -30);
        ctx.stroke();
    }

    // Lighter rib highlights
    ctx.strokeStyle = '#4a4035';
    ctx.lineWidth = 3;
    for (let i = 0; i < 20; i++) {
        ctx.beginPath();
        const startX = i * 30 - 58;
        ctx.moveTo(startX, 320);
        ctx.quadraticCurveTo(startX + 42, 80, 242, -30);
        ctx.stroke();
    }

    // Stone base wall
    ctx.fillStyle = '#4a4a42';
    ctx.fillRect(0, 170, 480, 150);

    // Stone texture
    for (let x = -20; x < 500; x += 40) {
        for (let y = 170; y < 320; y += 28) {
            const offsetX = (y % 56 === 0) ? 0 : 20;
            ctx.fillStyle = '#3a3a35';
            ctx.fillRect(x + offsetX, y, 38, 26);
            ctx.strokeStyle = '#2a2a25';
            ctx.lineWidth = 2;
            ctx.strokeRect(x + offsetX, y, 38, 26);
        }
    }

    // Draw the large stained glass window with progressive unlocking
    drawStainedGlassWindow(90, 15, 300, 155, currentGlow, unlockedSections);

    // Silhouette of person's head/shoulders at bottom (meditating)
    ctx.fillStyle = '#0a0a08';

    // Shoulders (wider, peaceful posture)
    ctx.beginPath();
    ctx.moveTo(100, 320);
    ctx.quadraticCurveTo(160, 275, 240, 285);
    ctx.quadraticCurveTo(320, 275, 380, 320);
    ctx.lineTo(100, 320);
    ctx.fill();

    // Head silhouette (slightly bowed in meditation)
    ctx.beginPath();
    ctx.ellipse(240, 268, 28, 32, 0, 0, Math.PI * 2);
    ctx.fill();

    // Light rays from window based on unlocked sections + current glow
    const totalLight = (unlockedSections / 6) * 0.7 + currentGlow * 0.3;
    if (totalLight > 0.1) {
        ctx.globalAlpha = totalLight * 0.5;
        const rayGrad = ctx.createRadialGradient(240, 90, 10, 240, 220, 250);

        // Color shifts based on unlocked sections
        if (unlockedSections >= 5) {
            rayGrad.addColorStop(0, '#ffffff');
            rayGrad.addColorStop(0.3, COLORS.yellowLight);
            rayGrad.addColorStop(0.6, COLORS.turquoiseLight);
        } else if (unlockedSections >= 3) {
            rayGrad.addColorStop(0, COLORS.yellowLight);
            rayGrad.addColorStop(0.5, COLORS.turquoiseLight);
        } else {
            rayGrad.addColorStop(0, COLORS.turquoiseLight);
        }
        rayGrad.addColorStop(1, 'transparent');

        ctx.fillStyle = rayGrad;
        ctx.fillRect(0, 0, 480, 320);
        ctx.globalAlpha = 1;
    }

    // Color spots on floor from stained glass (grow with unlocked sections)
    if (unlockedSections > 0) {
        const spotAlpha = 0.3 + (unlockedSections / 6) * 0.5;
        ctx.globalAlpha = spotAlpha;

        // Turquoise spots (sections 1-2)
        if (unlockedSections >= 1) {
            ctx.fillStyle = COLORS.turquoise;
            ctx.beginPath();
            ctx.ellipse(180, 250, 20 + unlockedSections * 3, 10, -0.2, 0, Math.PI * 2);
            ctx.fill();
        }

        if (unlockedSections >= 2) {
            ctx.fillStyle = COLORS.turquoiseLight;
            ctx.beginPath();
            ctx.ellipse(300, 245, 18 + unlockedSections * 2, 9, 0.2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Yellow spots (sections 3-4)
        if (unlockedSections >= 3) {
            ctx.fillStyle = COLORS.yellow;
            ctx.beginPath();
            ctx.ellipse(230, 255, 22, 11, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        if (unlockedSections >= 4) {
            ctx.fillStyle = COLORS.yellowLight;
            ctx.beginPath();
            ctx.ellipse(270, 260, 18, 9, 0.15, 0, Math.PI * 2);
            ctx.fill();
        }

        // Pink spots (sections 5-6)
        if (unlockedSections >= 5) {
            ctx.fillStyle = COLORS.pink;
            ctx.beginPath();
            ctx.ellipse(210, 265, 15, 8, -0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(290, 258, 14, 7, 0.2, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.globalAlpha = 1;
    }
}

// ============================================================================
// STAINED GLASS WINDOW - Progressive sections that unlock
// Each breath cycle unlocks a new section
// ============================================================================

function drawStainedGlassWindow(x, y, w, h, glow, sectionsLit) {
    ctx.save();

    // Create arch clipping path
    ctx.beginPath();
    ctx.moveTo(x, y + h);
    ctx.lineTo(x, y + h * 0.35);
    ctx.quadraticCurveTo(x, y, x + w/2, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + h * 0.35);
    ctx.lineTo(x + w, y + h);
    ctx.closePath();
    ctx.clip();

    // Base: dark/dim window (unlit)
    ctx.fillStyle = '#2a3a3a';
    ctx.fillRect(x, y, w, h);

    // Faint outline of the design when dark
    if (sectionsLit === 0 && glow < 0.1) {
        ctx.strokeStyle = '#3a4a4a';
        ctx.lineWidth = 2;
        // Hint of the wave pattern
        ctx.beginPath();
        ctx.moveTo(x + 30, y + h);
        ctx.quadraticCurveTo(x + 60, y + h/2, x + 40, y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x + w - 30, y + h);
        ctx.quadraticCurveTo(x + w - 60, y + h/2, x + w - 40, y);
        ctx.stroke();
    }

    const pixelSize = 6;

    // === SECTION 1: Left turquoise wave ===
    const sec1Alpha = sectionsLit >= 1 ? 1 : glow * 0.8;
    if (sec1Alpha > 0) {
        ctx.globalAlpha = sec1Alpha;
        ctx.fillStyle = sectionsLit >= 1 ? COLORS.turquoiseLight : COLORS.turquoise;

        for (let py = 0; py < h; py += pixelSize) {
            const waveX = Math.sin((py / h) * Math.PI * 1.5) * 35 + 25;
            for (let px = 0; px < waveX + 15; px += pixelSize) {
                ctx.fillRect(x + px, y + py, pixelSize - 1, pixelSize - 1);
            }
        }
        ctx.globalAlpha = 1;
    }

    // === SECTION 2: Right turquoise wave ===
    const sec2Alpha = sectionsLit >= 2 ? 1 : (sectionsLit >= 1 ? glow * 0.8 : 0);
    if (sec2Alpha > 0) {
        ctx.globalAlpha = sec2Alpha;
        ctx.fillStyle = sectionsLit >= 2 ? COLORS.turquoiseLight : COLORS.turquoise;

        for (let py = 0; py < h; py += pixelSize) {
            const waveX = Math.sin((py / h) * Math.PI * 1.5 + 0.8) * 35;
            for (let px = w - 40 + waveX; px < w; px += pixelSize) {
                ctx.fillRect(x + px, y + py, pixelSize - 1, pixelSize - 1);
            }
        }
        ctx.globalAlpha = 1;
    }

    // === SECTION 3: Left yellow flame ===
    const sec3Alpha = sectionsLit >= 3 ? 1 : (sectionsLit >= 2 ? glow * 0.9 : 0);
    if (sec3Alpha > 0) {
        ctx.globalAlpha = sec3Alpha;
        ctx.fillStyle = sectionsLit >= 3 ? COLORS.yellowLight : COLORS.yellow;

        // Flame shape
        const flame1 = [
            {x: 55, y: 25}, {x: 65, y: 15}, {x: 75, y: 25}, {x: 80, y: 40},
            {x: 75, y: 55}, {x: 65, y: 70}, {x: 55, y: 85}, {x: 50, y: 70},
            {x: 45, y: 55}, {x: 50, y: 40}, {x: 55, y: 30}
        ];
        flame1.forEach(p => {
            ctx.fillRect(x + p.x, y + p.y, pixelSize + 2, pixelSize + 2);
        });
        ctx.globalAlpha = 1;
    }

    // === SECTION 4: Right yellow flame ===
    const sec4Alpha = sectionsLit >= 4 ? 1 : (sectionsLit >= 3 ? glow * 0.9 : 0);
    if (sec4Alpha > 0) {
        ctx.globalAlpha = sec4Alpha;
        ctx.fillStyle = sectionsLit >= 4 ? COLORS.yellowLight : COLORS.yellow;

        const flame2 = [
            {x: w - 70, y: 25}, {x: w - 60, y: 15}, {x: w - 50, y: 25}, {x: w - 45, y: 40},
            {x: w - 50, y: 55}, {x: w - 60, y: 70}, {x: w - 70, y: 85}, {x: w - 75, y: 70},
            {x: w - 80, y: 55}, {x: w - 75, y: 40}
        ];
        flame2.forEach(p => {
            ctx.fillRect(x + p.x, y + p.y, pixelSize + 2, pixelSize + 2);
        });
        ctx.globalAlpha = 1;
    }

    // === SECTION 5: Center wave (darker turquoise) ===
    const sec5Alpha = sectionsLit >= 5 ? 1 : (sectionsLit >= 4 ? glow * 0.9 : 0);
    if (sec5Alpha > 0) {
        ctx.globalAlpha = sec5Alpha;
        ctx.fillStyle = sectionsLit >= 5 ? COLORS.turquoise : COLORS.turquoiseDark;

        for (let py = 0; py < h; py += pixelSize) {
            const wave = Math.sin((py / h) * Math.PI * 2) * 25;
            const waveStart = w/2 - 25 + wave;
            const waveEnd = w/2 + 5 + wave;
            for (let px = waveStart; px < waveEnd; px += pixelSize) {
                ctx.fillRect(x + px, y + py, pixelSize - 1, pixelSize - 1);
            }
        }
        ctx.globalAlpha = 1;
    }

    // === SECTION 6: Pink/red flowers in center ===
    const sec6Alpha = sectionsLit >= 6 ? 1 : (sectionsLit >= 5 ? glow : 0);
    if (sec6Alpha > 0) {
        ctx.globalAlpha = sec6Alpha;
        ctx.fillStyle = sectionsLit >= 6 ? COLORS.pinkLight : COLORS.pink;

        // Three flower clusters
        for (let i = 0; i < 3; i++) {
            const fx = w/2 - 25 + i * 25;
            const fy = h/2 - 15 + Math.sin(i * 1.5) * 20;

            // Flower center
            ctx.fillRect(x + fx, y + fy, pixelSize * 2, pixelSize * 2);

            // Petals
            ctx.fillRect(x + fx - pixelSize, y + fy + pixelSize/2, pixelSize, pixelSize);
            ctx.fillRect(x + fx + pixelSize * 2, y + fy + pixelSize/2, pixelSize, pixelSize);
            ctx.fillRect(x + fx + pixelSize/2, y + fy - pixelSize, pixelSize, pixelSize);
            ctx.fillRect(x + fx + pixelSize/2, y + fy + pixelSize * 2, pixelSize, pixelSize);
        }
        ctx.globalAlpha = 1;
    }

    // === Background glow when sections are lit ===
    if (sectionsLit > 0 || glow > 0) {
        const bgGlow = Math.min(1, (sectionsLit / 6) * 0.6 + glow * 0.4);
        ctx.globalAlpha = bgGlow * 0.5;
        const skyGrad = ctx.createRadialGradient(x + w/2, y + h/2, 0, x + w/2, y + h/2, w/2);
        skyGrad.addColorStop(0, '#ffffff');
        skyGrad.addColorStop(0.5, 'rgba(200, 240, 240, 0.8)');
        skyGrad.addColorStop(1, 'rgba(150, 200, 150, 0.3)');
        ctx.fillStyle = skyGrad;
        ctx.fillRect(x, y, w, h);
        ctx.globalAlpha = 1;
    }

    // Lead lines (black structural lines)
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 3;

    // Vertical supports
    ctx.beginPath();
    ctx.moveTo(x + w * 0.33, y + h);
    ctx.lineTo(x + w * 0.33, y + h * 0.25);
    ctx.moveTo(x + w * 0.67, y + h);
    ctx.lineTo(x + w * 0.67, y + h * 0.25);
    ctx.stroke();

    // Horizontal bar
    ctx.beginPath();
    ctx.moveTo(x + 10, y + h * 0.6);
    ctx.lineTo(x + w - 10, y + h * 0.6);
    ctx.stroke();

    ctx.restore();

    // Stone frame around window
    ctx.fillStyle = '#5a5a50';
    ctx.lineWidth = 8;

    // Arch frame
    ctx.strokeStyle = '#4a4a40';
    ctx.lineWidth = 12;
    ctx.beginPath();
    ctx.moveTo(x - 5, y + h + 5);
    ctx.lineTo(x - 5, y + h * 0.35);
    ctx.quadraticCurveTo(x - 5, y - 5, x + w/2, y - 5);
    ctx.quadraticCurveTo(x + w + 5, y - 5, x + w + 5, y + h * 0.35);
    ctx.lineTo(x + w + 5, y + h + 5);
    ctx.stroke();

    // Stone sill
    ctx.fillStyle = '#6a6a60';
    ctx.fillRect(x - 15, y + h, w + 30, 18);

    // === MAGNIFICENT GLOW for fully lit window ===
    if (sectionsLit >= 6) {
        // Outer radiant glow
        ctx.save();
        ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 500) * 0.1;

        const magnificentGrad = ctx.createRadialGradient(x + w/2, y + h/2, 20, x + w/2, y + h/2, w);
        magnificentGrad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
        magnificentGrad.addColorStop(0.3, 'rgba(64, 196, 196, 0.5)');
        magnificentGrad.addColorStop(0.5, 'rgba(232, 197, 71, 0.3)');
        magnificentGrad.addColorStop(0.7, 'rgba(232, 120, 140, 0.2)');
        magnificentGrad.addColorStop(1, 'transparent');

        ctx.fillStyle = magnificentGrad;
        ctx.beginPath();
        ctx.ellipse(x + w/2, y + h/2, w * 0.8, h * 0.9, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    // Temporary glow during inhale
    if (glow > 0.3 && sectionsLit < 6) {
        ctx.save();
        ctx.globalAlpha = (glow - 0.3) * 0.6;
        ctx.shadowColor = COLORS.turquoiseLight;
        ctx.shadowBlur = 20 + glow * 25;
        ctx.strokeStyle = COLORS.turquoise;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, y + h);
        ctx.lineTo(x, y + h * 0.35);
        ctx.quadraticCurveTo(x, y, x + w/2, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + h * 0.35);
        ctx.lineTo(x + w, y + h);
        ctx.stroke();
        ctx.restore();
    }
}

// ============================================================================
// BREATHING UI
// ============================================================================

function drawBreathingUI() {
    // Instructions at top
    if (breathPhase === 'waiting') {
        drawText('Hold A to breathe in', 240, 22, 11, 'rgba(255,255,255,0.8)', 'center', '400');
    } else if (breathPhase === 'inhale') {
        drawText('Breathing in...', 240, 22, 13, COLORS.turquoiseLight, 'center', '700');
    } else if (breathPhase === 'exhale') {
        drawText('Breathing out...', 240, 22, 13, COLORS.yellow, 'center', '700');
    }

    // Progress circle (bottom center)
    const centerX = 240;
    const centerY = 295;
    const radius = 18;

    // Background circle
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.stroke();

    // Progress arc
    if (breathPhase !== 'waiting') {
        ctx.strokeStyle = breathPhase === 'inhale' ? COLORS.turquoiseLight : COLORS.yellow;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, -Math.PI/2, -Math.PI/2 + breathProgress * Math.PI * 2);
        ctx.stroke();
    }

    // Breath count in center
    drawText(`${breathCycleCount}`, centerX, centerY + 5, 16, COLORS.white, 'center', '700');

    // Section indicators (6 small circles showing progress)
    for (let i = 0; i < 6; i++) {
        const angle = -Math.PI/2 + (i / 6) * Math.PI * 2;
        const dotX = centerX + Math.cos(angle) * (radius + 12);
        const dotY = centerY + Math.sin(angle) * (radius + 12);

        ctx.beginPath();
        ctx.arc(dotX, dotY, 4, 0, Math.PI * 2);

        if (i < unlockedSections) {
            // Lit - use color based on section
            if (i < 2) ctx.fillStyle = COLORS.turquoise;
            else if (i < 4) ctx.fillStyle = COLORS.yellow;
            else ctx.fillStyle = COLORS.pink;
        } else if (i === unlockedSections && breathPhase === 'inhale') {
            // Currently filling
            ctx.fillStyle = `rgba(255,255,255,${0.3 + currentGlow * 0.7})`;
        } else {
            // Not yet lit
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
        }
        ctx.fill();
    }

    // Key indicators (bottom corners)
    const aActive = aKeyHeld ? 1 : 0.3;
    const bActive = bKeyHeld ? 1 : 0.3;

    ctx.globalAlpha = aActive;
    ctx.fillStyle = COLORS.turquoise;
    ctx.fillRect(25, 295, 28, 18);
    drawText('A', 39, 308, 11, COLORS.white, 'center', '700');

    ctx.globalAlpha = bActive;
    ctx.fillStyle = COLORS.yellow;
    ctx.fillRect(60, 295, 28, 18);
    drawText('B', 74, 308, 11, COLORS.black, 'center', '700');

    ctx.globalAlpha = 1;

    // Hint for next action
    if (breathPhase === 'inhale' && breathProgress > 0.8) {
        drawText('Release A, then hold B', 240, 38, 10, 'rgba(255,255,255,0.6)', 'center', '400');
    } else if (breathPhase === 'waiting' && breathCycleCount > 0) {
        drawText('Hold A for next breath', 240, 38, 10, 'rgba(255,255,255,0.5)', 'center', '400');
    }
}

// ============================================================================
// LEVEL COMPLETE SCREEN - Magnificent finale
// ============================================================================

function drawLevelComplete() {
    // Dark background with radiant center
    const grad = ctx.createRadialGradient(240, 120, 0, 240, 160, 350);
    grad.addColorStop(0, '#4a6a7a');
    grad.addColorStop(0.5, '#2a3a40');
    grad.addColorStop(1, '#1a2025');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 480, 320);

    // Magnificent stained glass at full glory
    drawStainedGlassWindow(90, 10, 300, 150, 1, 6);

    // Radiant light beams
    ctx.globalAlpha = 0.4 + Math.sin(Date.now() / 800) * 0.1;
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2 + Date.now() / 5000;
        ctx.strokeStyle = i % 2 === 0 ? COLORS.turquoiseLight : COLORS.yellowLight;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(240, 90);
        ctx.lineTo(240 + Math.cos(angle) * 300, 90 + Math.sin(angle) * 200);
        ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Completion text
    drawText('Namaste', 240, 210, 32, COLORS.white, 'center', '700');
    drawText('Your meditation is complete', 240, 235, 13, COLORS.turquoiseLight, 'center', '400');

    // Stats
    drawText(`${breathCycleCount} breath cycles completed`, 240, 265, 11, 'rgba(255,255,255,0.7)', 'center', '400');

    // Final message
    drawText('Thank you for visiting Sea Ranch', 240, 290, 10, COLORS.sand, 'center', '400');

    drawText('PRESS A TO RETURN', 240, 310, 9, 'rgba(255,255,255,0.4)', 'center', '400');
}

// ============================================================================
// UPDATE
// ============================================================================

function update() {
    stateTimer++;

    switch (state) {
        case GameState.TITLE:
            // HTML overlay handles the title card
            break;

        case GameState.WALKING_TO_CHAPEL:
            // Walk character UP the path (decreasing Y, decreasing scale)
            playerY -= 0.8;
            playerScale = Math.max(0.6, playerScale - 0.003);

            // Slight wobble left-right as walking
            playerX = 280 + Math.sin(stateTimer * 0.1) * 3;

            if (stateTimer % 8 === 0) {
                playerWalkFrame++;
            }

            // Reached the chapel entrance
            if (playerY < 200) {
                state = GameState.ENTERING_CHAPEL;
                stateTimer = 0;
                SeaRanchStyle.flash(SeaRanchStyle.colors.cream, 0.15);
            }
            break;

        case GameState.ENTERING_CHAPEL:
            // Brief transition - fade to interior
            if (stateTimer > 90) {
                state = GameState.SITTING_DOWN;
                stateTimer = 0;
                SeaRanchStyle.flash(SeaRanchStyle.colors.cream, 0.15);
            }
            break;

        case GameState.SITTING_DOWN:
            // Animate sitting down
            if (stateTimer > 150) {
                state = GameState.MEDITATION;
                stateTimer = 0;
                meditationStartTime = Date.now();
                SeaRanchStyle.flash(SeaRanchStyle.colors.cream, 0.15);
            }
            break;

        case GameState.MEDITATION:
            // Handle breathing mechanics
            updateBreathing();

            // Check if all sections unlocked
            if (unlockedSections >= 6) {
                // Brief pause to admire the full window
                if (stateTimer > 180) {
                    state = GameState.LEVEL_COMPLETE;
                    stateTimer = 0;
                    // Save completion (Level 12 in narrative order)
                    SeaRanchStyle.saveCompletion(12);
                    // Juice effects for meditation complete
                    SeaRanchStyle.spawnSparkles(240, 120, SeaRanchStyle.colors.cream);
                    SeaRanchStyle.shake(4, 0.85);
                    SeaRanchStyle.flash(SeaRanchStyle.colors.cream, 0.15);
                }
            }
            break;

        case GameState.LEVEL_COMPLETE:
            break;
    }
}

function updateBreathing() {
    if (aKeyHeld && breathPhase !== 'exhale') {
        // Inhaling
        if (breathPhase !== 'inhale') {
            breathPhase = 'inhale';
            breathProgress = 0;
        }

        inhaleHoldTime++;
        if (inhaleHoldTime > HOLD_THRESHOLD) {
            breathProgress = Math.min(1, breathProgress + 1/INHALE_DURATION);
            // Glow builds up during inhale
            currentGlow = Math.min(1, breathProgress * 1.2);
        }
    } else if (!aKeyHeld && breathPhase === 'inhale' && breathProgress > 0.7) {
        // Released A after good inhale - transition to exhale phase
        breathPhase = 'exhale';
        breathProgress = 0;
        inhaleHoldTime = 0;
        // Lock in the section when we start exhale!
        if (unlockedSections < 6) {
            unlockedSections++;
            // Juice effect for unlocking a stained glass section
            SeaRanchStyle.spawnSparkles(240, 90, SeaRanchStyle.colors.cream);
            SeaRanchStyle.shake(4, 0.85);
        }
        breathCycleCount++;
    } else if (bKeyHeld && breathPhase === 'exhale') {
        // Exhaling
        exhaleHoldTime++;
        if (exhaleHoldTime > HOLD_THRESHOLD) {
            breathProgress = Math.min(1, breathProgress + 1/EXHALE_DURATION);
            // Glow fades during exhale (but section stays lit)
            currentGlow = Math.max(0, currentGlow - 0.015);
        }

        // Complete exhale
        if (breathProgress >= 1) {
            breathPhase = 'waiting';
            breathProgress = 0;
            exhaleHoldTime = 0;
            currentGlow = 0;
        }
    } else if (!aKeyHeld && !bKeyHeld) {
        // No keys held
        if (breathPhase === 'inhale' && breathProgress < 0.7) {
            // Incomplete inhale - reset
            breathPhase = 'waiting';
            breathProgress = 0;
            currentGlow = 0;
        }
        inhaleHoldTime = 0;
        exhaleHoldTime = 0;
    }
}

// ============================================================================
// RENDER
// ============================================================================

function render() {
    ctx.clearRect(0, 0, 480, 320);
    ctx.save();
    SeaRanchStyle.applyShake(ctx);

    switch (state) {
        case GameState.TITLE:
            // HTML overlay handles the title card
            break;

        case GameState.WALKING_TO_CHAPEL:
            drawChapelExterior();
            drawText('Sea Ranch Chapel', 240, 25, 18, COLORS.white, 'center', '700');
            drawText('Level 12: Meditation', 240, 45, 11, 'rgba(255,255,255,0.7)', 'center', '400');
            break;

        case GameState.ENTERING_CHAPEL:
            const fadeIn = Math.min(1, stateTimer / 90);
            drawChapelExterior();
            ctx.fillStyle = `rgba(0,0,0,${fadeIn})`;
            ctx.fillRect(0, 0, 480, 320);
            drawText('Entering the chapel...', 240, 160, 14, `rgba(255,255,255,${fadeIn})`, 'center', '400');
            break;

        case GameState.SITTING_DOWN:
            const sitProgress = Math.min(1, stateTimer / 120);
            drawChapelInteriorSitting(sitProgress);
            break;

        case GameState.MEDITATION:
            drawMeditationView();
            drawBreathingUI();
            break;

        case GameState.LEVEL_COMPLETE:
            drawLevelComplete();
            break;
    }

    SeaRanchStyle.updateJuice(ctx);
    ctx.restore();
}

// ============================================================================
// INPUT
// ============================================================================

document.addEventListener('keydown', (e) => {
    const isActionKey = e.code === 'Space' || e.code === 'Enter' || e.code === 'KeyA';

    // ESC returns to menu (B is used for breathing in this level)
    if (e.code === 'Escape') {
        window.location.href = 'level0-menu.html';
        return;
    }

    // Title screen - start game
    if (state === GameState.TITLE && isActionKey) {
        document.getElementById('title-card').style.display = 'none';
        state = GameState.WALKING_TO_CHAPEL;
        stateTimer = 0;
        e.preventDefault();
    }

    // A/Z for inhale, B/X for exhale (breathing mechanic)
    if (e.code === 'KeyA' || e.code === 'KeyZ') {
        aKeyHeld = true;
        e.preventDefault();
    }
    if (e.code === 'KeyB' || e.code === 'KeyX') {
        bKeyHeld = true;
        e.preventDefault();
    }

    if (state === GameState.LEVEL_COMPLETE && isActionKey) {
        window.location.href = 'level0-menu.html';
    }
});

document.addEventListener('keyup', (e) => {
    if (e.code === 'KeyA' || e.code === 'KeyZ') {
        aKeyHeld = false;
    }
    if (e.code === 'KeyB' || e.code === 'KeyX') {
        bKeyHeld = false;
    }
});

// ============================================================================
// GAME LOOP
// ============================================================================

function gameLoop() {
    update();
    render();

    // Apply weathered film grain effect for consistent Sea Ranch aesthetic
    if (state !== GameState.TITLE) {
        SeaRanchStyle.applyWeatheredEffect(ctx, { grainOpacity: 0.06, vignetteIntensity: 0.15 });
    }

    requestAnimationFrame(gameLoop);
}

// Start when image is loaded
chapelBg.onload = gameLoop;
chapelBg.onerror = gameLoop;

SeaRanchStyle.setupTouchControls();
setTimeout(() => {
    if (state === GameState.TITLE && stateTimer === 0) {
        gameLoop();
    }
}, 500);
</script>
</body>
</html>
