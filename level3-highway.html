<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sea Ranch Quest - Highway 1</title>
    <script src="sea-ranch-style.js?v=4"></script>
    <style>
        :root {
            --black: #1a1a1a;
            --white: #f5f5f0;
            --red: #C41E3A;
            --blue: #2E5DA8;
            --wood: #8b7355;
            --sand: #d4c4a8;
            --fog: #e8e4dc;
        }

        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            position: fixed;
            inset: 0;
        }
        #game-container {
            width: 640px;
            height: 480px;
            position: relative;
            overflow: hidden;
            background: #1a1a1a;
        }
        canvas {
            display: block;
            image-rendering: pixelated;
        }

        /* HTML/CSS Title Card */
        .title-card {
            position: absolute;
            inset: 0;
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .title-card .wood-bg {
            position: absolute;
            inset: 0;
            background:
                repeating-linear-gradient(
                    90deg,
                    transparent 0px,
                    transparent 3px,
                    rgba(139, 115, 85, 0.08) 3px,
                    rgba(139, 115, 85, 0.08) 4px
                ),
                radial-gradient(ellipse at 20% 30%, rgba(139, 115, 85, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 70% 60%, rgba(139, 115, 85, 0.1) 0%, transparent 40%),
                radial-gradient(ellipse at 40% 80%, rgba(139, 115, 85, 0.12) 0%, transparent 45%),
                linear-gradient(180deg, var(--fog) 0%, var(--sand) 100%);
        }

        .title-card .supergraphic {
            position: absolute;
            top: -80px;
            right: -120px;
            width: 550px;
            height: 550px;
            pointer-events: none;
        }

        .title-card .supergraphic::before,
        .title-card .supergraphic::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            border: 36px solid var(--blue);
        }

        .title-card .supergraphic::before {
            width: 420px;
            height: 420px;
            top: 0;
            right: 0;
            border-color: transparent transparent var(--blue) var(--blue);
            transform: rotate(-45deg);
        }

        .title-card .supergraphic::after {
            width: 320px;
            height: 320px;
            top: 50px;
            right: 50px;
            border-color: transparent transparent var(--blue) var(--blue);
            transform: rotate(-45deg);
            opacity: 0.7;
        }

        .title-card .arrow-accent {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 80px;
            height: 100px;
            pointer-events: none;
        }

        .title-card .arrow-accent::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 40px solid transparent;
            border-right: 40px solid transparent;
            border-bottom: 50px solid var(--red);
            top: 0;
        }

        .title-card .arrow-accent::after {
            content: '';
            position: absolute;
            width: 26px;
            height: 50px;
            background: var(--red);
            top: 45px;
            left: 27px;
        }

        .title-card .title-content {
            position: relative;
            z-index: 10;
            text-align: center;
        }

        .title-card .level-title {
            font-size: 56px;
            font-weight: 700;
            color: var(--black);
            letter-spacing: -2px;
            line-height: 1;
            margin-bottom: 12px;
        }

        .title-card .level-subtitle {
            font-size: 18px;
            font-weight: 400;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: var(--wood);
        }

        .title-card .continue-hint {
            position: absolute;
            bottom: 36px;
            right: 36px;
            font-size: 12px;
            color: var(--wood);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .title-card .title-grain {
            position: absolute;
            inset: 0;
            opacity: 0.4;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%' height='100%' filter='url(%23noise)'/%3E%3C/svg%3E");
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- HTML/CSS Title Card -->
        <div class="title-card" id="title-card">
            <div class="wood-bg"></div>
            <div class="supergraphic"></div>
            <div class="arrow-accent"></div>
            <div class="title-content">
                <div class="level-title">Highway 1</div>
                <div class="level-subtitle">Jenner to Sea Ranch</div>
            </div>
            <div class="continue-hint">A to start · B to menu</div>
            <div class="title-grain"></div>
        </div>

        <canvas id="game" width="640" height="480"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const W = 640;
        const H = 480;

        // ═══════════════════════════════════════════════════════════
        // PALETTE - Golden hour on the Sonoma Coast
        // ═══════════════════════════════════════════════════════════
        const COLORS = {
            // Sky - transitions through golden hour
            skyTop: '#4a7090',
            skyMid: '#7090a0',
            skyBottom: '#c0a080',

            // Ocean - Pacific at sunset, deep and golden-touched
            oceanDeep: '#2a4a5a',
            oceanMid: '#3a6070',
            oceanShimmer: '#c09060',
            foam: 'rgba(255, 245, 230, 0.4)',

            // Cliffs - dark dramatic cliffs on RIGHT side
            cliff: '#5a4a40',
            cliffLight: '#7a6a58',
            cliffDark: '#3a3028',
            cliffFace: '#6a5a48',

            // Grass - coastal meadow
            grass: '#5a7050',
            grassLight: '#7a9065',
            grassDark: '#4a5a40',

            // Wildflowers
            lupine: '#6070a0',
            poppy: '#d07030',

            // Road
            asphalt: '#3a3a38',
            asphaltLight: '#4a4a48',
            lineYellow: '#c0a050',
            lineWhite: '#d0ccc0',

            // Car - burgundy Volvo 240
            carBody: '#722F37',
            carLight: '#8a4048',
            carDark: '#5a2028',
            carChrome: '#c0b8a8',
            carWindow: '#405060',
            carTaillight: '#ff3030',

            // Hazards
            rock: '#6a6058',
            rockLight: '#8a7a68',
            rockDark: '#4a4038',
            deer: '#8a7060',
            deerLight: '#a08878',
            debris: '#5a4a3a',

            // Atmosphere
            haze: 'rgba(200, 180, 150, 0.15)',
            sunGlow: '#ffe0a0'
        };

        // ═══════════════════════════════════════════════════════════
        // GAME STATE
        // ═══════════════════════════════════════════════════════════
        let gameState = 'title';
        let time = 0;
        let distance = 0;
        const goalDistance = 9600;  // 60 seconds at cruise speed (160 * 60)
        let gameTime = 0;
        const maxTime = 90 * 60; // 90 seconds at 60fps

        // Player
        let playerX = 0;          // -1 to 1
        let playerVelX = 0;
        let playerSpeed = 0;
        const maxSpeed = 280;
        const cruiseSpeed = 160;  // Normal driving speed

        // Car physics for feel
        let carBounce = 0;
        let carTilt = 0;
        let wheelSpin = 0;
        let enginePulse = 0;

        // Road
        let roadCurve = 0;
        let targetCurve = 0;
        let curveTimer = 0;

        // World objects
        let seaStacks = [];      // Rocks in ocean
        let cypressTrees = [];   // Windswept trees
        let grasses = [];        // Coastal grass tufts
        let wildflowers = [];    // Lupine and poppies
        let fencePosts = [];     // Old fence line

        // HAZARDS - the core gameplay
        let hazards = [];         // Rocks, deer, debris on road
        let hazardsDodged = 0;
        let damage = 0;           // Car damage 0-3, at 3 you have to turn back
        const maxDamage = 3;

        // Crash
        let crashed = false;
        let crashTimer = 0;
        let invincibleTimer = 0;
        let guardrailCooldown = 0;  // Prevent guardrail spazzing

        // Ocean waves (persistent)
        let waves = [];
        for (let i = 0; i < 8; i++) {
            waves.push({
                phase: Math.random() * Math.PI * 2,
                speed: 0.02 + Math.random() * 0.01,
                amplitude: 2 + Math.random() * 2,
                y: 0.1 + i * 0.1
            });
        }

        // ═══════════════════════════════════════════════════════════
        // INPUT
        // ═══════════════════════════════════════════════════════════
        const keys = { left: false, right: false, up: false, down: false };

        document.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft') keys.left = true;
            if (e.key === 'ArrowRight') keys.right = true;
            if (e.key === 'ArrowUp') keys.up = true;
            if (e.key === 'ArrowDown') keys.down = true;

            const isActionKey = e.key === ' ' || e.key === 'Enter' || e.key === 'a' || e.key === 'A';
            const isBackKey = e.key === 'Escape' || e.key === 'b' || e.key === 'B';

            if (isBackKey) {
                window.location.href = 'level0-menu.html';
                return;
            }

            if (gameState === 'title' && isActionKey) {
                document.getElementById('title-card').style.display = 'none';
                startGame();
            }
            if ((gameState === 'win' || gameState === 'lose') && isActionKey) {
                document.getElementById('title-card').style.display = 'none';
                startGame();
            }
            e.preventDefault();
        });

        document.addEventListener('keyup', e => {
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
            if (e.key === 'ArrowUp') keys.up = false;
            if (e.key === 'ArrowDown') keys.down = false;
        });

        // ═══════════════════════════════════════════════════════════
        // SPAWNING
        // ═══════════════════════════════════════════════════════════

        function spawnSeaStack(depth) {
            seaStacks.push({
                depth: depth,
                x: 0.1 + Math.random() * 0.3,
                height: 30 + Math.random() * 50,
                width: 15 + Math.random() * 25,
                jagged: Math.random(),
                hasTop: Math.random() > 0.4
            });
        }

        function spawnCypress(depth) {
            cypressTrees.push({
                depth: depth,
                side: 'right',
                offset: 50 + Math.random() * 60,  // Well back from road
                height: 35 + Math.random() * 25,
                lean: -0.2 + Math.random() * 0.15,
                branches: 3 + Math.floor(Math.random() * 3)
            });
        }

        function spawnGrass(depth) {
            grasses.push({
                depth: depth,
                side: Math.random() > 0.4 ? 'right' : 'left',
                offset: 3 + Math.random() * 12,  // Close to road shoulder
                blades: 4 + Math.floor(Math.random() * 4),
                height: 6 + Math.random() * 6,
                sway: Math.random() * Math.PI * 2
            });
        }

        function spawnWildflowers(depth) {
            wildflowers.push({
                depth: depth,
                side: 'right',
                offset: 25 + Math.random() * 35,  // In the meadow
                type: Math.random() > 0.6 ? 'poppy' : 'lupine',
                count: 2 + Math.floor(Math.random() * 3),
                spread: 8 + Math.random() * 10
            });
        }

        function spawnFencePost(depth) {
            fencePosts.push({
                depth: depth,
                offset: 8 + Math.random() * 10,  // Close to road shoulder
                height: 18 + Math.random() * 6,
                lean: (Math.random() - 0.5) * 0.15
            });
        }

        // ═══════════════════════════════════════════════════════════
        // HAZARD SPAWNING
        // ═══════════════════════════════════════════════════════════

        function spawnHazard(type, laneX) {
            const hazard = {
                depth: 0.0,  // Start at horizon for more reaction time
                type: type,
                laneX: laneX !== undefined ? laneX : (Math.random() - 0.5) * 0.8,  // Random lane position
                active: true,
                animPhase: Math.random() * Math.PI * 2
            };

            if (type === 'rock') {
                hazard.size = 0.8 + Math.random() * 0.4;
                hazard.rotation = Math.random() * 0.3 - 0.15;
                // Rock variety - different shapes
                hazard.rockType = Math.floor(Math.random() * 3);  // 0=boulder, 1=angular, 2=flat
                hazard.mossy = Math.random() > 0.6;
            } else if (type === 'deer') {
                hazard.runDirection = Math.random() > 0.5 ? 1 : -1;
                hazard.runSpeed = 0.3 + Math.random() * 0.2;
                hazard.startX = hazard.runDirection > 0 ? -0.8 : 0.8;
                hazard.laneX = hazard.startX;
                // Deer variety - bucks have antlers
                hazard.isBuck = Math.random() > 0.5;
                hazard.antlerSize = hazard.isBuck ? (0.7 + Math.random() * 0.5) : 0;
            } else if (type === 'debris') {
                hazard.pieces = 2 + Math.floor(Math.random() * 3);
                hazard.spread = 0.15 + Math.random() * 0.1;
            } else if (type === 'log') {
                hazard.length = 0.8 + Math.random() * 0.4;
                hazard.rotation = (Math.random() - 0.5) * 0.6;  // Angled across road
                hazard.hasBark = Math.random() > 0.3;
                hazard.hasBranches = Math.random() > 0.5;
            }

            hazards.push(hazard);
        }

        function spawnHazardNow(type) {
            // Spawn hazard immediately - no warning
            if (type === 'rock') {
                spawnHazard('rock', (Math.random() - 0.5) * 0.6);
            } else if (type === 'deer') {
                spawnHazard('deer');
            } else if (type === 'debris') {
                spawnHazard('debris', (Math.random() - 0.5) * 0.5);
            } else if (type === 'log') {
                spawnHazard('log', (Math.random() - 0.5) * 0.5);
            }
        }

        // ═══════════════════════════════════════════════════════════
        // START GAME
        // ═══════════════════════════════════════════════════════════
        function startGame() {
            gameState = 'playing';
            time = 0;
            distance = 0;
            gameTime = 0;
            playerX = 0;
            playerVelX = 0;
            playerSpeed = cruiseSpeed;
            carBounce = 0;
            carTilt = 0;
            crashed = false;
            crashTimer = 0;
            invincibleTimer = 0;
            roadCurve = 0;
            targetCurve = 0;
            curveTimer = 0;

            // Reset gameplay
            hazards = [];
            hazardsDodged = 0;
            damage = 0;

            // Reset juice effects
            SeaRanchStyle.resetJuice();

            // Clear and spawn initial scenery
            seaStacks = [];
            cypressTrees = [];
            grasses = [];
            wildflowers = [];
            fencePosts = [];

            for (let i = 0; i < 4; i++) spawnSeaStack(i * 0.25);
            for (let i = 0; i < 4; i++) spawnCypress(i * 0.25);
            for (let i = 0; i < 12; i++) spawnGrass(i * 0.08);
            for (let i = 0; i < 4; i++) spawnWildflowers(i * 0.25);
            for (let i = 0; i < 5; i++) spawnFencePost(i * 0.2);

            // Spawn first hazard after a moment
            setTimeout(() => {
                if (gameState === 'playing') {
                    spawnHazardNow(['rock', 'debris', 'deer'][Math.floor(Math.random() * 3)]);
                }
            }, 2500);
        }

        // ═══════════════════════════════════════════════════════════
        // UPDATE - Hazard dodging mechanics
        // ═══════════════════════════════════════════════════════════
        function update(dt) {
            if (gameState !== 'playing') return;

            time++;
            gameTime++;

            // Win condition - reached destination
            if (distance >= goalDistance) {
                gameState = 'win';
                SeaRanchStyle.saveCompletion(3);
                SeaRanchStyle.spawnCelebration(W/2, H/2);
                SeaRanchStyle.triggerLevelComplete();
                return;
            }

            // Apply time scale for slow-mo effects
            dt *= SeaRanchStyle.getTimeScale();

            // Lose condition - too much damage
            if (damage >= maxDamage) {
                gameState = 'lose';
                return;
            }

            // Invincibility frames after hit
            if (invincibleTimer > 0) {
                invincibleTimer -= dt;
            }

            // Crash recovery
            if (crashed) {
                crashTimer -= dt;
                playerSpeed *= 0.96;
                if (crashTimer <= 0) {
                    crashed = false;
                    playerSpeed = cruiseSpeed;
                }
            }

            // Road curves - gentle, scenic
            curveTimer -= dt;
            if (curveTimer <= 0) {
                targetCurve = (Math.random() - 0.5) * 1.2;
                curveTimer = 2 + Math.random() * 2;
            }
            roadCurve += (targetCurve - roadCurve) * dt * 1.5;

            // Speed control
            if (!crashed) {
                if (keys.up) {
                    playerSpeed += 200 * dt;
                } else if (keys.down) {
                    playerSpeed -= 300 * dt;
                } else {
                    // Gradually return to cruise speed
                    playerSpeed += (cruiseSpeed - playerSpeed) * dt * 2;
                }
                playerSpeed = Math.max(40, Math.min(maxSpeed, playerSpeed));
            }

            // Steering - very responsive for dodging hazards
            const steerPower = 8.0;  // High acceleration
            if (keys.left) playerVelX -= steerPower * dt;
            if (keys.right) playerVelX += steerPower * dt;

            // Curve pulls you (reduced so it doesn't fight steering)
            const curveForce = roadCurve * 0.3;
            playerVelX += curveForce * dt;

            // Friction - low when steering, high when not (snappy response)
            const steering = keys.left || keys.right;
            const friction = steering ? 1.5 : 4.0;
            playerVelX *= (1 - friction * dt);
            playerVelX = Math.max(-1.8, Math.min(1.8, playerVelX));  // Higher max velocity
            playerX += playerVelX * dt;

            // Car tilt from steering
            carTilt += (playerVelX * 0.1 - carTilt) * dt * 10;

            // Car bounce
            carBounce = Math.sin(time * 0.25) * 1.5;

            // Wheel spin
            wheelSpin += playerSpeed * dt * 0.08;

            // Guardrail cooldown
            if (guardrailCooldown > 0) {
                guardrailCooldown -= dt;
            }

            // Lane boundaries - stay on the road!
            if (playerX < -0.65) {
                playerX = -0.65;
                // Gentle resistance instead of hard bounce
                if (keys.left) {
                    playerVelX = 0; // Just stop, don't bounce
                } else {
                    playerVelX = Math.max(0, playerVelX * -0.3);
                }
                // Only shake/sound on initial impact
                if (guardrailCooldown <= 0) {
                    SeaRanchStyle.shake(4, 0.9);
                    SeaRanchStyle.playSound('soft');
                    guardrailCooldown = 0.3; // 300ms cooldown
                }
            }
            if (playerX > 0.65) {
                playerX = 0.65;
                // Gentle resistance instead of hard bounce
                if (keys.right) {
                    playerVelX = 0; // Just stop, don't bounce
                } else {
                    playerVelX = Math.min(0, playerVelX * -0.3);
                }
                // Only shake/sound on initial impact
                if (guardrailCooldown <= 0) {
                    SeaRanchStyle.shake(4, 0.9);
                    SeaRanchStyle.playSound('soft');
                    guardrailCooldown = 0.3; // 300ms cooldown
                }
            }

            // Trail effect when swerving hard
            if (Math.abs(playerVelX) > 0.5) {
                const trailX = W/2 + playerX * 160;
                SeaRanchStyle.addTrailPoint(trailX, H - 50, 'rgba(60, 60, 60, 0.3)', 6);
            }

            // Distance tracking
            distance += playerSpeed * dt;
            const scrollSpeed = playerSpeed / maxSpeed * dt;

            // ─────────────────────────────────────────────────────────
            // HAZARD SPAWNING - steady stream of obstacles to dodge
            // Game is ~50 seconds, want ~12-15 hazards for good pacing
            // ─────────────────────────────────────────────────────────
            // Spawn when no hazards OR when existing hazards are far enough away
            const nearestHazard = hazards.reduce((min, h) => Math.min(min, h.depth), 1);
            if (hazards.length === 0 || (hazards.length < 2 && nearestHazard > 0.4)) {
                // Base spawn rate + time-based increase for pacing
                const spawnChance = 0.012 + (distance / goalDistance) * 0.008;
                if (Math.random() < spawnChance) {
                    const types = ['rock', 'rock', 'debris', 'deer', 'log', 'log'];
                    spawnHazardNow(types[Math.floor(Math.random() * types.length)]);
                }
            }

            // ─────────────────────────────────────────────────────────
            // HAZARD UPDATES
            // ─────────────────────────────────────────────────────────
            for (let i = hazards.length - 1; i >= 0; i--) {
                const h = hazards[i];

                // Move hazard toward player - slower approach for better visibility
                h.depth += scrollSpeed * 0.9;

                // Deer runs across road
                if (h.type === 'deer' && h.depth > 0.3) {
                    h.laneX += h.runDirection * h.runSpeed * dt;
                }

                // Collision detection
                if (h.active && invincibleTimer <= 0 && h.depth > 0.82 && h.depth < 0.98) {
                    let hitWidth = 0.25;
                    if (h.type === 'debris') hitWidth = h.spread;
                    if (h.type === 'deer') hitWidth = 0.2;

                    if (Math.abs(playerX - h.laneX) < hitWidth) {
                        triggerHit();
                        h.active = false;
                    }
                }

                // Successfully dodged
                if (h.active && h.depth > 1.0) {
                    hazardsDodged++;
                    h.active = false;
                    // Quick whoosh on successful dodge
                    SeaRanchStyle.playSound('dodge');
                }

                // Remove if off screen
                if (h.depth > 1.2) hazards.splice(i, 1);
            }

            // ─────────────────────────────────────────────────────────
            // SCENERY UPDATES
            // ─────────────────────────────────────────────────────────
            for (let i = seaStacks.length - 1; i >= 0; i--) {
                seaStacks[i].depth += scrollSpeed * 0.7;
                if (seaStacks[i].depth > 1.1) seaStacks.splice(i, 1);
            }
            while (seaStacks.length < 6) spawnSeaStack(Math.random() * 0.1);

            for (let i = cypressTrees.length - 1; i >= 0; i--) {
                cypressTrees[i].depth += scrollSpeed * 0.8;
                if (cypressTrees[i].depth > 1.1) cypressTrees.splice(i, 1);
            }
            while (cypressTrees.length < 4) spawnCypress(Math.random() * 0.1);

            for (let i = grasses.length - 1; i >= 0; i--) {
                grasses[i].depth += scrollSpeed * 0.8;
                if (grasses[i].depth > 1.1) grasses.splice(i, 1);
            }
            while (grasses.length < 25) spawnGrass(Math.random() * 0.05);

            for (let i = wildflowers.length - 1; i >= 0; i--) {
                wildflowers[i].depth += scrollSpeed * 0.8;
                if (wildflowers[i].depth > 1.1) wildflowers.splice(i, 1);
            }
            while (wildflowers.length < 4) spawnWildflowers(Math.random() * 0.1);

            for (let i = fencePosts.length - 1; i >= 0; i--) {
                fencePosts[i].depth += scrollSpeed * 0.8;
                if (fencePosts[i].depth > 1.1) fencePosts.splice(i, 1);
            }
            while (fencePosts.length < 5) spawnFencePost(Math.random() * 0.1);
        }

        function triggerHit() {
            crashed = true;
            crashTimer = 0.8;
            invincibleTimer = 2.0;  // 2 seconds of invincibility
            damage++;
            playerSpeed *= 0.3;

            // BIG juice on crash!
            SeaRanchStyle.shake(20, 0.88);
            SeaRanchStyle.flash('#ff4040', 0.5);
            SeaRanchStyle.setTimeScale(0.3, 15);  // Brief slow-mo
            SeaRanchStyle.spawnParticles(W/2, H - 80, {
                count: 15,
                color: '#ff6040',
                speed: 5,
                size: 4,
                life: 25,
                spread: Math.PI,
                angle: -Math.PI/2,
                gravity: 0.2
            });
            SeaRanchStyle.playSound('hit');  // Unpleasant thud
        }

        // ═══════════════════════════════════════════════════════════
        // PERSPECTIVE HELPERS
        // ═══════════════════════════════════════════════════════════
        const horizonY = 165;

        function depthToY(d) {
            return horizonY + d * (H - horizonY);
        }

        function depthToScale(d) {
            return 0.1 + d * 0.9;
        }

        function getRoadX(d) {
            const curveOffset = roadCurve * (1 - d) * (1 - d) * 120;
            return W * 0.5 + curveOffset;  // Road is centered
        }

        function getRoadWidth(d) {
            return 20 + d * 180;
        }

        // ═══════════════════════════════════════════════════════════
        // RENDER - THE GOOD STUFF
        // ═══════════════════════════════════════════════════════════

        function drawSky() {
            const sunsetProgress = gameTime / maxTime;

            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, horizonY);
            const t = Math.min(1, sunsetProgress * 1.5);
            gradient.addColorStop(0, lerpColor('#5080a0', '#3a5070', t));
            gradient.addColorStop(0.5, lerpColor('#80a0b0', '#7080a0', t));
            gradient.addColorStop(1, lerpColor('#d0a070', '#e08040', t));

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, W, horizonY + 20);

            // Sun - low on horizon, LEFT side (over ocean)
            const sunX = 100 - sunsetProgress * 30;
            const sunY = horizonY - 45 + sunsetProgress * 25;
            const sunRadius = 32;

            // Sun glow layers
            for (let i = 4; i >= 0; i--) {
                const glowR = sunRadius + i * 25;
                const alpha = 0.15 - i * 0.025;
                ctx.fillStyle = `rgba(255, ${200 - i * 20}, ${100 - i * 20}, ${alpha})`;
                ctx.beginPath();
                ctx.arc(sunX, sunY, glowR, 0, Math.PI * 2);
                ctx.fill();
            }

            // Sun body
            const sunGrad = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunRadius);
            sunGrad.addColorStop(0, '#fffae0');
            sunGrad.addColorStop(0.7, '#ffd080');
            sunGrad.addColorStop(1, '#ff9040');
            ctx.fillStyle = sunGrad;
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
            ctx.fill();

            // Light rays
            ctx.save();
            ctx.globalAlpha = 0.08;
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 + time * 0.001;
                const rayLen = 70 + Math.sin(time * 0.02 + i) * 20;
                ctx.strokeStyle = '#ffe0a0';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(sunX + Math.cos(angle) * sunRadius, sunY + Math.sin(angle) * sunRadius);
                ctx.lineTo(sunX + Math.cos(angle) * rayLen, sunY + Math.sin(angle) * rayLen);
                ctx.stroke();
            }
            ctx.restore();

            // Wispy clouds
            ctx.save();
            ctx.globalAlpha = 0.3;
            for (let i = 0; i < 5; i++) {
                const cx = (i * 180 + time * 0.05) % (W + 100) - 50;
                const cy = 40 + i * 20;
                const sunTint = Math.max(0, 1 - Math.abs(cx - sunX) / 200);

                ctx.fillStyle = lerpColor('#c0c0c0', '#ffd090', sunTint);
                ctx.beginPath();
                ctx.ellipse(cx, cy, 60 + i * 10, 8 + i * 2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cx + 40, cy + 5, 40, 6, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawOcean() {
            // Ocean on LEFT side of road
            const oceanGrad = ctx.createLinearGradient(0, horizonY, 0, H);
            oceanGrad.addColorStop(0, '#3a6878');
            oceanGrad.addColorStop(0.3, '#2a5868');
            oceanGrad.addColorStop(1, '#1a4050');

            ctx.fillStyle = oceanGrad;
            ctx.beginPath();
            ctx.moveTo(0, horizonY);

            // Follow road left edge
            for (let d = 0; d <= 1.05; d += 0.05) {
                const y = depthToY(d);
                const roadLeftEdge = getRoadX(Math.min(d, 1)) - getRoadWidth(Math.min(d, 1)) - 5;
                ctx.lineTo(Math.max(0, roadLeftEdge), y);
            }
            ctx.lineTo(0, H);
            ctx.closePath();
            ctx.fill();

            // Sunset reflection on ocean
            const sunX = 100;
            const reflectionGrad = ctx.createLinearGradient(sunX - 50, horizonY, sunX + 50, H);
            reflectionGrad.addColorStop(0, 'rgba(255, 200, 100, 0.3)');
            reflectionGrad.addColorStop(0.3, 'rgba(255, 180, 80, 0.15)');
            reflectionGrad.addColorStop(1, 'rgba(255, 160, 60, 0.05)');

            ctx.fillStyle = reflectionGrad;
            ctx.beginPath();
            ctx.moveTo(sunX - 70, horizonY);
            ctx.lineTo(sunX + 70, horizonY);
            ctx.lineTo(sunX + 25, H);
            ctx.lineTo(sunX - 25, H);
            ctx.closePath();
            ctx.fill();

            // Animated waves
            ctx.save();
            for (const wave of waves) {
                const waveY = horizonY + wave.y * (H - horizonY);
                const wavePhase = time * wave.speed + wave.phase;
                const d = wave.y;
                const waveMaxX = Math.max(0, getRoadX(Math.min(d, 1)) - getRoadWidth(Math.min(d, 1)) - 10);

                if (waveMaxX <= 0) continue;

                ctx.strokeStyle = `rgba(255, 255, 255, ${0.15 - wave.y * 0.1})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(0, waveY);

                for (let x = 0; x < waveMaxX; x += 15) {
                    const y = waveY + Math.sin(wavePhase + x * 0.03) * wave.amplitude;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Foam on some waves
                if (wave.y < 0.5 && waveMaxX > 30) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    for (let x = 20; x < waveMaxX - 20; x += 40) {
                        const foamY = waveY + Math.sin(wavePhase + x * 0.03) * wave.amplitude;
                        ctx.beginPath();
                        ctx.ellipse(x, foamY, 12, 3, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            ctx.restore();

            // Sea stacks (rocks in ocean)
            seaStacks.sort((a, b) => a.depth - b.depth);
            for (const stack of seaStacks) {
                if (stack.depth < 0.02 || stack.depth > 0.7) continue;

                const y = depthToY(stack.depth);
                const scale = depthToScale(stack.depth);
                const d = stack.depth;
                const oceanMaxX = Math.max(0, getRoadX(Math.min(d, 1)) - getRoadWidth(Math.min(d, 1)) - 15);
                if (oceanMaxX < 30) continue;

                const x = stack.x * oceanMaxX;

                const w = stack.width * scale;
                const h = stack.height * scale;

                // Shadow in water
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(x + 5, y + 3, w * 0.8, h * 0.15, 0, 0, Math.PI * 2);
                ctx.fill();

                // Rock body
                ctx.fillStyle = COLORS.cliff;
                ctx.beginPath();
                ctx.moveTo(x - w/2, y);
                ctx.lineTo(x - w/2 + w * 0.2, y - h * 0.7);
                ctx.quadraticCurveTo(x, y - h - (stack.hasTop ? h * 0.2 : 0), x + w/2 - w * 0.2, y - h * 0.6);
                ctx.lineTo(x + w/2, y);
                ctx.closePath();
                ctx.fill();

                // Highlight
                ctx.fillStyle = COLORS.cliffLight;
                ctx.beginPath();
                ctx.moveTo(x - w/4, y - h * 0.3);
                ctx.lineTo(x, y - h * 0.9);
                ctx.lineTo(x + w/6, y - h * 0.5);
                ctx.closePath();
                ctx.fill();

                // Vegetation tuft
                if (stack.hasTop && stack.depth > 0.15) {
                    ctx.fillStyle = COLORS.grass;
                    ctx.beginPath();
                    ctx.arc(x, y - h - 3 * scale, 5 * scale, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawCliffs() {
            // Distant headlands on left
            ctx.fillStyle = '#4a5a5a';
            ctx.beginPath();
            ctx.moveTo(0, horizonY);
            ctx.lineTo(0, horizonY - 30);
            ctx.quadraticCurveTo(50, horizonY - 50, 100, horizonY - 20);
            ctx.quadraticCurveTo(140, horizonY - 35, 180, horizonY);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#5a6a6a';
            ctx.beginPath();
            ctx.moveTo(140, horizonY);
            ctx.lineTo(160, horizonY - 25);
            ctx.quadraticCurveTo(200, horizonY - 40, 250, horizonY);
            ctx.closePath();
            ctx.fill();
        }

        function drawLand() {
            // Coastal meadow/cliffs on RIGHT side
            const grassGrad = ctx.createLinearGradient(0, horizonY, 0, H);
            grassGrad.addColorStop(0, COLORS.grassLight);
            grassGrad.addColorStop(0.5, COLORS.grass);
            grassGrad.addColorStop(1, COLORS.grassDark);

            ctx.fillStyle = grassGrad;
            ctx.beginPath();

            const horizonRoadX = getRoadX(0) + getRoadWidth(0);
            ctx.moveTo(horizonRoadX + 3, horizonY);
            ctx.lineTo(W, horizonY);
            ctx.lineTo(W, H);

            const bottomRoadX = getRoadX(1) + getRoadWidth(1);
            ctx.lineTo(bottomRoadX + 3, H);
            ctx.closePath();
            ctx.fill();

            // Grass texture
            ctx.save();
            ctx.globalAlpha = 0.08;
            for (let y = horizonY + 10; y < H; y += 12) {
                const d = (y - horizonY) / (H - horizonY);
                const roadRightEdge = getRoadX(d) + getRoadWidth(d) + 5;
                ctx.strokeStyle = y % 24 === 0 ? '#8aaa75' : '#4a6a40';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(roadRightEdge, y);
                ctx.lineTo(W, y);
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawRoad() {
            // Draw road segments with perspective
            for (let d = 0; d <= 1.05; d += 0.02) {
                const y1 = depthToY(d);
                const y2 = depthToY(d + 0.02);
                const x1 = getRoadX(d);
                const x2 = getRoadX(d + 0.02);
                const w1 = getRoadWidth(d);
                const w2 = getRoadWidth(d + 0.02);

                const roadShade = Math.min(d, 1) * 0.15;
                ctx.fillStyle = `rgb(${58 + roadShade * 20}, ${58 + roadShade * 20}, ${56 + roadShade * 15})`;
                ctx.beginPath();
                ctx.moveTo(x1 - w1, y1);
                ctx.lineTo(x1 + w1, y1);
                ctx.lineTo(x2 + w2, y2);
                ctx.lineTo(x2 - w2, y2);
                ctx.closePath();
                ctx.fill();

                // Subtle road texture
                if (d > 0.3 && d < 1) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    const texY = y1 + Math.random() * (y2 - y1);
                    ctx.fillRect(x1 - w1 * 0.8, texY, w1 * 1.6, 1);
                }
            }

            // Edge lines
            ctx.strokeStyle = COLORS.lineWhite;
            ctx.lineWidth = 2;
            ctx.setLineDash([]);

            // Left edge
            ctx.beginPath();
            for (let d = 0; d <= 1.05; d += 0.02) {
                const y = depthToY(d);
                const x = getRoadX(Math.min(d, 1)) - getRoadWidth(Math.min(d, 1));
                if (d === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Right edge
            ctx.beginPath();
            for (let d = 0; d <= 1.05; d += 0.02) {
                const y = depthToY(d);
                const x = getRoadX(Math.min(d, 1)) + getRoadWidth(Math.min(d, 1));
                if (d === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Center dashed line
            ctx.strokeStyle = COLORS.lineYellow;
            ctx.lineWidth = 2.5;
            ctx.setLineDash([10, 10]);
            ctx.lineDashOffset = -(distance * 0.4) % 20;
            ctx.beginPath();
            for (let d = 0; d <= 1.05; d += 0.02) {
                const y = depthToY(d);
                const x = getRoadX(Math.min(d, 1));
                if (d === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawGrass() {
            for (const g of grasses) {
                if (g.depth < 0.1 || g.depth > 1) continue;

                const y = depthToY(g.depth);
                const scale = depthToScale(g.depth);
                const roadX = getRoadX(g.depth);
                const roadW = getRoadWidth(g.depth);

                let x;
                if (g.side === 'right') {
                    x = roadX + roadW + g.offset * scale;
                    if (x > W - 10) continue;  // Skip if off screen
                } else {
                    const leftEdge = roadX - roadW;
                    if (leftEdge < 20) continue;  // Skip if ocean
                    x = leftEdge - g.offset * scale;
                }

                const sway = Math.sin(time * 0.05 + g.sway) * 3 * scale;

                ctx.strokeStyle = COLORS.grass;
                ctx.lineWidth = 1;

                for (let b = 0; b < g.blades; b++) {
                    const bladeX = x + (b - g.blades/2) * 2 * scale;
                    const bladeH = g.height * scale * (0.7 + Math.random() * 0.3);
                    const bladeSway = sway + Math.sin(b) * 2;

                    ctx.beginPath();
                    ctx.moveTo(bladeX, y);
                    ctx.quadraticCurveTo(bladeX + bladeSway * 0.5, y - bladeH * 0.5, bladeX + bladeSway, y - bladeH);
                    ctx.stroke();
                }
            }
        }

        function drawWildflowers() {
            for (const f of wildflowers) {
                if (f.depth < 0.15 || f.depth > 0.95) continue;

                const y = depthToY(f.depth);
                const scale = depthToScale(f.depth);
                const roadX = getRoadX(f.depth);
                const roadW = getRoadWidth(f.depth);

                const x = roadX + roadW + f.offset * scale;
                if (x > W - 20) continue;  // Skip if off screen

                for (let i = 0; i < f.count; i++) {
                    const fx = x + (i - f.count/2) * f.spread * scale * 0.3;
                    const fy = y - 2 + Math.sin(i) * 3 * scale;
                    const flowerSize = (f.type === 'poppy' ? 3 : 2) * scale;

                    // Stem
                    ctx.strokeStyle = '#5a7a4a';
                    ctx.lineWidth = 1;
                    const stemSway = Math.sin(time * 0.04 + i + f.depth * 10) * 2;
                    ctx.beginPath();
                    ctx.moveTo(fx, y);
                    ctx.quadraticCurveTo(fx + stemSway, fy + 5, fx + stemSway, fy - flowerSize);
                    ctx.stroke();

                    // Flower
                    ctx.fillStyle = f.type === 'poppy' ? COLORS.poppy : COLORS.lupine;
                    if (f.type === 'poppy') {
                        ctx.beginPath();
                        ctx.arc(fx + stemSway, fy - flowerSize - 2, flowerSize, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        for (let p = 0; p < 3; p++) {
                            ctx.beginPath();
                            ctx.arc(fx + stemSway, fy - flowerSize - p * 3 * scale, flowerSize * 0.7, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }
        }

        function drawCypressTrees() {
            cypressTrees.sort((a, b) => a.depth - b.depth);

            for (const tree of cypressTrees) {
                if (tree.depth < 0.08 || tree.depth > 1) continue;

                const y = depthToY(tree.depth);
                const scale = depthToScale(tree.depth);
                const roadX = getRoadX(tree.depth);
                const roadW = getRoadWidth(tree.depth);

                const x = roadX + roadW + tree.offset * scale;
                if (x > W - 15) continue;
                const h = tree.height * scale;
                const w = h * 0.5;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(tree.lean);

                // Gnarled trunk with character
                const trunkW = w * 0.12;
                ctx.fillStyle = '#2a1f18';
                ctx.beginPath();
                ctx.moveTo(-trunkW, 0);
                ctx.quadraticCurveTo(-trunkW * 1.5, -h * 0.25, -trunkW * 0.8, -h * 0.45);
                ctx.lineTo(trunkW * 0.8, -h * 0.45);
                ctx.quadraticCurveTo(trunkW * 1.2, -h * 0.2, trunkW, 0);
                ctx.closePath();
                ctx.fill();

                // Main branch reaching windward
                ctx.strokeStyle = '#2a1f18';
                ctx.lineWidth = trunkW * 0.6;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(0, -h * 0.4);
                ctx.quadraticCurveTo(w * 0.4, -h * 0.55, w * 0.7, -h * 0.5);
                ctx.stroke();

                // Deepest foliage layer (shadow/depth)
                ctx.fillStyle = '#1a3328';
                drawFoliageCluster(w * 0.65, -h * 0.52, w * 0.45, h * 0.28, 0.3);
                drawFoliageCluster(w * 0.2, -h * 0.7, w * 0.35, h * 0.22, 0.2);
                drawFoliageCluster(-w * 0.1, -h * 0.55, w * 0.25, h * 0.18, 0.1);

                // Mid foliage layer
                ctx.fillStyle = '#234a38';
                drawFoliageCluster(w * 0.55, -h * 0.55, w * 0.4, h * 0.25, 0.25);
                drawFoliageCluster(w * 0.15, -h * 0.72, w * 0.32, h * 0.2, 0.15);
                drawFoliageCluster(w * 0.35, -h * 0.65, w * 0.28, h * 0.18, 0.2);

                // Top highlight foliage (catches light)
                ctx.fillStyle = '#2d5a45';
                drawFoliageCluster(w * 0.5, -h * 0.58, w * 0.32, h * 0.2, 0.2);
                drawFoliageCluster(w * 0.25, -h * 0.75, w * 0.25, h * 0.16, 0.1);

                // Windswept tips (trailing wisps)
                ctx.fillStyle = '#1a3328';
                ctx.beginPath();
                ctx.moveTo(w * 0.7, -h * 0.48);
                ctx.quadraticCurveTo(w * 0.9, -h * 0.45, w * 1.0, -h * 0.42);
                ctx.quadraticCurveTo(w * 0.85, -h * 0.5, w * 0.7, -h * 0.52);
                ctx.fill();

                ctx.restore();
            }
        }

        // Helper for organic foliage clusters
        function drawFoliageCluster(cx, cy, rx, ry, wobble) {
            ctx.beginPath();
            const points = 8;
            for (let i = 0; i <= points; i++) {
                const angle = (i / points) * Math.PI * 2;
                const radiusVar = 1 + Math.sin(angle * 3 + wobble * 10) * 0.15;
                const px = cx + Math.cos(angle) * rx * radiusVar;
                const py = cy + Math.sin(angle) * ry * radiusVar;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
        }

        function drawFencePosts() {
            fencePosts.sort((a, b) => a.depth - b.depth);

            for (const post of fencePosts) {
                if (post.depth < 0.1 || post.depth > 1) continue;

                const y = depthToY(post.depth);
                const scale = depthToScale(post.depth);
                const roadX = getRoadX(post.depth);
                const roadW = getRoadWidth(post.depth);

                const x = roadX + roadW + post.offset * scale;
                if (x > W - 10) continue;  // Skip if off screen
                const h = post.height * scale;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(post.lean);

                ctx.fillStyle = '#6a5a4a';
                ctx.fillRect(-2 * scale, -h, 4 * scale, h);

                // Wire
                if (Math.random() > 0.5 && scale > 0.4) {
                    ctx.strokeStyle = 'rgba(80, 70, 60, 0.4)';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(2 * scale, -h * 0.7);
                    ctx.lineTo(40 * scale, -h * 0.65 + Math.sin(time * 0.1) * 2);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        function drawHazards() {
            hazards.sort((a, b) => a.depth - b.depth);

            for (const h of hazards) {
                if (h.depth < 0.02 || h.depth > 1.1) continue;  // Draw from very far away

                const y = depthToY(h.depth);
                const scale = depthToScale(h.depth);
                const roadX = getRoadX(h.depth);
                const roadW = getRoadWidth(h.depth);
                const x = roadX + h.laneX * roadW;

                if (h.type === 'rock') {
                    // Varied realistic rocks
                    const size = 40 * scale * h.size;
                    const rockType = h.rockType || 0;

                    // Shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.beginPath();
                    ctx.ellipse(x + 4 * scale, y + 3 * scale, size * 1.1, size * 0.25, 0.1, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.save();
                    ctx.translate(x, y - size * 0.35);
                    ctx.rotate(h.rotation);

                    if (rockType === 0) {
                        // Rounded boulder - coastal granite
                        ctx.fillStyle = '#5a5550';
                        ctx.beginPath();
                        ctx.moveTo(-size * 0.55, size * 0.3);
                        ctx.quadraticCurveTo(-size * 0.6, 0, -size * 0.45, -size * 0.35);
                        ctx.quadraticCurveTo(-size * 0.2, -size * 0.5, size * 0.1, -size * 0.45);
                        ctx.quadraticCurveTo(size * 0.45, -size * 0.35, size * 0.55, 0);
                        ctx.quadraticCurveTo(size * 0.5, size * 0.35, size * 0.3, size * 0.4);
                        ctx.lineTo(-size * 0.4, size * 0.35);
                        ctx.closePath();
                        ctx.fill();

                        // Highlight - rounded
                        ctx.fillStyle = '#7a7570';
                        ctx.beginPath();
                        ctx.ellipse(-size * 0.15, -size * 0.25, size * 0.25, size * 0.18, -0.3, 0, Math.PI * 2);
                        ctx.fill();

                        // Dark underside
                        ctx.fillStyle = '#3a3530';
                        ctx.beginPath();
                        ctx.ellipse(size * 0.1, size * 0.2, size * 0.35, size * 0.12, 0.2, 0, Math.PI * 2);
                        ctx.fill();

                    } else if (rockType === 1) {
                        // Angular/jagged rock
                        ctx.fillStyle = '#4a4540';
                        ctx.beginPath();
                        ctx.moveTo(-size * 0.5, size * 0.35);
                        ctx.lineTo(-size * 0.55, -size * 0.1);
                        ctx.lineTo(-size * 0.3, -size * 0.45);
                        ctx.lineTo(0, -size * 0.55);
                        ctx.lineTo(size * 0.25, -size * 0.4);
                        ctx.lineTo(size * 0.5, -size * 0.2);
                        ctx.lineTo(size * 0.55, size * 0.25);
                        ctx.lineTo(size * 0.35, size * 0.4);
                        ctx.closePath();
                        ctx.fill();

                        // Angular highlight facets
                        ctx.fillStyle = '#6a6560';
                        ctx.beginPath();
                        ctx.moveTo(-size * 0.3, -size * 0.45);
                        ctx.lineTo(0, -size * 0.55);
                        ctx.lineTo(size * 0.1, -size * 0.2);
                        ctx.lineTo(-size * 0.2, -size * 0.15);
                        ctx.closePath();
                        ctx.fill();

                        // Crack line
                        ctx.strokeStyle = '#2a2520';
                        ctx.lineWidth = 1.5 * scale;
                        ctx.beginPath();
                        ctx.moveTo(-size * 0.1, -size * 0.4);
                        ctx.lineTo(size * 0.15, size * 0.1);
                        ctx.stroke();

                    } else {
                        // Flat slab rock
                        ctx.fillStyle = '#555048';
                        ctx.beginPath();
                        ctx.moveTo(-size * 0.6, size * 0.15);
                        ctx.lineTo(-size * 0.5, -size * 0.2);
                        ctx.lineTo(size * 0.4, -size * 0.25);
                        ctx.lineTo(size * 0.6, size * 0.1);
                        ctx.lineTo(size * 0.5, size * 0.3);
                        ctx.lineTo(-size * 0.45, size * 0.25);
                        ctx.closePath();
                        ctx.fill();

                        // Top surface lighter
                        ctx.fillStyle = '#706a60';
                        ctx.beginPath();
                        ctx.moveTo(-size * 0.5, -size * 0.2);
                        ctx.lineTo(-size * 0.35, -size * 0.3);
                        ctx.lineTo(size * 0.35, -size * 0.35);
                        ctx.lineTo(size * 0.4, -size * 0.25);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Moss patches (if mossy)
                    if (h.mossy) {
                        ctx.fillStyle = '#4a5a40';
                        ctx.beginPath();
                        ctx.ellipse(-size * 0.2, -size * 0.1, size * 0.15, size * 0.08, 0.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.ellipse(size * 0.15, -size * 0.25, size * 0.1, size * 0.06, -0.3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.restore();

                } else if (h.type === 'deer') {
                    // Deer - proper proportions, viewed from behind/side as it crosses
                    const deerScale = scale * 1.6;
                    const runCycle = Math.sin(time * 0.5 + h.animPhase);

                    ctx.save();
                    ctx.translate(x, y);
                    ctx.scale(h.runDirection, 1);

                    // Shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(0, 2, 22 * deerScale, 6 * deerScale, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Back legs - long and slender, animated
                    ctx.fillStyle = '#5a4535';
                    const backLegOffset = runCycle * 8;
                    // Left back leg
                    ctx.beginPath();
                    ctx.moveTo(-12 * deerScale, -12 * deerScale);
                    ctx.quadraticCurveTo(-14 * deerScale - backLegOffset, -6 * deerScale, -10 * deerScale - backLegOffset * 0.5, 0);
                    ctx.lineTo(-7 * deerScale - backLegOffset * 0.5, 0);
                    ctx.quadraticCurveTo(-9 * deerScale - backLegOffset, -6 * deerScale, -8 * deerScale, -12 * deerScale);
                    ctx.fill();
                    // Right back leg
                    ctx.beginPath();
                    ctx.moveTo(-8 * deerScale, -12 * deerScale);
                    ctx.quadraticCurveTo(-10 * deerScale + backLegOffset, -6 * deerScale, -6 * deerScale + backLegOffset * 0.5, 0);
                    ctx.lineTo(-3 * deerScale + backLegOffset * 0.5, 0);
                    ctx.quadraticCurveTo(-5 * deerScale + backLegOffset, -6 * deerScale, -4 * deerScale, -12 * deerScale);
                    ctx.fill();

                    // Front legs - animated opposite
                    const frontLegOffset = -runCycle * 8;
                    ctx.beginPath();
                    ctx.moveTo(10 * deerScale, -14 * deerScale);
                    ctx.quadraticCurveTo(12 * deerScale - frontLegOffset, -7 * deerScale, 8 * deerScale - frontLegOffset * 0.5, 0);
                    ctx.lineTo(5 * deerScale - frontLegOffset * 0.5, 0);
                    ctx.quadraticCurveTo(7 * deerScale - frontLegOffset, -7 * deerScale, 6 * deerScale, -14 * deerScale);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(14 * deerScale, -14 * deerScale);
                    ctx.quadraticCurveTo(16 * deerScale + frontLegOffset, -7 * deerScale, 12 * deerScale + frontLegOffset * 0.5, 0);
                    ctx.lineTo(9 * deerScale + frontLegOffset * 0.5, 0);
                    ctx.quadraticCurveTo(11 * deerScale + frontLegOffset, -7 * deerScale, 10 * deerScale, -14 * deerScale);
                    ctx.fill();

                    // Body - horizontal oval
                    ctx.fillStyle = '#8a6a55';
                    ctx.beginPath();
                    ctx.ellipse(0, -22 * deerScale, 20 * deerScale, 12 * deerScale, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Lighter underside
                    ctx.fillStyle = '#b8a090';
                    ctx.beginPath();
                    ctx.ellipse(0, -17 * deerScale, 14 * deerScale, 6 * deerScale, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // White rump patch (characteristic of deer)
                    ctx.fillStyle = '#f5efe8';
                    ctx.beginPath();
                    ctx.ellipse(-16 * deerScale, -22 * deerScale, 6 * deerScale, 8 * deerScale, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Tail - raised when running
                    ctx.fillStyle = '#f5efe8';
                    ctx.beginPath();
                    ctx.moveTo(-20 * deerScale, -24 * deerScale);
                    ctx.quadraticCurveTo(-26 * deerScale, -30 * deerScale, -24 * deerScale, -35 * deerScale);
                    ctx.quadraticCurveTo(-22 * deerScale, -30 * deerScale, -18 * deerScale, -26 * deerScale);
                    ctx.fill();

                    // Neck - angled forward
                    ctx.fillStyle = '#8a6a55';
                    ctx.beginPath();
                    ctx.moveTo(14 * deerScale, -28 * deerScale);
                    ctx.quadraticCurveTo(22 * deerScale, -38 * deerScale, 24 * deerScale, -48 * deerScale);
                    ctx.lineTo(18 * deerScale, -48 * deerScale);
                    ctx.quadraticCurveTo(16 * deerScale, -38 * deerScale, 10 * deerScale, -28 * deerScale);
                    ctx.fill();

                    // Head - elongated oval
                    ctx.fillStyle = '#7a5a48';
                    ctx.beginPath();
                    ctx.ellipse(24 * deerScale, -52 * deerScale, 6 * deerScale, 8 * deerScale, 0.4, 0, Math.PI * 2);
                    ctx.fill();

                    // Snout
                    ctx.fillStyle = '#6a4a38';
                    ctx.beginPath();
                    ctx.ellipse(30 * deerScale, -50 * deerScale, 4 * deerScale, 3 * deerScale, 0.3, 0, Math.PI * 2);
                    ctx.fill();

                    // Nose
                    ctx.fillStyle = '#2a2020';
                    ctx.beginPath();
                    ctx.ellipse(33 * deerScale, -49 * deerScale, 2 * deerScale, 1.5 * deerScale, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Eye
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.arc(26 * deerScale, -54 * deerScale, 1.5 * deerScale, 0, Math.PI * 2);
                    ctx.fill();

                    // Antlers for bucks
                    if (h.isBuck && h.antlerSize > 0) {
                        const antlerS = h.antlerSize * deerScale;
                        ctx.strokeStyle = '#5a4a3a';
                        ctx.lineWidth = 2.5 * deerScale;
                        ctx.lineCap = 'round';

                        // Left antler
                        ctx.beginPath();
                        ctx.moveTo(22 * deerScale, -60 * deerScale);
                        ctx.quadraticCurveTo(15 * deerScale, -72 * antlerS, 10 * deerScale, -78 * antlerS);
                        ctx.stroke();
                        // Tines
                        ctx.lineWidth = 1.8 * deerScale;
                        ctx.beginPath();
                        ctx.moveTo(14 * deerScale, -70 * antlerS);
                        ctx.lineTo(8 * deerScale, -68 * antlerS);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(12 * deerScale, -75 * antlerS);
                        ctx.lineTo(5 * deerScale, -72 * antlerS);
                        ctx.stroke();

                        // Right antler
                        ctx.lineWidth = 2.5 * deerScale;
                        ctx.beginPath();
                        ctx.moveTo(26 * deerScale, -59 * deerScale);
                        ctx.quadraticCurveTo(32 * deerScale, -70 * antlerS, 38 * deerScale, -75 * antlerS);
                        ctx.stroke();
                        // Tines
                        ctx.lineWidth = 1.8 * deerScale;
                        ctx.beginPath();
                        ctx.moveTo(33 * deerScale, -68 * antlerS);
                        ctx.lineTo(40 * deerScale, -65 * antlerS);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(36 * deerScale, -72 * antlerS);
                        ctx.lineTo(44 * deerScale, -70 * antlerS);
                        ctx.stroke();
                    }

                    // Ears - large and alert (positioned differently for bucks/does)
                    const earOffset = h.isBuck ? 5 : 0;
                    ctx.fillStyle = '#7a5a48';
                    ctx.beginPath();
                    ctx.ellipse((18 - earOffset) * deerScale, -62 * deerScale, 3 * deerScale, 7 * deerScale, -0.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse((28 + earOffset) * deerScale, -61 * deerScale, 3 * deerScale, 7 * deerScale, 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    // Inner ear
                    ctx.fillStyle = '#c0a090';
                    ctx.beginPath();
                    ctx.ellipse((18 - earOffset) * deerScale, -61 * deerScale, 1.5 * deerScale, 4 * deerScale, -0.4, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();

                } else if (h.type === 'debris') {
                    // BIGGER scattered debris
                    for (let p = 0; p < h.pieces; p++) {
                        const px = x + (p - h.pieces/2) * h.spread * roadW * 0.6;
                        const psize = (14 + Math.random() * 12) * scale;

                        // Shadow
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.beginPath();
                        ctx.ellipse(px, y + 2, psize * 1.1, psize * 0.35, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Debris piece
                        ctx.save();
                        ctx.translate(px, y - psize * 0.35);
                        ctx.rotate(p * 0.8 + h.animPhase);

                        if (p % 2 === 0) {
                            // Rock - darker
                            ctx.fillStyle = '#4a3a2a';
                            ctx.beginPath();
                            ctx.arc(0, 0, psize * 0.7, 0, Math.PI * 2);
                            ctx.fill();
                            // Highlight
                            ctx.fillStyle = '#7a6a5a';
                            ctx.beginPath();
                            ctx.arc(-psize * 0.2, -psize * 0.2, psize * 0.3, 0, Math.PI * 2);
                            ctx.fill();
                        } else {
                            // Branch/log - thicker
                            ctx.fillStyle = '#5a4030';
                            ctx.fillRect(-psize * 1.2, -3 * scale, psize * 2.4, 6 * scale);
                            ctx.fillStyle = '#7a6050';
                            ctx.fillRect(-psize * 1.2, -3 * scale, psize * 2.4, 2 * scale);
                        }
                        ctx.restore();
                    }

                } else if (h.type === 'log') {
                    // Fallen tree log across road
                    const logLen = 80 * scale * h.length;
                    const logRad = 12 * scale;

                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(h.rotation);

                    // Shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
                    ctx.beginPath();
                    ctx.ellipse(4 * scale, 4 * scale, logLen * 0.55, logRad * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Log body - cylinder shape
                    ctx.fillStyle = h.hasBark ? '#4a3828' : '#6a5040';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, logLen * 0.5, logRad, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Bark texture lines
                    if (h.hasBark) {
                        ctx.strokeStyle = '#3a2818';
                        ctx.lineWidth = 1;
                        for (let i = -4; i <= 4; i++) {
                            const bx = i * logLen * 0.1;
                            ctx.beginPath();
                            ctx.moveTo(bx, -logRad * 0.7);
                            ctx.lineTo(bx + 2, logRad * 0.7);
                            ctx.stroke();
                        }
                    }

                    // Top highlight
                    ctx.fillStyle = h.hasBark ? '#5a4838' : '#8a7060';
                    ctx.beginPath();
                    ctx.ellipse(0, -logRad * 0.3, logLen * 0.45, logRad * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // End grain (cut end)
                    ctx.fillStyle = '#8a7560';
                    ctx.beginPath();
                    ctx.ellipse(logLen * 0.48, 0, logRad * 0.3, logRad * 0.9, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Rings
                    ctx.strokeStyle = '#6a5545';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.ellipse(logLen * 0.48, 0, logRad * 0.15, logRad * 0.5, 0, 0, Math.PI * 2);
                    ctx.stroke();

                    // Broken branches sticking up
                    if (h.hasBranches) {
                        ctx.strokeStyle = '#4a3828';
                        ctx.lineWidth = 3 * scale;
                        ctx.lineCap = 'round';
                        // Branch 1
                        ctx.beginPath();
                        ctx.moveTo(-logLen * 0.2, -logRad * 0.5);
                        ctx.quadraticCurveTo(-logLen * 0.25, -logRad * 2, -logLen * 0.15, -logRad * 2.5);
                        ctx.stroke();
                        ctx.lineWidth = 2 * scale;
                        ctx.beginPath();
                        ctx.moveTo(-logLen * 0.2, -logRad * 1.8);
                        ctx.lineTo(-logLen * 0.28, -logRad * 2.2);
                        ctx.stroke();
                        // Branch 2
                        ctx.lineWidth = 2.5 * scale;
                        ctx.beginPath();
                        ctx.moveTo(logLen * 0.15, -logRad * 0.6);
                        ctx.quadraticCurveTo(logLen * 0.12, -logRad * 1.5, logLen * 0.2, -logRad * 2);
                        ctx.stroke();
                    }

                    ctx.restore();
                }
            }
        }

        function drawPlayerCar() {
            const x = W/2 + playerX * 160;
            const y = H - 65 + carBounce;

            // Flash during invincibility
            if (invincibleTimer > 0 && Math.floor(time / 6) % 2 === 1) return;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(carTilt);

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 42, 50, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tires with rotation
            ctx.fillStyle = '#1a1a1a';
            const tireW = 10;
            const tireH = 22;

            ctx.save();
            ctx.translate(-40, 20);
            ctx.rotate(Math.sin(wheelSpin) * 0.1);
            ctx.fillRect(-tireW/2, -tireH/2, tireW, tireH);
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            for (let t = -8; t < 8; t += 4) {
                ctx.beginPath();
                ctx.moveTo(-tireW/2, t);
                ctx.lineTo(tireW/2, t);
                ctx.stroke();
            }
            ctx.restore();

            ctx.save();
            ctx.translate(40, 20);
            ctx.rotate(Math.sin(wheelSpin) * 0.1);
            ctx.fillRect(-tireW/2, -tireH/2, tireW, tireH);
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            for (let t = -8; t < 8; t += 4) {
                ctx.beginPath();
                ctx.moveTo(-tireW/2, t);
                ctx.lineTo(tireW/2, t);
                ctx.stroke();
            }
            ctx.restore();

            // Body - Volvo 240 wagon
            ctx.fillStyle = COLORS.carBody;
            ctx.beginPath();
            ctx.moveTo(-45, 28);
            ctx.lineTo(-42, -8);
            ctx.lineTo(-38, -35);
            ctx.lineTo(38, -35);
            ctx.lineTo(42, -8);
            ctx.lineTo(45, 28);
            ctx.closePath();
            ctx.fill();

            // Body side highlight
            ctx.fillStyle = COLORS.carLight;
            ctx.beginPath();
            ctx.moveTo(-45, 28);
            ctx.lineTo(-42, -8);
            ctx.lineTo(-38, -35);
            ctx.lineTo(-20, -35);
            ctx.lineTo(-20, 28);
            ctx.closePath();
            ctx.fill();

            // Rear window
            ctx.fillStyle = COLORS.carWindow;
            ctx.fillRect(-28, -32, 56, 20);

            // Window reflection
            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.beginPath();
            ctx.moveTo(-26, -30);
            ctx.lineTo(-26, -15);
            ctx.lineTo(-5, -30);
            ctx.closePath();
            ctx.fill();

            // Taillights - Volvo vertical style
            ctx.fillStyle = COLORS.carTaillight;
            ctx.fillRect(-42, -8, 6, 28);
            ctx.fillRect(36, -8, 6, 28);

            // Brake light glow
            if (keys.down) {
                ctx.fillStyle = 'rgba(255, 50, 50, 0.5)';
                ctx.beginPath();
                ctx.ellipse(-39, 6, 12, 20, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(39, 6, 12, 20, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Chrome bumper
            ctx.fillStyle = COLORS.carChrome;
            ctx.fillRect(-42, 22, 84, 5);

            // California license plate
            ctx.fillStyle = '#f8f8f8';
            ctx.fillRect(-18, 3, 36, 14);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 0.5;
            ctx.strokeRect(-18, 3, 36, 14);
            ctx.fillStyle = '#c41e3a';
            ctx.fillRect(-18, 3, 36, 2);
            ctx.fillStyle = '#1a3a6a';
            ctx.font = 'bold 7px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('4SEA742', 0, 14);

            // Exhaust puff when accelerating
            if (keys.up && playerSpeed > 100) {
                ctx.fillStyle = `rgba(180, 180, 180, ${0.2 + enginePulse * 0.2})`;
                for (let p = 0; p < 3; p++) {
                    const puffX = -15 + Math.sin(time * 0.2 + p) * 5 - (time * 0.5 % 20) - p * 8;
                    const puffY = 35 + Math.sin(time * 0.3 + p) * 3;
                    const puffSize = 4 + p * 2 + (time * 0.3 % 5);
                    ctx.beginPath();
                    ctx.arc(puffX, puffY, puffSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.restore();
        }

        function drawUI() {
            // Distance to Sea Ranch
            const progress = Math.min(1, distance / goalDistance);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(20, 12, 160, 24);

            ctx.fillStyle = '#f5f0e0';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('SEA RANCH', 28, 26);

            // Progress bar
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(100, 18, 70, 10);
            ctx.fillStyle = '#80d080';
            ctx.fillRect(100, 18, 70 * progress, 10);

            // Car condition - Supergraphic semicircle gauge
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(W - 85, 10, 70, 28);

            ctx.fillStyle = '#f5f0e0';
            ctx.font = 'bold 9px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('CAR', W - 50, 19);

            // Draw damage as diminishing semicircles (Supergraphic style)
            const gaugeX = W - 50;
            const gaugeY = 30;
            const remaining = maxDamage - damage;

            for (let i = 0; i < maxDamage; i++) {
                const arcX = gaugeX - 18 + i * 18;
                if (i < remaining) {
                    // Healthy - filled arc
                    ctx.fillStyle = '#2E5DA8';  // Sea Ranch blue
                    ctx.beginPath();
                    ctx.arc(arcX, gaugeY, 6, Math.PI, 0);
                    ctx.fill();
                } else {
                    // Damaged - red X
                    ctx.strokeStyle = '#C41E3A';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(arcX - 4, gaugeY - 4);
                    ctx.lineTo(arcX + 4, gaugeY + 4);
                    ctx.moveTo(arcX + 4, gaugeY - 4);
                    ctx.lineTo(arcX - 4, gaugeY + 4);
                    ctx.stroke();
                }
            }
        }

        function drawAtmosphere() {
            // Golden hour haze
            const sunsetProgress = gameTime / maxTime;

            // Overall warm tint
            ctx.fillStyle = `rgba(255, 200, 120, ${0.03 + sunsetProgress * 0.05})`;
            ctx.fillRect(0, 0, W, H);

            // Low sun lens flare
            if (sunsetProgress > 0.3) {
                const flareAlpha = (sunsetProgress - 0.3) * 0.15;
                ctx.fillStyle = `rgba(255, 220, 150, ${flareAlpha})`;
                ctx.beginPath();
                ctx.ellipse(120, horizonY - 25, 100, 30, 0.2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ═══════════════════════════════════════════════════════════
        // RENDER ORCHESTRATION
        // ═══════════════════════════════════════════════════════════
        function render() {
            ctx.save();
            SeaRanchStyle.applyShake(ctx);

            // Layer the scene back to front
            drawSky();
            drawCliffs();
            drawOcean();
            drawLand();
            drawRoad();

            // Scenery by depth
            drawFencePosts();
            drawGrass();
            drawWildflowers();
            drawCypressTrees();

            // Hazards
            drawHazards();

            // Player
            drawPlayerCar();

            // Atmosphere overlay
            drawAtmosphere();

            // Juice
            SeaRanchStyle.updateJuice(ctx);
            ctx.restore();

            // UI on top
            drawUI();
        }

        function drawWin() {
            render();
            SeaRanchStyle.drawWinScreen(ctx, 'Welcome to Sea Ranch', `safe arrival after ${hazardsDodged} close calls`);
        }

        function drawLose() {
            render();
            SeaRanchStyle.drawLoseScreen(ctx, 'Car Trouble', 'had to turn back to Jenner');
        }

        // ═══════════════════════════════════════════════════════════
        // UTILITIES
        // ═══════════════════════════════════════════════════════════
        function lerpColor(c1, c2, t) {
            const r1 = parseInt(c1.slice(1, 3), 16);
            const g1 = parseInt(c1.slice(3, 5), 16);
            const b1 = parseInt(c1.slice(5, 7), 16);
            const r2 = parseInt(c2.slice(1, 3), 16);
            const g2 = parseInt(c2.slice(3, 5), 16);
            const b2 = parseInt(c2.slice(5, 7), 16);
            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);
            return `rgb(${r}, ${g}, ${b})`;
        }

        // ═══════════════════════════════════════════════════════════
        // GAME LOOP
        // ═══════════════════════════════════════════════════════════
        let lastTime = performance.now();

        function gameLoop(now) {
            const dt = Math.min(0.05, (now - lastTime) / 1000);
            lastTime = now;

            if (gameState === 'title') {
                // Title card handled by HTML
            } else if (gameState === 'playing') {
                update(dt);
                render();
            } else if (gameState === 'win') {
                drawWin();
            } else if (gameState === 'lose') {
                drawLose();
            }

            // Film grain for consistent aesthetic
            if (gameState !== 'title') {
                SeaRanchStyle.applyWeatheredEffect(ctx, { grainOpacity: 0.05, vignetteIntensity: 0.12 });
            }

            requestAnimationFrame(gameLoop);
        }

        SeaRanchStyle.setupTouchControls();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
